{"version":3,"sources":["../../src/experimental/erc7715GrantPermissionsAction.ts","../../src/experimental/erc7710RedeemDelegationAction.ts","../../src/experimental/delegationStorage.ts","../../src/experimental/index.ts"],"names":["toHex"],"mappings":"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","sourcesContent":["import {\n  Account,\n  Address,\n  Chain,\n  Client,\n  Hex,\n  isHex,\n  RpcSchema,\n  toHex,\n  Transport,\n} from 'viem';\n\n/**\n * Represents a custom permission with arbitrary data.\n */\nexport type Permission = {\n  data: Record<string, unknown>;\n  type: string;\n  rules?: Record<string, unknown>;\n  isRequired?: boolean;\n};\n\n/**\n * Represents a native token stream permission.\n * This allows for continuous token streaming with defined parameters.\n */\nexport type NativeTokenStreamPermission = Permission & {\n  type: 'native-token-stream';\n  data: {\n    initialAmount?: bigint;\n    amountPerSecond: bigint;\n    startTime: number;\n    maxAmount?: number;\n    justification: string;\n  };\n};\n\nexport type SignerParam =\n  | Address\n  | { type: 'account'; data: { address: Address } }\n  | { type: string; data: Record<string, unknown> };\n\n/**\n * Parameters for a permission request.\n *\n * @template Signer - The type of the signer provided, either an Address or Account.\n */\nexport type PermissionRequest<Signer extends SignerParam> = {\n  chainId: number;\n  // address to which the permission request is targetting\n  address?: Address;\n  // Timestamp (in seconds) that specifies the time by which this permission MUST expire.\n  expiry: number;\n  // The permission to grant to the user.\n  permission: Permission;\n  // Account to assign the permission to.\n  signer: Signer;\n  // Whether the caller allows the permission to be adjusted.\n  isAdjustmentAllowed?: boolean;\n};\n\n/**\n * Response from a permission request, including additional metadata.\n */\nexport type PermissionResponse = PermissionRequest<Address> & {\n  // the PermissionsContext for the granted permission\n  context: Hex;\n\n  // ERC-4337 Factory and data to deploy smart contract account.\n  accountMeta?: {\n    factory: Hex;\n    factoryData: Hex;\n  }[];\n\n  // This is actually _either_ a userOpBuilder or a delegationManager, but the typings\n  // become complicated to consume if we encode it correctly.\n  signerMeta?: {\n    userOpBuilder?: Hex;\n    delegationManager?: Hex;\n  };\n};\n\n/**\n * Parameters for granting permissions.\n *\n * @template Signer - The type of the signer, either an Address or Account.\n */\nexport type GrantPermissionsParameters = PermissionRequest<SignerParam>[];\n\n/**\n * Return type for the grant permissions action.\n */\nexport type GrantPermissionsReturnType = PermissionResponse[];\n/**\n * Represents the authorization status of installed MetaMask Snaps.\n *\n * @property {string} version - The version of the installed Snap.\n * @property {string} id - The unique identifier of the Snap.\n * @property {boolean} enabled - Whether the Snap is currently enabled.\n * @property {boolean} blocked - Whether the Snap is currently blocked.\n */\nexport type SnapAuthorizations = Record<\n  string,\n  { version: string; id: string; enabled: boolean; blocked: boolean }\n>;\n\n/**\n * RPC schema for MetaMask Snap-related methods.\n *\n * Extends the base RPC schema with methods specific to interacting with Snaps:\n * - `wallet_invokeSnap`: Invokes a method on a specific Snap.\n * - `wallet_getSnaps`: Retrieves all installed Snaps and their authorization status.\n * - `wallet_requestSnaps`: Requests permission to use specific Snaps.\n */\nexport type SnapRpcSchema = RpcSchema &\n  [\n    {\n      Method: 'wallet_invokeSnap';\n      Params: {\n        snapId: string;\n        request: {\n          method: string;\n          params: unknown[];\n        };\n      };\n      ReturnType: unknown;\n    },\n    {\n      Method: 'wallet_getSnaps';\n      Params: {};\n      ReturnType: SnapAuthorizations;\n    },\n    {\n      Method: 'wallet_requestSnaps';\n      Params: Record<string, unknown>;\n      ReturnType: SnapAuthorizations;\n    },\n  ];\n\n/**\n * A Viem client extended with MetaMask Snap-specific RPC methods.\n *\n * This client type allows for interaction with MetaMask Snaps through\n * the standard Viem client interface, with added type safety for\n * Snap-specific methods.\n */\nexport type SnapClient = Client<\n  Transport,\n  Chain | undefined,\n  Account | undefined,\n  SnapRpcSchema\n>;\n\n/**\n * Checks if a specific snap is authorized, within the specified authorizations object..\n *\n * @param authorizations - The SnapAuthorizations object containing installed Snaps and their authorization status.\n * @param snapId - The ID of the snap to check.\n * @returns A boolean indicating whether the snap is authorized.\n */\nconst isSnapAuthorized = (\n  authorizations: SnapAuthorizations,\n  snapId: string,\n) => {\n  const authorization = authorizations[snapId];\n  const isAuthorized =\n    (authorization?.enabled && !authorization?.blocked) || false;\n\n  return isAuthorized;\n};\n\n/**\n * Requests re-authorization of a specific snap.\n *\n * @param client - The SnapClient instance used to interact with MetaMask Snaps.\n * @param snapId - The ID of the snap to re-authorize.\n * @returns A promise that resolves to a boolean indicating whether the snap was re-authorized.\n */\nconst reAuthorize = async (client: SnapClient, snapId: string) => {\n  const newAuthorizations = await client.request({\n    method: 'wallet_requestSnaps',\n    params: {\n      [snapId]: {},\n    },\n  });\n\n  return isSnapAuthorized(newAuthorizations, snapId);\n};\n\n/**\n * Ensures that the required MetaMask Snaps for ERC-7715 permissions are authorized.\n *\n * @param client - The SnapClient instance used to interact with MetaMask Snaps.\n * @param snapIds - Optional object containing custom snap IDs to use.\n * @param snapIds.kernelSnapId - Custom ID for the permissions kernel snap (defaults to 'npm:@metamask/permissions-kernel-snap').\n * @param snapIds.providerSnapId - Custom ID for the permissions provider snap (defaults to 'npm:@metamask/gator-permissions-snap').\n * @returns A promise that resolves to a boolean indicating whether both snaps are authorized.\n *\n * @remarks\n * This function attempts to authorize both the kernel and provider snaps required for ERC-7715 permissions.\n * It returns true only if both snaps are successfully authorized.\n */\nexport async function ensureSnapsAuthorized(\n  client: SnapClient,\n  snapIds?: { kernelSnapId: string; providerSnapId: string },\n) {\n  const kernelSnapId =\n    snapIds?.kernelSnapId ?? 'npm:@metamask/permissions-kernel-snap';\n  const providerSnapId =\n    snapIds?.providerSnapId ?? 'npm:@metamask/gator-permissions-snap';\n\n  const existingAuthorizations = await client.request({\n    method: 'wallet_getSnaps',\n    params: {},\n  });\n\n  if (\n    !isSnapAuthorized(existingAuthorizations, kernelSnapId) &&\n    !(await reAuthorize(client, kernelSnapId))\n  ) {\n    return false;\n  }\n\n  if (\n    !isSnapAuthorized(existingAuthorizations, providerSnapId) &&\n    !(await reAuthorize(client, providerSnapId))\n  ) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Grants permissions according to EIP-7715 specification.\n *\n * @template Signer - The type of the signer, either an Address or Account.\n * @param client - The client to use for the request.\n * @param parameters - The permissions requests to grant.\n * @param kernelSnapId - The ID of the kernel snap to invoke, defaults to 'npm:@metamask/permissions-kernel-snap'.\n * @returns A promise that resolves to the permission responses.\n *\n * @remarks\n * This function formats the permissions requests and invokes the wallet snap to grant permissions.\n * It will throw an error if the permissions could not be granted.\n */\nexport async function erc7715GrantPermissionsAction(\n  client: SnapClient,\n  parameters: GrantPermissionsParameters,\n  kernelSnapId: string = 'npm:@metamask/permissions-kernel-snap',\n): Promise<GrantPermissionsReturnType> {\n  const formattedParameters = parameters.map(formatPermissionsRequest);\n\n  const result = await client.request(\n    {\n      method: 'wallet_invokeSnap',\n      params: {\n        snapId: kernelSnapId,\n        request: {\n          method: 'wallet_grantPermissions',\n          params: formattedParameters,\n        },\n      },\n    },\n    { retryCount: 0 },\n  );\n\n  if (result === null) {\n    throw new Error('Failed to grant permissions');\n  }\n\n  return result as any as GrantPermissionsReturnType;\n}\n\n/**\n * Formats a permissions request for submission to the wallet.\n *\n * @param parameters - The permissions request to format.\n * @returns The formatted permissions request.\n *\n * @internal\n */\nfunction formatPermissionsRequest(parameters: PermissionRequest<SignerParam>) {\n  const { chainId, address, expiry, isAdjustmentAllowed } = parameters;\n\n  const permissionFormatter = getPermissionFormatter(\n    parameters.permission.type,\n  );\n\n  const signerAddress =\n    typeof parameters.signer === 'string'\n      ? parameters.signer\n      : parameters.signer.data.address;\n\n  const optionalFields = {\n    ...(isAdjustmentAllowed !== undefined ? { isAdjustmentAllowed } : {}),\n    ...(address ? { address } : {}),\n  };\n\n  return {\n    ...optionalFields,\n    chainId: toHex(chainId),\n    expiry,\n    permission: permissionFormatter(parameters.permission),\n    signer: {\n      // only support account type for now\n      type: 'account',\n      data: {\n        address: signerAddress,\n      },\n    },\n  };\n}\n\nfunction toHexOrThrow(\n  value: Parameters<typeof toHex>[0] | undefined,\n  message?: string,\n) {\n  if (value === undefined || value === null) {\n    throw new Error(message || 'Invalid parameters: value is required');\n  }\n  if (typeof value === 'string') {\n    if (!isHex(value)) {\n      throw new Error('Invalid parameters: invalid hex value');\n    }\n    return value;\n  }\n\n  return toHex(value);\n}\n\nfunction getPermissionFormatter(\n  permissionType: string,\n): (permission: Permission) => Permission {\n  switch (permissionType) {\n    case 'native-token-stream':\n      return (permission: Permission) =>\n        formatNativeTokenStreamPermission(\n          permission as NativeTokenStreamPermission,\n        );\n    default:\n      return (permission: Permission) => ({ ...permission });\n  }\n}\n\nfunction formatNativeTokenStreamPermission(\n  permission: NativeTokenStreamPermission,\n): Permission {\n  if (permission.data.justification == undefined) {\n    throw new Error('Invalid parameters: justification is required');\n  }\n  if (permission.data.startTime == undefined) {\n    throw new Error('Invalid parameters: startTime is required');\n  }\n\n  const optionalFields = {\n    ...(permission.data.initialAmount != undefined && {\n      initialAmount: toHexOrThrow(permission.data.initialAmount),\n    }),\n    ...(permission.data.maxAmount != undefined && {\n      maxAmount: toHexOrThrow(permission.data.maxAmount),\n    }),\n  };\n\n  return {\n    ...permission,\n    data: {\n      amountPerSecond: toHexOrThrow(\n        permission.data.amountPerSecond,\n        'Invalid parameters: amountPerSecond is required',\n      ),\n      startTime: Number(permission.data.startTime),\n      justification: permission.data.justification,\n      ...optionalFields,\n    },\n  };\n}\n","import {\n  createExecution,\n  getDeleGatorEnvironment,\n  DelegationManager,\n  encodeExecutionCalldatas,\n  SINGLE_DEFAULT_MODE,\n} from '@metamask/delegation-utils';\nimport {\n  Account,\n  Chain,\n  concat,\n  encodeFunctionData,\n  Hex,\n  isAddressEqual,\n  OneOf,\n  PublicClient,\n  SendTransactionParameters,\n  SendTransactionRequest,\n  Transport,\n  WalletClient,\n} from 'viem';\n\nimport {\n  BundlerClient,\n  SendUserOperationParameters,\n  SmartAccount,\n} from 'viem/account-abstraction';\nimport type { Call } from 'src/types';\n\nexport type DelegatedCall = Call &\n  OneOf<{ permissionsContext: Hex; delegationManager: Hex } | {}>;\n\nexport type SendTransactionWithDelegationParameters<\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  request extends SendTransactionRequest<\n    chain,\n    chainOverride\n  > = SendTransactionRequest<chain, chainOverride>,\n> = SendTransactionParameters<chain, account, chainOverride, request> & {\n  permissionsContext: Hex;\n  delegationManager: Hex;\n};\n\nexport async function sendTransactionWithDelegationAction<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: WalletClient<Transport, chain, account>,\n  args: SendTransactionWithDelegationParameters<chain, account>,\n) {\n  const executions = [\n    createExecution(args.to || undefined, args.value, args.data),\n  ];\n\n  const calldata = encodeFunctionData({\n    abi: DelegationManager.abi,\n    functionName: 'redeemDelegations',\n    args: [\n      [args.permissionsContext],\n      [SINGLE_DEFAULT_MODE],\n      encodeExecutionCalldatas([executions]),\n    ],\n  });\n\n  const hash = await client.sendTransaction({\n    ...args,\n    to: args.delegationManager,\n    data: calldata,\n  } as unknown as SendTransactionParameters);\n\n  return hash;\n}\n\nexport type SendUserOperationWithDelegationParameters<\n  account extends SmartAccount | undefined = SmartAccount | undefined,\n  accountOverride extends SmartAccount | undefined = SmartAccount | undefined,\n> = SendUserOperationParameters<account, accountOverride, DelegatedCall[]> & {\n  accountMetadata?: { factory: Hex; factoryData: Hex }[];\n  calls: DelegatedCall[];\n  publicClient: PublicClient<Transport, Chain>;\n};\n\n/**\n * Broadcasts a User Operation with delegation to the Bundler.\n *\n * @param client - Client to use\n * @param parameters - Parameters for the user operation with delegation\n * @returns The User Operation hash\n *\n * @example\n * import { createBundlerClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n *\n * const bundlerClient = createBundlerClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const userOpHash = await sendUserOperationWithDelegationAction(bundlerClient, {\n *   account: bobSmartAccount,\n *   calls: [\n *     {\n *       to: aliceCounterContractAddress,\n *       data: encodeFunctionData({\n *         abi: CounterMetadata.abi,\n *         functionName: 'increment',\n *       }),\n *       value: 0n,\n *       permissionsContext: '0x...',\n *       delegationManager: '0x...',\n *     },\n *   ],\n *   accountMetadata: [{ factory: '0x...', factoryData: '0x...' }], // Optional: for deploying accounts\n * })\n */\nexport async function sendUserOperationWithDelegationAction<\n  account extends SmartAccount | undefined,\n  accountOverride extends SmartAccount | undefined = undefined,\n>(\n  client: BundlerClient<Transport, Chain | undefined, account>,\n  parameters: SendUserOperationWithDelegationParameters<\n    account,\n    accountOverride\n  >,\n) {\n  if (parameters.accountMetadata) {\n    const { publicClient } = parameters;\n\n    const includedAccountKeys: Record<Hex, boolean> = {};\n\n    const chainId = publicClient.chain?.id;\n\n    if (!chainId) {\n      throw new Error('Chain ID is not set');\n    }\n\n    const { SimpleFactory } = getDeleGatorEnvironment(chainId);\n\n    const uniqueAccountMetadatas = parameters.accountMetadata.filter(\n      (accountMetadata) => {\n        if (!isAddressEqual(accountMetadata.factory, SimpleFactory)) {\n          throw new Error(\n            `Invalid accountMetadata: ${accountMetadata.factory} is not allowed.`,\n          );\n        }\n\n        // ensure that factory calls are not duplicated\n        const accountKey = concat([\n          accountMetadata.factory,\n          accountMetadata.factoryData,\n        ]);\n        const isDuplicate = includedAccountKeys[accountKey];\n\n        includedAccountKeys[accountKey] = true;\n        return !isDuplicate;\n      },\n    );\n\n    const factoryCalls = (\n      await Promise.all(\n        uniqueAccountMetadatas.map(async ({ factory, factoryData }) => {\n          const isDeployed = await publicClient\n            .call({\n              to: factory,\n              data: factoryData,\n            })\n            .then(() => false)\n            .catch(() => true);\n\n          if (isDeployed) {\n            return undefined;\n          } else {\n            return {\n              to: factory,\n              value: 0n,\n              data: factoryData,\n            };\n          }\n        }),\n      )\n    ).filter((call: Call | undefined) => call !== undefined) as Call[];\n\n    parameters.calls = [...factoryCalls, ...parameters.calls];\n  }\n\n  return client.sendUserOperation(\n    parameters as unknown as SendUserOperationParameters,\n  );\n}\n","import { type Hex, toHex } from 'viem';\nimport {\n  type Delegation,\n  getDelegationHashOffchain,\n} from '@metamask/delegation-utils';\n\ntype ErrorResponse = {\n  error: string;\n  data?: any;\n};\n\nexport type APIStoreDelegationResponse = {\n  delegationHash: Hex;\n};\n\n/**\n * Represents the allowed filters when querying the data store for delegations.\n */\nexport enum DelegationStoreFilter {\n  Given = 'GIVEN',\n  Received = 'RECEIVED',\n  All = 'ALL',\n}\n\n/**\n * Public Delegation Storage Service environments. To be used in the\n * DeleGationStorageService config.\n *\n * new DelegationStorageClient({\n *   ...,\n *   environment: DelegationStorageEnvironment.prod\n * })\n */\nexport const DelegationStorageEnvironment: {\n  [K in 'dev' | 'prod']: Environment;\n} = {\n  dev: { apiUrl: 'https://passkeys.dev-api.cx.metamask.io' },\n  prod: { apiUrl: 'https://passkeys.api.cx.metamask.io' },\n};\n\nexport type Environment = {\n  apiUrl: string;\n};\n\nexport type DelegationStorageConfig = {\n  apiKey: string;\n  apiKeyId: string;\n  environment: Environment;\n  fetcher?: typeof fetch;\n};\n\nexport class DelegationStorageClient {\n  private readonly _apiVersionPrefix = 'api/v0';\n\n  private readonly _config: DelegationStorageConfig;\n\n  private readonly _fetcher: typeof fetch;\n  private readonly _apiUrl: string;\n\n  constructor(config: DelegationStorageConfig) {\n    let apiUrl = config.environment.apiUrl.replace(/\\/+$/, ''); // Remove trailing slashes\n    if (!apiUrl.endsWith(this._apiVersionPrefix)) {\n      apiUrl = `${apiUrl}/${this._apiVersionPrefix}`;\n    }\n    this._fetcher = this._initializeFetcher(config);\n    this._config = config;\n    this._apiUrl = apiUrl;\n  }\n\n  /**\n   * Initializes the fetch function for HTTP requests.\n   *\n   * - Uses `config.fetcher` if provided.\n   * - Falls back to global `fetch` if available.\n   * - Throws an error if no fetch function is available.\n   *\n   * @param config - Configuration object that may include a custom fetch function.\n   * @returns The fetch function to be used for HTTP requests.\n   * @throws Error if no fetch function is available in the environment.\n   */\n  private _initializeFetcher(config: DelegationStorageConfig): typeof fetch {\n    if (config.fetcher) {\n      return config.fetcher;\n    } else if (typeof globalThis?.fetch === 'function') {\n      return globalThis.fetch.bind(globalThis);\n    } else {\n      throw new Error(\n        'Fetch API is not available in this environment. Please provide a fetch function in the config.',\n      );\n    }\n  }\n\n  /**\n   * Fetch the delegation chain from the Delegation Storage Service, ending with\n   * the specified leaf delegation.\n   *\n   * @param leafDelegationOrDelegationHash - the leaf delegation, or the hash\n   * of the leaf delegation\n   * @returns resolves to the delegation chain - empty array if the delegation\n   * is not found.\n   */\n  async getDelegationChain(\n    leafDelegationOrDelegationHash: Hex | Delegation,\n  ): Promise<Delegation[]> {\n    const leafDelegationHash =\n      typeof leafDelegationOrDelegationHash === 'string'\n        ? leafDelegationOrDelegationHash\n        : getDelegationHashOffchain(leafDelegationOrDelegationHash);\n\n    const response = await this._fetcher(\n      `${this._apiUrl}/delegation/chain/${leafDelegationHash}`,\n      {\n        method: 'GET',\n        headers: {\n          Authorization: `Bearer ${this._config.apiKey}`,\n          'x-api-key-id': this._config.apiKeyId,\n        },\n      },\n    );\n\n    const responseData: Delegation[] | ErrorResponse = await response.json();\n\n    if ('error' in responseData) {\n      throw new Error(\n        `Failed to fetch delegation chain: ${responseData.error}`,\n      );\n    }\n\n    return responseData;\n  }\n\n  /**\n   * Fetch the delegations from the Delegation Storage Service, either `Received`\n   * by, or `Given` by, (or both: `All`) the specified deleGatorAddress. Defaults\n   * to `Received`\n   *\n   * @param deleGatorAddress - The deleGatorAddress to retrieve the delegations for.\n   * @param filterMode - the DelegationStoreFilter mode - defaults to Received\n   * @returns resolves to the list of delegations received by the deleGatorAddress, empty array if the delegations are not found.\n   */\n  async fetchDelegations(\n    deleGatorAddress: Hex,\n    filterMode = DelegationStoreFilter.Received,\n  ): Promise<Delegation[]> {\n    const response = await this._fetcher(\n      `${this._apiUrl}/delegation/accounts/${deleGatorAddress}?filter=${filterMode}`,\n      {\n        method: 'GET',\n        headers: {\n          Authorization: `Bearer ${this._config.apiKey}`,\n          'x-api-key-id': this._config.apiKeyId,\n        },\n      },\n    );\n\n    const responseData: Delegation[] | ErrorResponse = await response.json();\n\n    if ('error' in responseData) {\n      throw new Error(`Failed to fetch delegations: ${responseData.error}`);\n    }\n\n    return responseData;\n  }\n\n  /**\n   * Store the specified delegation in the Delegation Storage Service.\n   *\n   * @param delegation - the delegation to store\n   * @returns resolves to the delegation hash indicating successfully stored\n   */\n  async storeDelegation(delegation: Delegation): Promise<Hex> {\n    if (!delegation.signature || delegation.signature === '0x') {\n      throw new Error('Delegation must be signed to be stored');\n    }\n\n    const delegationHash = getDelegationHashOffchain(delegation);\n\n    const body = JSON.stringify(\n      {\n        ...delegation,\n        metadata: [],\n      },\n      (_, value: any) =>\n        typeof value === 'bigint' || typeof value === 'number'\n          ? toHex(value)\n          : value,\n      2,\n    );\n\n    const response = await this._fetcher(`${this._apiUrl}/delegation/store`, {\n      method: 'POST',\n      headers: {\n        Authorization: `Bearer ${this._config.apiKey}`,\n        'x-api-key-id': this._config.apiKeyId,\n        'Content-Type': 'application/json',\n      },\n      body,\n    });\n\n    const responseData: APIStoreDelegationResponse | ErrorResponse =\n      await response.json();\n\n    if ('error' in responseData) {\n      throw new Error(responseData.error);\n    }\n\n    if (responseData.delegationHash !== delegationHash) {\n      throw Error(\n        'Failed to store the Delegation, the hash returned from the MM delegation storage API does not match the hash of the delegation',\n      );\n    }\n\n    return responseData.delegationHash;\n  }\n}\n","import { Client, Transport, WalletClient } from 'viem';\n\nimport {\n  ensureSnapsAuthorized,\n  erc7715GrantPermissionsAction,\n  SnapClient,\n  type GrantPermissionsParameters,\n} from './erc7715GrantPermissionsAction';\nimport {\n  sendTransactionWithDelegationAction,\n  SendTransactionWithDelegationParameters,\n  sendUserOperationWithDelegationAction,\n  SendUserOperationWithDelegationParameters,\n} from './erc7710RedeemDelegationAction';\nimport { BundlerClient } from 'viem/account-abstraction';\n\nexport {\n  erc7715GrantPermissionsAction as grantPermissions,\n  type GrantPermissionsParameters,\n  type GrantPermissionsReturnType,\n} from './erc7715GrantPermissionsAction';\n\nexport {\n  DelegationStorageClient,\n  type DelegationStoreFilter,\n  type Environment,\n  type DelegationStorageConfig,\n} from './delegationStorage';\n\nexport const erc7715ProviderActions =\n  (snapIds?: { kernelSnapId: string; providerSnapId: string }) =>\n  (client: Client<Transport>) => ({\n    grantPermissions: async (parameters: GrantPermissionsParameters) => {\n      if (!(await ensureSnapsAuthorized(client as SnapClient, snapIds))) {\n        throw new Error('Snaps not authorized');\n      }\n\n      return erc7715GrantPermissionsAction(\n        client as SnapClient,\n        parameters,\n        snapIds?.kernelSnapId,\n      );\n    },\n  });\n\nexport const erc7710WalletActions = () => (client: WalletClient) => ({\n  sendTransactionWithDelegation: (\n    args: SendTransactionWithDelegationParameters,\n  ) => sendTransactionWithDelegationAction(client, args),\n});\n\nexport const erc7710BundlerActions = () => (client: Client) => ({\n  sendUserOperationWithDelegation: (\n    args: SendUserOperationWithDelegationParameters,\n  ) => sendUserOperationWithDelegationAction(client as BundlerClient, args),\n});\n"]}