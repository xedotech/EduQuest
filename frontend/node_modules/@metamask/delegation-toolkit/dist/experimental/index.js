"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } } function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; } var _class;require('../chunk-SSYGV25P.js');

// src/experimental/erc7715GrantPermissionsAction.ts



var _viem = require('viem');
var isSnapAuthorized = (authorizations, snapId) => {
  const authorization = authorizations[snapId];
  const isAuthorized = _optionalChain([authorization, 'optionalAccess', _2 => _2.enabled]) && !_optionalChain([authorization, 'optionalAccess', _3 => _3.blocked]) || false;
  return isAuthorized;
};
var reAuthorize = async (client, snapId) => {
  const newAuthorizations = await client.request({
    method: "wallet_requestSnaps",
    params: {
      [snapId]: {}
    }
  });
  return isSnapAuthorized(newAuthorizations, snapId);
};
async function ensureSnapsAuthorized(client, snapIds) {
  const kernelSnapId = _nullishCoalesce(_optionalChain([snapIds, 'optionalAccess', _4 => _4.kernelSnapId]), () => ( "npm:@metamask/permissions-kernel-snap"));
  const providerSnapId = _nullishCoalesce(_optionalChain([snapIds, 'optionalAccess', _5 => _5.providerSnapId]), () => ( "npm:@metamask/gator-permissions-snap"));
  const existingAuthorizations = await client.request({
    method: "wallet_getSnaps",
    params: {}
  });
  if (!isSnapAuthorized(existingAuthorizations, kernelSnapId) && !await reAuthorize(client, kernelSnapId)) {
    return false;
  }
  if (!isSnapAuthorized(existingAuthorizations, providerSnapId) && !await reAuthorize(client, providerSnapId)) {
    return false;
  }
  return true;
}
async function erc7715GrantPermissionsAction(client, parameters, kernelSnapId = "npm:@metamask/permissions-kernel-snap") {
  const formattedParameters = parameters.map(formatPermissionsRequest);
  const result = await client.request(
    {
      method: "wallet_invokeSnap",
      params: {
        snapId: kernelSnapId,
        request: {
          method: "wallet_grantPermissions",
          params: formattedParameters
        }
      }
    },
    { retryCount: 0 }
  );
  if (result === null) {
    throw new Error("Failed to grant permissions");
  }
  return result;
}
function formatPermissionsRequest(parameters) {
  const { chainId, address, expiry, isAdjustmentAllowed } = parameters;
  const permissionFormatter = getPermissionFormatter(
    parameters.permission.type
  );
  const signerAddress = typeof parameters.signer === "string" ? parameters.signer : parameters.signer.data.address;
  const optionalFields = {
    ...isAdjustmentAllowed !== void 0 ? { isAdjustmentAllowed } : {},
    ...address ? { address } : {}
  };
  return {
    ...optionalFields,
    chainId: _viem.toHex.call(void 0, chainId),
    expiry,
    permission: permissionFormatter(parameters.permission),
    signer: {
      // only support account type for now
      type: "account",
      data: {
        address: signerAddress
      }
    }
  };
}
function toHexOrThrow(value, message) {
  if (value === void 0 || value === null) {
    throw new Error(message || "Invalid parameters: value is required");
  }
  if (typeof value === "string") {
    if (!_viem.isHex.call(void 0, value)) {
      throw new Error("Invalid parameters: invalid hex value");
    }
    return value;
  }
  return _viem.toHex.call(void 0, value);
}
function getPermissionFormatter(permissionType) {
  switch (permissionType) {
    case "native-token-stream":
      return (permission) => formatNativeTokenStreamPermission(
        permission
      );
    default:
      return (permission) => ({ ...permission });
  }
}
function formatNativeTokenStreamPermission(permission) {
  if (permission.data.justification == void 0) {
    throw new Error("Invalid parameters: justification is required");
  }
  if (permission.data.startTime == void 0) {
    throw new Error("Invalid parameters: startTime is required");
  }
  const optionalFields = {
    ...permission.data.initialAmount != void 0 && {
      initialAmount: toHexOrThrow(permission.data.initialAmount)
    },
    ...permission.data.maxAmount != void 0 && {
      maxAmount: toHexOrThrow(permission.data.maxAmount)
    }
  };
  return {
    ...permission,
    data: {
      amountPerSecond: toHexOrThrow(
        permission.data.amountPerSecond,
        "Invalid parameters: amountPerSecond is required"
      ),
      startTime: Number(permission.data.startTime),
      justification: permission.data.justification,
      ...optionalFields
    }
  };
}

// src/experimental/erc7710RedeemDelegationAction.ts






var _delegationutils = require('@metamask/delegation-utils');





async function sendTransactionWithDelegationAction(client, args) {
  const executions = [
    _delegationutils.createExecution.call(void 0, args.to || void 0, args.value, args.data)
  ];
  const calldata = _viem.encodeFunctionData.call(void 0, {
    abi: _delegationutils.DelegationManager.abi,
    functionName: "redeemDelegations",
    args: [
      [args.permissionsContext],
      [_delegationutils.SINGLE_DEFAULT_MODE],
      _delegationutils.encodeExecutionCalldatas.call(void 0, [executions])
    ]
  });
  const hash = await client.sendTransaction({
    ...args,
    to: args.delegationManager,
    data: calldata
  });
  return hash;
}
async function sendUserOperationWithDelegationAction(client, parameters) {
  if (parameters.accountMetadata) {
    const { publicClient } = parameters;
    const includedAccountKeys = {};
    const chainId = _optionalChain([publicClient, 'access', _6 => _6.chain, 'optionalAccess', _7 => _7.id]);
    if (!chainId) {
      throw new Error("Chain ID is not set");
    }
    const { SimpleFactory } = _delegationutils.getDeleGatorEnvironment.call(void 0, chainId);
    const uniqueAccountMetadatas = parameters.accountMetadata.filter(
      (accountMetadata) => {
        if (!_viem.isAddressEqual.call(void 0, accountMetadata.factory, SimpleFactory)) {
          throw new Error(
            `Invalid accountMetadata: ${accountMetadata.factory} is not allowed.`
          );
        }
        const accountKey = _viem.concat.call(void 0, [
          accountMetadata.factory,
          accountMetadata.factoryData
        ]);
        const isDuplicate = includedAccountKeys[accountKey];
        includedAccountKeys[accountKey] = true;
        return !isDuplicate;
      }
    );
    const factoryCalls = (await Promise.all(
      uniqueAccountMetadatas.map(async ({ factory, factoryData }) => {
        const isDeployed = await publicClient.call({
          to: factory,
          data: factoryData
        }).then(() => false).catch(() => true);
        if (isDeployed) {
          return void 0;
        } else {
          return {
            to: factory,
            value: 0n,
            data: factoryData
          };
        }
      })
    )).filter((call) => call !== void 0);
    parameters.calls = [...factoryCalls, ...parameters.calls];
  }
  return client.sendUserOperation(
    parameters
  );
}

// src/experimental/delegationStorage.ts




var DelegationStorageClient = (_class = class {
  __init() {this._apiVersionPrefix = "api/v0"}
  
  
  
  constructor(config) {;_class.prototype.__init.call(this);
    let apiUrl = config.environment.apiUrl.replace(/\/+$/, "");
    if (!apiUrl.endsWith(this._apiVersionPrefix)) {
      apiUrl = `${apiUrl}/${this._apiVersionPrefix}`;
    }
    this._fetcher = this._initializeFetcher(config);
    this._config = config;
    this._apiUrl = apiUrl;
  }
  /**
   * Initializes the fetch function for HTTP requests.
   *
   * - Uses `config.fetcher` if provided.
   * - Falls back to global `fetch` if available.
   * - Throws an error if no fetch function is available.
   *
   * @param config - Configuration object that may include a custom fetch function.
   * @returns The fetch function to be used for HTTP requests.
   * @throws Error if no fetch function is available in the environment.
   */
  _initializeFetcher(config) {
    if (config.fetcher) {
      return config.fetcher;
    } else if (typeof _optionalChain([globalThis, 'optionalAccess', _8 => _8.fetch]) === "function") {
      return globalThis.fetch.bind(globalThis);
    } else {
      throw new Error(
        "Fetch API is not available in this environment. Please provide a fetch function in the config."
      );
    }
  }
  /**
   * Fetch the delegation chain from the Delegation Storage Service, ending with
   * the specified leaf delegation.
   *
   * @param leafDelegationOrDelegationHash - the leaf delegation, or the hash
   * of the leaf delegation
   * @returns resolves to the delegation chain - empty array if the delegation
   * is not found.
   */
  async getDelegationChain(leafDelegationOrDelegationHash) {
    const leafDelegationHash = typeof leafDelegationOrDelegationHash === "string" ? leafDelegationOrDelegationHash : _delegationutils.getDelegationHashOffchain.call(void 0, leafDelegationOrDelegationHash);
    const response = await this._fetcher(
      `${this._apiUrl}/delegation/chain/${leafDelegationHash}`,
      {
        method: "GET",
        headers: {
          Authorization: `Bearer ${this._config.apiKey}`,
          "x-api-key-id": this._config.apiKeyId
        }
      }
    );
    const responseData = await response.json();
    if ("error" in responseData) {
      throw new Error(
        `Failed to fetch delegation chain: ${responseData.error}`
      );
    }
    return responseData;
  }
  /**
   * Fetch the delegations from the Delegation Storage Service, either `Received`
   * by, or `Given` by, (or both: `All`) the specified deleGatorAddress. Defaults
   * to `Received`
   *
   * @param deleGatorAddress - The deleGatorAddress to retrieve the delegations for.
   * @param filterMode - the DelegationStoreFilter mode - defaults to Received
   * @returns resolves to the list of delegations received by the deleGatorAddress, empty array if the delegations are not found.
   */
  async fetchDelegations(deleGatorAddress, filterMode = "RECEIVED" /* Received */) {
    const response = await this._fetcher(
      `${this._apiUrl}/delegation/accounts/${deleGatorAddress}?filter=${filterMode}`,
      {
        method: "GET",
        headers: {
          Authorization: `Bearer ${this._config.apiKey}`,
          "x-api-key-id": this._config.apiKeyId
        }
      }
    );
    const responseData = await response.json();
    if ("error" in responseData) {
      throw new Error(`Failed to fetch delegations: ${responseData.error}`);
    }
    return responseData;
  }
  /**
   * Store the specified delegation in the Delegation Storage Service.
   *
   * @param delegation - the delegation to store
   * @returns resolves to the delegation hash indicating successfully stored
   */
  async storeDelegation(delegation) {
    if (!delegation.signature || delegation.signature === "0x") {
      throw new Error("Delegation must be signed to be stored");
    }
    const delegationHash = _delegationutils.getDelegationHashOffchain.call(void 0, delegation);
    const body = JSON.stringify(
      {
        ...delegation,
        metadata: []
      },
      (_, value) => typeof value === "bigint" || typeof value === "number" ? _viem.toHex.call(void 0, value) : value,
      2
    );
    const response = await this._fetcher(`${this._apiUrl}/delegation/store`, {
      method: "POST",
      headers: {
        Authorization: `Bearer ${this._config.apiKey}`,
        "x-api-key-id": this._config.apiKeyId,
        "Content-Type": "application/json"
      },
      body
    });
    const responseData = await response.json();
    if ("error" in responseData) {
      throw new Error(responseData.error);
    }
    if (responseData.delegationHash !== delegationHash) {
      throw Error(
        "Failed to store the Delegation, the hash returned from the MM delegation storage API does not match the hash of the delegation"
      );
    }
    return responseData.delegationHash;
  }
}, _class);

// src/experimental/index.ts
var erc7715ProviderActions = (snapIds) => (client) => ({
  grantPermissions: async (parameters) => {
    if (!await ensureSnapsAuthorized(client, snapIds)) {
      throw new Error("Snaps not authorized");
    }
    return erc7715GrantPermissionsAction(
      client,
      parameters,
      _optionalChain([snapIds, 'optionalAccess', _9 => _9.kernelSnapId])
    );
  }
});
var erc7710WalletActions = () => (client) => ({
  sendTransactionWithDelegation: (args) => sendTransactionWithDelegationAction(client, args)
});
var erc7710BundlerActions = () => (client) => ({
  sendUserOperationWithDelegation: (args) => sendUserOperationWithDelegationAction(client, args)
});






exports.DelegationStorageClient = DelegationStorageClient; exports.erc7710BundlerActions = erc7710BundlerActions; exports.erc7710WalletActions = erc7710WalletActions; exports.erc7715ProviderActions = erc7715ProviderActions; exports.grantPermissions = erc7715GrantPermissionsAction;
//# sourceMappingURL=index.js.map