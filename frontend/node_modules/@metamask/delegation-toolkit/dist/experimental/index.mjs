import "../chunk-E2SEJZTC.mjs";

// src/experimental/erc7715GrantPermissionsAction.ts
import {
  isHex,
  toHex
} from "viem";
var isSnapAuthorized = (authorizations, snapId) => {
  const authorization = authorizations[snapId];
  const isAuthorized = authorization?.enabled && !authorization?.blocked || false;
  return isAuthorized;
};
var reAuthorize = async (client, snapId) => {
  const newAuthorizations = await client.request({
    method: "wallet_requestSnaps",
    params: {
      [snapId]: {}
    }
  });
  return isSnapAuthorized(newAuthorizations, snapId);
};
async function ensureSnapsAuthorized(client, snapIds) {
  const kernelSnapId = snapIds?.kernelSnapId ?? "npm:@metamask/permissions-kernel-snap";
  const providerSnapId = snapIds?.providerSnapId ?? "npm:@metamask/gator-permissions-snap";
  const existingAuthorizations = await client.request({
    method: "wallet_getSnaps",
    params: {}
  });
  if (!isSnapAuthorized(existingAuthorizations, kernelSnapId) && !await reAuthorize(client, kernelSnapId)) {
    return false;
  }
  if (!isSnapAuthorized(existingAuthorizations, providerSnapId) && !await reAuthorize(client, providerSnapId)) {
    return false;
  }
  return true;
}
async function erc7715GrantPermissionsAction(client, parameters, kernelSnapId = "npm:@metamask/permissions-kernel-snap") {
  const formattedParameters = parameters.map(formatPermissionsRequest);
  const result = await client.request(
    {
      method: "wallet_invokeSnap",
      params: {
        snapId: kernelSnapId,
        request: {
          method: "wallet_grantPermissions",
          params: formattedParameters
        }
      }
    },
    { retryCount: 0 }
  );
  if (result === null) {
    throw new Error("Failed to grant permissions");
  }
  return result;
}
function formatPermissionsRequest(parameters) {
  const { chainId, address, expiry, isAdjustmentAllowed } = parameters;
  const permissionFormatter = getPermissionFormatter(
    parameters.permission.type
  );
  const signerAddress = typeof parameters.signer === "string" ? parameters.signer : parameters.signer.data.address;
  const optionalFields = {
    ...isAdjustmentAllowed !== void 0 ? { isAdjustmentAllowed } : {},
    ...address ? { address } : {}
  };
  return {
    ...optionalFields,
    chainId: toHex(chainId),
    expiry,
    permission: permissionFormatter(parameters.permission),
    signer: {
      // only support account type for now
      type: "account",
      data: {
        address: signerAddress
      }
    }
  };
}
function toHexOrThrow(value, message) {
  if (value === void 0 || value === null) {
    throw new Error(message || "Invalid parameters: value is required");
  }
  if (typeof value === "string") {
    if (!isHex(value)) {
      throw new Error("Invalid parameters: invalid hex value");
    }
    return value;
  }
  return toHex(value);
}
function getPermissionFormatter(permissionType) {
  switch (permissionType) {
    case "native-token-stream":
      return (permission) => formatNativeTokenStreamPermission(
        permission
      );
    default:
      return (permission) => ({ ...permission });
  }
}
function formatNativeTokenStreamPermission(permission) {
  if (permission.data.justification == void 0) {
    throw new Error("Invalid parameters: justification is required");
  }
  if (permission.data.startTime == void 0) {
    throw new Error("Invalid parameters: startTime is required");
  }
  const optionalFields = {
    ...permission.data.initialAmount != void 0 && {
      initialAmount: toHexOrThrow(permission.data.initialAmount)
    },
    ...permission.data.maxAmount != void 0 && {
      maxAmount: toHexOrThrow(permission.data.maxAmount)
    }
  };
  return {
    ...permission,
    data: {
      amountPerSecond: toHexOrThrow(
        permission.data.amountPerSecond,
        "Invalid parameters: amountPerSecond is required"
      ),
      startTime: Number(permission.data.startTime),
      justification: permission.data.justification,
      ...optionalFields
    }
  };
}

// src/experimental/erc7710RedeemDelegationAction.ts
import {
  createExecution,
  getDeleGatorEnvironment,
  DelegationManager,
  encodeExecutionCalldatas,
  SINGLE_DEFAULT_MODE
} from "@metamask/delegation-utils";
import {
  concat,
  encodeFunctionData,
  isAddressEqual
} from "viem";
async function sendTransactionWithDelegationAction(client, args) {
  const executions = [
    createExecution(args.to || void 0, args.value, args.data)
  ];
  const calldata = encodeFunctionData({
    abi: DelegationManager.abi,
    functionName: "redeemDelegations",
    args: [
      [args.permissionsContext],
      [SINGLE_DEFAULT_MODE],
      encodeExecutionCalldatas([executions])
    ]
  });
  const hash = await client.sendTransaction({
    ...args,
    to: args.delegationManager,
    data: calldata
  });
  return hash;
}
async function sendUserOperationWithDelegationAction(client, parameters) {
  if (parameters.accountMetadata) {
    const { publicClient } = parameters;
    const includedAccountKeys = {};
    const chainId = publicClient.chain?.id;
    if (!chainId) {
      throw new Error("Chain ID is not set");
    }
    const { SimpleFactory } = getDeleGatorEnvironment(chainId);
    const uniqueAccountMetadatas = parameters.accountMetadata.filter(
      (accountMetadata) => {
        if (!isAddressEqual(accountMetadata.factory, SimpleFactory)) {
          throw new Error(
            `Invalid accountMetadata: ${accountMetadata.factory} is not allowed.`
          );
        }
        const accountKey = concat([
          accountMetadata.factory,
          accountMetadata.factoryData
        ]);
        const isDuplicate = includedAccountKeys[accountKey];
        includedAccountKeys[accountKey] = true;
        return !isDuplicate;
      }
    );
    const factoryCalls = (await Promise.all(
      uniqueAccountMetadatas.map(async ({ factory, factoryData }) => {
        const isDeployed = await publicClient.call({
          to: factory,
          data: factoryData
        }).then(() => false).catch(() => true);
        if (isDeployed) {
          return void 0;
        } else {
          return {
            to: factory,
            value: 0n,
            data: factoryData
          };
        }
      })
    )).filter((call) => call !== void 0);
    parameters.calls = [...factoryCalls, ...parameters.calls];
  }
  return client.sendUserOperation(
    parameters
  );
}

// src/experimental/delegationStorage.ts
import { toHex as toHex2 } from "viem";
import {
  getDelegationHashOffchain
} from "@metamask/delegation-utils";
var DelegationStorageClient = class {
  _apiVersionPrefix = "api/v0";
  _config;
  _fetcher;
  _apiUrl;
  constructor(config) {
    let apiUrl = config.environment.apiUrl.replace(/\/+$/, "");
    if (!apiUrl.endsWith(this._apiVersionPrefix)) {
      apiUrl = `${apiUrl}/${this._apiVersionPrefix}`;
    }
    this._fetcher = this._initializeFetcher(config);
    this._config = config;
    this._apiUrl = apiUrl;
  }
  /**
   * Initializes the fetch function for HTTP requests.
   *
   * - Uses `config.fetcher` if provided.
   * - Falls back to global `fetch` if available.
   * - Throws an error if no fetch function is available.
   *
   * @param config - Configuration object that may include a custom fetch function.
   * @returns The fetch function to be used for HTTP requests.
   * @throws Error if no fetch function is available in the environment.
   */
  _initializeFetcher(config) {
    if (config.fetcher) {
      return config.fetcher;
    } else if (typeof globalThis?.fetch === "function") {
      return globalThis.fetch.bind(globalThis);
    } else {
      throw new Error(
        "Fetch API is not available in this environment. Please provide a fetch function in the config."
      );
    }
  }
  /**
   * Fetch the delegation chain from the Delegation Storage Service, ending with
   * the specified leaf delegation.
   *
   * @param leafDelegationOrDelegationHash - the leaf delegation, or the hash
   * of the leaf delegation
   * @returns resolves to the delegation chain - empty array if the delegation
   * is not found.
   */
  async getDelegationChain(leafDelegationOrDelegationHash) {
    const leafDelegationHash = typeof leafDelegationOrDelegationHash === "string" ? leafDelegationOrDelegationHash : getDelegationHashOffchain(leafDelegationOrDelegationHash);
    const response = await this._fetcher(
      `${this._apiUrl}/delegation/chain/${leafDelegationHash}`,
      {
        method: "GET",
        headers: {
          Authorization: `Bearer ${this._config.apiKey}`,
          "x-api-key-id": this._config.apiKeyId
        }
      }
    );
    const responseData = await response.json();
    if ("error" in responseData) {
      throw new Error(
        `Failed to fetch delegation chain: ${responseData.error}`
      );
    }
    return responseData;
  }
  /**
   * Fetch the delegations from the Delegation Storage Service, either `Received`
   * by, or `Given` by, (or both: `All`) the specified deleGatorAddress. Defaults
   * to `Received`
   *
   * @param deleGatorAddress - The deleGatorAddress to retrieve the delegations for.
   * @param filterMode - the DelegationStoreFilter mode - defaults to Received
   * @returns resolves to the list of delegations received by the deleGatorAddress, empty array if the delegations are not found.
   */
  async fetchDelegations(deleGatorAddress, filterMode = "RECEIVED" /* Received */) {
    const response = await this._fetcher(
      `${this._apiUrl}/delegation/accounts/${deleGatorAddress}?filter=${filterMode}`,
      {
        method: "GET",
        headers: {
          Authorization: `Bearer ${this._config.apiKey}`,
          "x-api-key-id": this._config.apiKeyId
        }
      }
    );
    const responseData = await response.json();
    if ("error" in responseData) {
      throw new Error(`Failed to fetch delegations: ${responseData.error}`);
    }
    return responseData;
  }
  /**
   * Store the specified delegation in the Delegation Storage Service.
   *
   * @param delegation - the delegation to store
   * @returns resolves to the delegation hash indicating successfully stored
   */
  async storeDelegation(delegation) {
    if (!delegation.signature || delegation.signature === "0x") {
      throw new Error("Delegation must be signed to be stored");
    }
    const delegationHash = getDelegationHashOffchain(delegation);
    const body = JSON.stringify(
      {
        ...delegation,
        metadata: []
      },
      (_, value) => typeof value === "bigint" || typeof value === "number" ? toHex2(value) : value,
      2
    );
    const response = await this._fetcher(`${this._apiUrl}/delegation/store`, {
      method: "POST",
      headers: {
        Authorization: `Bearer ${this._config.apiKey}`,
        "x-api-key-id": this._config.apiKeyId,
        "Content-Type": "application/json"
      },
      body
    });
    const responseData = await response.json();
    if ("error" in responseData) {
      throw new Error(responseData.error);
    }
    if (responseData.delegationHash !== delegationHash) {
      throw Error(
        "Failed to store the Delegation, the hash returned from the MM delegation storage API does not match the hash of the delegation"
      );
    }
    return responseData.delegationHash;
  }
};

// src/experimental/index.ts
var erc7715ProviderActions = (snapIds) => (client) => ({
  grantPermissions: async (parameters) => {
    if (!await ensureSnapsAuthorized(client, snapIds)) {
      throw new Error("Snaps not authorized");
    }
    return erc7715GrantPermissionsAction(
      client,
      parameters,
      snapIds?.kernelSnapId
    );
  }
});
var erc7710WalletActions = () => (client) => ({
  sendTransactionWithDelegation: (args) => sendTransactionWithDelegationAction(client, args)
});
var erc7710BundlerActions = () => (client) => ({
  sendUserOperationWithDelegation: (args) => sendUserOperationWithDelegationAction(client, args)
});
export {
  DelegationStorageClient,
  erc7710BundlerActions,
  erc7710WalletActions,
  erc7715ProviderActions,
  erc7715GrantPermissionsAction as grantPermissions
};
//# sourceMappingURL=index.mjs.map