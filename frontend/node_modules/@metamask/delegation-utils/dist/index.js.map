{"version":3,"sources":["../src/index.ts","../src/executions.ts","../src/blockchain.ts","../src/caveats.ts","../src/constants.ts","../src/data.ts","../src/delegation.ts","../src/caveatBuilder/allowedMethodsBuilder.ts","../src/caveatBuilder/allowedTargetsBuilder.ts","../src/caveatBuilder/caveatBuilder.ts","../src/caveatBuilder/deployedBuilder.ts","../src/caveatBuilder/allowedCalldataBuilder.ts","../src/caveatBuilder/erc20BalanceChangeBuilder.ts","../src/caveatBuilder/types.ts","../src/caveatBuilder/valueLteBuilder.ts","../src/caveatBuilder/limitedCallsBuilder.ts","../src/caveatBuilder/idBuilder.ts","../src/caveatBuilder/nonceBuilder.ts","../src/caveatBuilder/timestampBuilder.ts","../src/caveatBuilder/shared.ts","../src/caveatBuilder/blockNumberBuilder.ts","../src/caveatBuilder/erc20TransferAmountBuilder.ts","../src/caveatBuilder/erc20StreamingBuilder.ts","../src/caveatBuilder/nativeTokenStreamingBuilder.ts","../src/caveatBuilder/nativeTokenTransferAmountBuilder.ts","../src/caveatBuilder/nativeBalanceChangeBuilder.ts","../src/caveatBuilder/redeemerBuilder.ts","../src/caveatBuilder/nativeTokenPaymentBuilder.ts","../src/caveatBuilder/argsEqualityCheckBuilder.ts","../src/caveatBuilder/erc1155BalanceChangeBuilder.ts","../src/caveatBuilder/erc721BalanceChangeBuilder.ts","../src/caveatBuilder/erc721TransferBuilder.ts","../src/caveatBuilder/specificActionERC20TransferBatchBuilder.ts","../src/caveatBuilder/erc20PeriodTransferBuilder.ts","../src/caveatBuilder/nativeTokenPeriodTransferBuilder.ts","../src/caveatBuilder/exactCalldataBatchBuilder.ts","../src/caveatBuilder/exactCalldataBuilder.ts","../src/caveatBuilder/exactExecutionBuilder.ts","../src/caveatBuilder/exactExecutionBatchBuilder.ts","../src/caveatBuilder/multiTokenPeriodBuilder.ts","../src/caveatBuilder/index.ts","../src/delegatorEnvironment.ts","../src/write.ts","../src/rpcError.ts","../src/userOp.ts","../src/webAuthn.ts","../src/signatures.ts"],"names":["encodePacked","encodeAbiParameters","Implementation","toHex","parseAbiParameters","keccak256","isHex","AllowedMethodsEnforcer","concat","AllowedTargetsEnforcer","isAddress","DeployedEnforcer","AllowedCalldataEnforcer","BalanceChangeType","ERC20BalanceChangeEnforcer","ValueLteEnforcer","pad","LimitedCallsEnforcer","id","IdEnforcer","nonce","NonceEnforcer","TimestampEnforcer","BlockNumberEnforcer","ERC20TransferAmountEnforcer","ERC20StreamingEnforcer","NativeTokenStreamingEnforcer","NativeTokenTransferAmountEnforcer","NativeBalanceChangeEnforcer","RedeemerEnforcer","NativeTokenPaymentEnforcer","ArgsEqualityCheckEnforcer","ERC1155BalanceChangeEnforcer","ERC721BalanceChangeEnforcer","ERC721TransferEnforcer","SpecificActionERC20TransferBatchEnforcer","NativeTokenPeriodTransferEnforcer","ExactCalldataBatchEnforcer","ExactCalldataEnforcer","ExactExecutionEnforcer","ExactExecutionBatchEnforcer","MultiTokenPeriodEnforcer","SimpleFactory","DelegationManager"],"mappings":"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","sourcesContent":["export * from '@metamask/delegation-deployments';\nexport * from '@metamask/delegation-abis';\nexport * from './executions';\nexport * from './blockchain';\nexport * from './caveats';\nexport * from './constants';\nexport * from './data';\nexport * from './delegation';\nexport * from './delegatorEnvironment';\nexport * from './rpcError';\nexport * from './types';\nexport * from './userOp';\nexport * from './webAuthn';\nexport * from './caveatBuilder';\nexport * from './write';\nexport { BalanceChangeType } from './caveatBuilder/types';\nexport { aggregateSignature, type PartialSignature } from './signatures';\nexport { signUserOperation } from './userOp';\n","import { type Hex, encodeAbiParameters, encodePacked, zeroAddress } from 'viem';\n\nexport type ExecutionStruct = {\n  target: Hex;\n  value: bigint;\n  callData: Hex;\n};\n\n/**\n * Creates an execution data structure.\n * @param target The address to invoke some calldata on.\n * @param value ETH to send to the address.\n * @param callData The calldata to invoke on the address.\n * @returns The created execution data structure.\n */\nexport const createExecution = (\n  target: Hex = zeroAddress,\n  value: bigint = 0n,\n  callData: Hex = '0x',\n): ExecutionStruct => ({\n  target,\n  value,\n  callData,\n});\n\n// Encoded modes\n// https://github.com/erc7579/erc7579-implementation/blob/main/src/lib/ModeLib.sol\nexport const SINGLE_DEFAULT_MODE =\n  '0x0000000000000000000000000000000000000000000000000000000000000000';\nexport const SINGLE_TRY_MODE =\n  '0x0001000000000000000000000000000000000000000000000000000000000000';\nexport const BATCH_DEFAULT_MODE =\n  '0x0100000000000000000000000000000000000000000000000000000000000000';\nexport const BATCH_TRY_MODE =\n  '0x0101000000000000000000000000000000000000000000000000000000000000';\n\nexport type ExecutionMode =\n  | typeof SINGLE_DEFAULT_MODE\n  | typeof SINGLE_TRY_MODE\n  | typeof BATCH_DEFAULT_MODE\n  | typeof BATCH_TRY_MODE;\n\n/**\n * The ABI type components of an Execution.\n */\nexport const EXECUTION_ABI_TYPE_COMPONENTS = [\n  { type: 'address', name: 'target' },\n  { type: 'uint256', name: 'value' },\n  { type: 'bytes', name: 'callData' },\n];\n\n/**\n * Encodes a single Execution. Used for executing a single Execution in a DeleGator SCA.\n * @param execution the execution to encode\n * @returns the encoded execution\n */\nexport const encodeSingleExecution = (execution: ExecutionStruct): Hex => {\n  return encodePacked(\n    ['address', 'uint256', 'bytes'],\n    [execution.target, execution.value, execution.callData],\n  );\n};\n\n/**\n * Encodes a batch of Executions. Used for executing a batch of Executions in a DeleGator SCA.\n * @dev If there's only a single execution, the contracts expect the `encodeSingleExecution` format.\n * @param executions the executions to encode\n * @returns the encoded executions\n */\nexport const encodeBatchExecution = (executions: ExecutionStruct[]): Hex => {\n  return encodeAbiParameters(\n    [\n      {\n        components: EXECUTION_ABI_TYPE_COMPONENTS,\n        name: 'executions',\n        type: 'tuple[]',\n      },\n    ],\n    [executions],\n  );\n};\n\n/**\n * Encodes the calldata for interacting with the advanced `execute` DeleGator method. Dynamically selects between single and batch execution based on the number of executions.\n * @param executions the execution(s) to encode\n * @returns the encoded execution(s)\n */\nexport const encodeExecutionCalldata = (executions: ExecutionStruct[]): Hex => {\n  if (executions.length == 0) {\n    throw new Error(\n      `Error while getting the execution calldatas, executions is empty`,\n    );\n  }\n  if (executions.length == 1) {\n    const execution = executions[0]!;\n    return encodeSingleExecution(execution);\n  }\n\n  return encodeBatchExecution(executions);\n};\n\n/**\n * Encodes the calldata for interacting with `redeemDelegations`. Encodes each batch of executions individually, dynamically selecting between single and batch execution based on the number of executions.\n * @param executionsBatch the executions to encode\n * @returns the encoded executions\n */\nexport const encodeExecutionCalldatas = (\n  executionsBatch: ExecutionStruct[][],\n): Hex[] => {\n  if (executionsBatch.length == 0) {\n    throw new Error(\n      `Error while getting the execution calldatas, executionsBatch is empty`,\n    );\n  }\n  return executionsBatch.map(encodeExecutionCalldata);\n};\n","import { CHAIN_ID } from '@metamask/delegation-deployments';\n\nexport const getExplorerAddressLink = (chainId: number, address: string) => {\n  const prefix = getExplorerLink(chainId);\n  return `${prefix}/address/${address}`;\n};\n\nexport const getExplorerTransactionLink = (chainId: number, hash: string) => {\n  const prefix = getExplorerLink(chainId);\n  return `${prefix}/tx/${hash}`;\n};\n\nconst CHAIN_EXPLORERS = {\n  [CHAIN_ID.mainnet]: 'https://etherscan.io',\n  [CHAIN_ID.optimism]: 'https://optimistic.etherscan.io',\n  [CHAIN_ID.polygon]: 'https://polygonscan.com',\n  [CHAIN_ID.base]: 'https://basescan.org',\n  [CHAIN_ID.arbitrum]: 'https://arbiscan.io',\n  [CHAIN_ID.linea]: 'https://lineascan.build',\n  [CHAIN_ID.sepolia]: 'https://sepolia.etherscan.io',\n  [CHAIN_ID.lineaSepolia]: 'https://sepolia.lineascan.build',\n};\n\nconst getExplorerLink = (chainId: number) => {\n  const url = CHAIN_EXPLORERS[chainId];\n  if (!url) {\n    throw new Error(`Unsupported chainId: ${chainId}`);\n  }\n  return url;\n};\n\nexport const shortenHash = (address: string | undefined) =>\n  !!address ? address.slice(0, 6) + '...' : '';\n\nexport const getInfuraRpcUrl = (chainId: number, apiKey?: string) => {\n  if (!apiKey) throw new Error('Infura API key is required');\n  switch (chainId) {\n    case CHAIN_ID.mainnet:\n      return `https://mainnet.infura.io/v3/${apiKey}`;\n    case CHAIN_ID.optimism:\n      return `https://optimism-mainnet.infura.io/v3/${apiKey}`;\n    case CHAIN_ID.polygon:\n      return `https://polygon-mainnet.infura.io/v3/${apiKey}`;\n    case CHAIN_ID.arbitrum:\n      return `https://arbitrum-mainnet.infura.io/v3/${apiKey}`;\n    case CHAIN_ID.linea:\n      return `https://linea-mainnet.infura.io/v3/${apiKey}`;\n    case CHAIN_ID.sepolia:\n      return `https://sepolia.infura.io/v3/${apiKey}`;\n    case CHAIN_ID.lineaSepolia:\n      return `https://linea-sepolia.infura.io/v3/${apiKey}`;\n    default:\n      throw new Error(`Unsupported chainId: ${chainId}`);\n  }\n};\n","import {\n  type Hex,\n  encodePacked,\n  encodeAbiParameters,\n  parseAbiParameters,\n  keccak256,\n  toHex,\n} from 'viem';\n\nexport const CAVEAT_ABI_TYPE_COMPONENTS = [\n  { type: 'address', name: 'enforcer' },\n  { type: 'bytes', name: 'terms' },\n  { type: 'bytes', name: 'args' },\n];\n\nexport type Caveat = {\n  enforcer: Hex;\n  terms: Hex;\n  args: Hex;\n};\n\nexport const CAVEAT_TYPEHASH: Hex = keccak256(\n  toHex('Caveat(address enforcer,bytes terms)'),\n);\n\n/**\n * Calculates the hash of an array of Caveats.\n * @param input The array of Caveats.\n * @return The keccak256 hash of the encoded Caveat array packet.\n */\nexport const getCaveatArrayPacketHash = (input: Caveat[]): Hex => {\n  let encoded: Hex = '0x';\n\n  for (let i = 0; i < input.length; ++i) {\n    const caveatPacketHash = getCaveatPacketHash(input[i] as Caveat);\n    encoded = encodePacked(['bytes', 'bytes32'], [encoded, caveatPacketHash]);\n  }\n  return keccak256(encoded);\n};\n\n/**\n * Calculates the hash of a single Caveat.\n * @param input The Caveat data.\n * @return The keccak256 hash of the encoded Caveat packet.\n */\nexport const getCaveatPacketHash = (input: Caveat): Hex => {\n  const encoded = encodeAbiParameters(\n    parseAbiParameters('bytes32, address, bytes32'),\n    [CAVEAT_TYPEHASH, input.enforcer, keccak256(input.terms)],\n  );\n  return keccak256(encoded);\n};\n\n/**\n * Creates a caveat.\n * @param enforcer The contract that guarantees the caveat is upheld.\n * @param terms The data that the enforcer will use to verify the caveat (unique per enforcer).\n * @returns A Caveat.\n */\nexport const createCaveat = (\n  enforcer: Hex,\n  terms: Hex,\n  args: Hex = '0x',\n): Caveat => ({\n  enforcer,\n  terms,\n  args,\n});\n","/**\n * To be used in sdk methods to call Implementation specific code\n * @type {Implementation}\n */\nexport enum Implementation {\n  MultiSig,\n  Hybrid,\n}\n","import { type Hex, isHex, toHex } from 'viem';\n\n/**\n * Checks if two hexadecimal strings are equal, ignoring case sensitivity.\n * @param a - The first hexadecimal string.\n * @param b - The second hexadecimal string.\n * @returns True if the hexadecimal strings are equal, false otherwise.\n */\nexport function isEqualHex(a: Hex, b: Hex): boolean {\n  return isHex(a) && a.toLowerCase() === b.toLowerCase();\n}\n\n/*\n * hexlify all members of object, recursively\n */\nexport function deepHexlify(obj: any): any {\n  if (typeof obj === 'function') {\n    return undefined;\n  }\n\n  if (obj == null || typeof obj === 'string' || typeof obj === 'boolean') {\n    return obj;\n  }\n\n  if (typeof obj === 'bigint') {\n    return toHex(obj);\n  }\n\n  if (obj._isBigNumber != null || typeof obj !== 'object') {\n    return toHex(obj).replace(/^0x0/, '0x');\n  }\n\n  if (Array.isArray(obj)) {\n    return obj.map((member) => deepHexlify(member));\n  }\n\n  return Object.keys(obj).reduce(\n    (set, key) =>\n      Object.assign(Object.assign({}, set), {\n        [key]: deepHexlify(obj[key]),\n      }),\n    {},\n  );\n}\n","import {\n  type Hex,\n  encodeAbiParameters,\n  parseAbiParameters,\n  keccak256,\n  hashMessage,\n  toBytes,\n  toHex,\n  TypedData,\n  AbiParameter,\n  Address,\n  WalletClient,\n  Account,\n  Chain,\n  Transport,\n  getAddress,\n} from 'viem';\nimport {\n  CAVEAT_ABI_TYPE_COMPONENTS,\n  Caveat,\n  getCaveatArrayPacketHash,\n} from './caveats';\nimport { type Caveats, resolveCaveats } from './caveatBuilder';\n\n/**\n * Converts a Delegation to a DelegationStruct.\n * The DelegationStruct is the format used in the Delegation Framework.\n * @param delegation the delegation to format\n * @returns\n */\nexport const toDelegationStruct = (\n  delegation: Delegation,\n): DelegationStruct => {\n  const caveats = delegation.caveats.map((caveat) => ({\n    enforcer: getAddress(caveat.enforcer),\n    terms: caveat.terms,\n    args: caveat.args,\n  }));\n\n  const salt = delegation.salt === '0x' ? 0n : BigInt(delegation.salt);\n\n  return {\n    delegate: getAddress(delegation.delegate),\n    delegator: getAddress(delegation.delegator),\n    authority:\n      delegation.authority === undefined\n        ? ROOT_AUTHORITY\n        : delegation.authority,\n    caveats,\n    salt,\n    signature: delegation.signature,\n  };\n};\n\n/**\n * Represents a delegation that grants permissions from a delegator to a delegate.\n *\n * @property delegate - The address of the entity receiving the delegation.\n * @property delegator - The address of the entity granting the delegation.\n * @property authority - The authority under which this delegation is granted. For root delegations, this is ROOT_AUTHORITY.\n * @property caveats - An array of restrictions or conditions applied to this delegation.\n * @property salt - A unique value to prevent replay attacks and ensure uniqueness of the delegation.\n * @property signature - The cryptographic signature validating this delegation.\n */\nexport type Delegation = {\n  delegate: Hex;\n  delegator: Hex;\n  authority: Hex;\n  caveats: Caveat[];\n  salt: Hex;\n  signature: Hex;\n};\n\n/**\n * Represents a DelegationStruct as defined in the Delegation Framework.\n * This is distinguished from the Delegation type by requiring the salt to be a bigint\n * instead of a Hex string, which is useful for on-chain operations and EIP-712 signing.\n */\nexport type DelegationStruct = Omit<Delegation, 'salt'> & {\n  salt: bigint;\n};\n\n/**\n * ABI Encodes a delegation.\n * @param delegations\n * @returns\n */\nexport const encodeDelegation = (delegations: Delegation[]) => {\n  const delegationStructs = delegations.map(toDelegationStruct);\n\n  return encodeAbiParameters(\n    [\n      {\n        components: DELEGATION_ABI_TYPE_COMPONENTS,\n        name: 'delegations',\n        type: 'tuple[]',\n      },\n    ],\n    [delegationStructs],\n  );\n};\n\n/**\n * ABI Encodes the delegation chains to generate the encoded permissions contexts.\n * @param permissionContexts\n * @returns\n */\nexport const encodePermissionContexts = (delegations: Delegation[][]) => {\n  const encodedDelegations = delegations.map((delegationChain) =>\n    encodeDelegation(delegationChain),\n  );\n  return encodedDelegations;\n};\n\n/**\n * To be used on a delegation as the root authority.\n */\nexport const ROOT_AUTHORITY =\n  '0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff';\n\n/**\n * To be used in the allowList field of a gas delegation so as not to restrict who can redeem the gas delegation.\n */\nexport const ANY_BENEFICIARY = '0x0000000000000000000000000000000000000a11';\n\n/**\n * To be used when generating a delegation hash to be signed\n * NOTE: signature is omitted from the Delegation typehash\n */\nexport const DELEGATION_TYPEHASH = keccak256(\n  toHex(\n    'Delegation(address delegate,address delegator,bytes32 authority,Caveat[] caveats,uint256 salt)Caveat(address enforcer,bytes terms)',\n  ),\n);\n\n/**\n * The ABI type components of a Delegation.\n */\nexport const DELEGATION_ABI_TYPE_COMPONENTS = [\n  { type: 'address', name: 'delegate' },\n  { type: 'address', name: 'delegator' },\n  { type: 'bytes32', name: 'authority' },\n  { type: 'tuple[]', name: 'caveats', components: CAVEAT_ABI_TYPE_COMPONENTS },\n  { type: 'uint256', name: 'salt' },\n  { type: 'bytes', name: 'signature' },\n];\n\n/**\n * TypedData to be used when signing a Delegation. Delegation value for `signature` and Caveat values for `args` are omitted as they cannot be known at signing time.\n */\nexport const SIGNABLE_DELEGATION_TYPED_DATA: TypedData = {\n  Caveat: [\n    { name: 'enforcer', type: 'address' },\n    { name: 'terms', type: 'bytes' },\n  ],\n  Delegation: [\n    { name: 'delegate', type: 'address' },\n    { name: 'delegator', type: 'address' },\n    { name: 'authority', type: 'bytes32' },\n    { name: 'caveats', type: 'Caveat[]' },\n    { name: 'salt', type: 'uint256' },\n  ],\n} as const;\n\n/**\n * The ABI type for a full delegation.\n */\nexport const DELEGATION_ARRAY_ABI_TYPE: AbiParameter = {\n  type: 'tuple[]',\n  components: DELEGATION_ABI_TYPE_COMPONENTS,\n} as const;\n\n/**\n * Encodes an array of Delegations for use in a contract call.\n * @param delegations The array of Delegations to encode.\n * @returns The encoded Delegations as abi parameters.\n */\nexport const encodeDelegations = (delegations: Delegation[]) =>\n  encodeAbiParameters([DELEGATION_ARRAY_ABI_TYPE], [delegations]);\n\n/**\n * get ethSignedMessageHash hex string to allow signing with passkey\n * @param delegationHash to be signed\n */\nexport const prepDelegationHashForPasskeySign = (delegationHash: Hex) => {\n  return hashMessage({\n    raw: toBytes(delegationHash),\n  });\n};\n\n/**\n * This function is used to get the hash of the Delegation parameters.\n * @param input The Delegation parameters to be hashed.\n * @return Returns the hash of the Delegation parameters.\n */\nexport const getDelegationHashOffchain = (input: Delegation): Hex => {\n  const delegationStruct = toDelegationStruct(input);\n\n  const encoded = encodeAbiParameters(\n    parseAbiParameters('bytes32, address, address, bytes32, bytes32, uint'),\n    [\n      DELEGATION_TYPEHASH,\n      delegationStruct.delegate,\n      delegationStruct.delegator,\n      delegationStruct.authority,\n      getCaveatArrayPacketHash(delegationStruct.caveats),\n      delegationStruct.salt,\n    ],\n  );\n\n  return keccak256(encoded);\n};\n\ntype BaseCreateDelegationOptions = {\n  from: Hex;\n  caveats: Caveats;\n  parentDelegation?: Delegation | Hex;\n};\n\n/**\n * Options for creating a specific delegation\n */\nexport type CreateDelegationOptions = BaseCreateDelegationOptions & {\n  to: Hex;\n};\n\n/**\n * Options for creating an open delegation\n */\nexport type CreateOpenDelegationOptions = BaseCreateDelegationOptions;\n\n/**\n * Resolves the authority for a delegation based on the parent delegation\n * @param parentDelegation The parent delegation or its hash\n * @returns The resolved authority hash\n */\nexport const resolveAuthority = (parentDelegation?: Delegation | Hex): Hex => {\n  if (!parentDelegation) {\n    return ROOT_AUTHORITY;\n  }\n\n  if (typeof parentDelegation === 'string') {\n    return parentDelegation;\n  }\n\n  return getDelegationHashOffchain(parentDelegation);\n};\n\n/**\n * Creates a delegation with specific delegate\n * @param options The options for creating the delegation\n * @returns The created delegation data structure\n */\nexport const createDelegation = (\n  options: CreateDelegationOptions,\n): Delegation => {\n  return {\n    delegate: options.to,\n    delegator: options.from,\n    authority: resolveAuthority(options.parentDelegation),\n    caveats: resolveCaveats(options.caveats),\n    salt: '0x',\n    signature: '0x',\n  };\n};\n\n/**\n * Creates an open delegation that can be redeemed by any delegate\n * @param options The options for creating the open delegation\n * @returns The created delegation data structure\n */\nexport const createOpenDelegation = (\n  options: CreateOpenDelegationOptions,\n): Delegation => {\n  return {\n    delegate: ANY_BENEFICIARY,\n    delegator: options.from,\n    authority: resolveAuthority(options.parentDelegation),\n    caveats: resolveCaveats(options.caveats),\n    salt: '0x',\n    signature: '0x',\n  };\n};\n\n/**\n * Signs a delegation using the wallet client.\n * @param walletClient - The wallet client to sign the delegation with.\n * @param delegation - The delegation to sign.\n * @param delegationManager - The address of the delegation manager.\n * @param chainId - The chain ID that the delegation manager is deployed on.\n * @param name - The name of the domain of the delegation manager.\n * @param version - The version of the domain of the delegation manager.\n * @returns The signature.\n */\nexport const signDelegation = async ({\n  signer,\n  delegation,\n  delegationManager,\n  chainId,\n  name = 'DelegationManager',\n  version = '1',\n}: {\n  signer: WalletClient<Transport, Chain, Account>;\n  delegation: Omit<Delegation, 'signature'>;\n  delegationManager: Address;\n  chainId: number;\n  name?: string;\n  version?: string;\n}) => {\n  const delegationStruct = toDelegationStruct({\n    ...delegation,\n    signature: '0x',\n  });\n\n  return signer.signTypedData({\n    account: signer.account,\n    domain: {\n      chainId,\n      name,\n      version,\n      verifyingContract: delegationManager,\n    },\n    types: SIGNABLE_DELEGATION_TYPED_DATA,\n    primaryType: 'Delegation',\n    message: delegationStruct,\n  });\n};\n","import type { Caveat, DeleGatorEnvironment } from '..';\nimport { type Hex, isHex, concat, toFunctionSelector, AbiFunction } from 'viem';\n\nexport const allowedMethods = 'allowedMethods';\n\nexport type MethodSelector = Hex | string | AbiFunction;\n\n// length of function selector in chars, _including_ 0x prefix\nconst FUNCTION_SELECTOR_STRING_LENGTH = 10;\n\n/**\n * Builds a caveat struct for the AllowedMethodsEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param selectors - The allowed function selectors.\n * @returns The Caveat.\n * @throws Error if no selectors are provided or if any selector is invalid.\n */\nexport const allowedMethodsBuilder = (\n  environment: DeleGatorEnvironment,\n  selectors: MethodSelector[],\n): Caveat => {\n  if (selectors.length === 0) {\n    throw new Error('Invalid selectors: must provide at least one selector');\n  }\n\n  const parsedSelectors = selectors.map(parseSelector);\n\n  const terms = concat(parsedSelectors);\n\n  const {\n    caveatEnforcers: { AllowedMethodsEnforcer },\n  } = environment;\n\n  return {\n    enforcer: AllowedMethodsEnforcer!,\n    terms,\n    args: '0x',\n  };\n};\n\nfunction parseSelector(selector: MethodSelector) {\n  if (isHex(selector)) {\n    if (selector.length !== FUNCTION_SELECTOR_STRING_LENGTH) {\n      throw new Error(\n        'Invalid selector: must be a 4 byte hex string, abi function signature, or AbiFunction',\n      );\n    } else {\n      return selector;\n    }\n  }\n\n  try {\n    return toFunctionSelector(selector);\n  } catch (rootError: any) {\n    throw new Error(\n      'Invalid selector: must be a 4 byte hex string, abi function signature, or AbiFunction',\n      { cause: rootError },\n    );\n  }\n}\n","import type { Caveat, DeleGatorEnvironment } from '..';\nimport { concat, isAddress, type Address } from 'viem';\n\nexport const allowedTargets = 'allowedTargets';\n\n/**\n * Builds a caveat struct for AllowedTargetsEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param targets - The array of allowed target addresses.\n * @returns The Caveat.\n * @throws Error if no targets are provided or if any of the addresses are invalid.\n */\nexport const allowedTargetsBuilder = (\n  environment: DeleGatorEnvironment,\n  targets: Address[],\n): Caveat => {\n  if (targets.length === 0) {\n    throw new Error(\n      'Invalid targets: must provide at least one target address',\n    );\n  }\n\n  // we check that the address is valid, but doesn't need to be checksummed\n  const invalidAddresses = targets.filter(\n    (target) => !isAddress(target, { strict: false }),\n  );\n\n  if (invalidAddresses.length > 0) {\n    throw new Error('Invalid targets: must be valid addresses');\n  }\n\n  const terms = concat(targets);\n\n  const {\n    caveatEnforcers: { AllowedTargetsEnforcer },\n  } = environment;\n\n  return {\n    enforcer: AllowedTargetsEnforcer!,\n    terms,\n    args: '0x',\n  };\n};\n","import type { Caveat, DeleGatorEnvironment } from '..';\n\nexport type Caveats = CaveatBuilder | Caveat[];\n\ntype CaveatWithOptionalArgs = Omit<Caveat, 'args'> & {\n  args?: Caveat['args'];\n};\n\n/**\n * Resolve the array of Caveat from a Caveats argument.\n * Caveats may be a CaveatBuilder or an array of Caveat.\n *\n * @param caveats - the caveats to be resolved\n * @returns - the resolved caveats array\n */\nexport const resolveCaveats = (caveats: Caveats) => {\n  if (Array.isArray(caveats)) {\n    return caveats;\n  }\n  return caveats.build();\n};\n\ntype RemoveFirst<T extends any[]> = T extends [any, ...infer Rest]\n  ? Rest\n  : never;\n\ntype CaveatBuilderMap = {\n  [key: string]: (\n    environment: DeleGatorEnvironment,\n    ...args: [...any]\n  ) => Caveat;\n};\n\nexport type CaveatBuilderConfig = {\n  allowEmptyCaveats?: boolean;\n};\n\n/**\n * Represents a builder for creating caveats.\n *\n * @template TCaveatBuilderMap - The type of the caveat builder map.\n */\nexport class CaveatBuilder<TCaveatBuilderMap extends CaveatBuilderMap = {}> {\n  private results: Caveat[] = [];\n  private hasBeenBuilt = false;\n\n  constructor(\n    private readonly environment: DeleGatorEnvironment,\n    private readonly config: CaveatBuilderConfig = {},\n    private readonly enforcerBuilders: TCaveatBuilderMap = {} as TCaveatBuilderMap,\n    builtCaveats: Caveat[] = [] as Caveat[],\n  ) {\n    this.results = builtCaveats;\n  }\n\n  /**\n   * Extends the CaveatBuilder with a new enforcer function.\n   *\n   * @template TEnforcerName - The name of the enforcer.\n   * @template TFunction - The type of the enforcer function.\n   * @param name - The name of the enforcer.\n   * @param fn - The enforcer function.\n   * @returns The extended CaveatBuilder instance.\n   */\n  extend<\n    TEnforcerName extends string,\n    TFunction extends (\n      environment: DeleGatorEnvironment,\n      ...args: [...any]\n    ) => Caveat,\n  >(\n    name: TEnforcerName,\n    fn: TFunction,\n  ): CaveatBuilder<TCaveatBuilderMap & Record<TEnforcerName, TFunction>> {\n    return new CaveatBuilder<\n      TCaveatBuilderMap & Record<TEnforcerName, TFunction>\n    >(\n      this.environment,\n      this.config,\n      { ...this.enforcerBuilders, [name]: fn },\n      this.results,\n    );\n  }\n\n  /**\n   * Adds a caveat directly using a Caveat object.\n   *\n   * @param caveat - The caveat to add\n   * @returns The CaveatBuilder instance for chaining\n   */\n  addCaveat(caveat: CaveatWithOptionalArgs): CaveatBuilder<TCaveatBuilderMap>;\n\n  /**\n   * Adds a caveat using a named enforcer function.\n   *\n   * @param name - The name of the enforcer function to use\n   * @param args - The arguments to pass to the enforcer function\n   * @returns The CaveatBuilder instance for chaining\n   */\n  addCaveat<TEnforcerName extends keyof TCaveatBuilderMap>(\n    name: TEnforcerName,\n    ...args: RemoveFirst<Parameters<TCaveatBuilderMap[TEnforcerName]>>\n  ): CaveatBuilder<TCaveatBuilderMap>;\n\n  addCaveat<TEnforcerName extends keyof TCaveatBuilderMap>(\n    nameOrCaveat: TEnforcerName | CaveatWithOptionalArgs,\n    ...args: typeof nameOrCaveat extends CaveatWithOptionalArgs\n      ? []\n      : RemoveFirst<Parameters<TCaveatBuilderMap[TEnforcerName]>>\n  ): CaveatBuilder<TCaveatBuilderMap> {\n    if (typeof nameOrCaveat === 'object') {\n      const caveat = {\n        args: '0x' as const, // defaults to \"0x\"\n        ...nameOrCaveat,\n      };\n\n      this.results = [...this.results, caveat];\n\n      return this;\n    } else {\n      const name = nameOrCaveat;\n\n      const func = this.enforcerBuilders[name];\n      if (typeof func === 'function') {\n        const result = func(this.environment, ...args);\n\n        this.results = [...this.results, result];\n\n        return this;\n      }\n      throw new Error(`Function \"${String(name)}\" does not exist.`);\n    }\n  }\n\n  /**\n   * Returns the caveats that have been built using this CaveatBuilder.\n   *\n   * @returns The array of built caveats.\n   */\n  build(): Caveat[] {\n    if (this.hasBeenBuilt) {\n      throw new Error('This CaveatBuilder has already been built.');\n    }\n\n    if (this.results.length === 0 && !this.config.allowEmptyCaveats) {\n      throw new Error(\n        'No caveats found. If you definitely want to create an empty caveat collection, set `allowEmptyCaveats`.',\n      );\n    }\n\n    this.hasBeenBuilt = true;\n\n    return this.results;\n  }\n}\n","import type { Caveat, DeleGatorEnvironment } from '..';\nimport { concat, isAddress, isHex, pad, type Address, type Hex } from 'viem';\n\nexport const deployed = 'deployed';\n\n/**\n * Builds a caveat struct for a DeployedEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param contractAddress - The address of the contract that must be deployed.\n * @param salt - The address of the factory contract.\n * @param bytecode - The bytecode of the contract to be deployed.\n * @returns The Caveat.\n * @throws Error if the contract address, factory address, or bytecode is invalid.\n */\nexport const deployedBuilder = (\n  environment: DeleGatorEnvironment,\n  contractAddress: Address,\n  salt: Hex,\n  bytecode: Hex,\n): Caveat => {\n  // we check that the addresses are valid, but don't need to be checksummed\n  if (!isAddress(contractAddress, { strict: false })) {\n    throw new Error(\n      `Invalid contractAddress: must be a valid Ethereum address`,\n    );\n  }\n\n  if (!isHex(salt)) {\n    throw new Error('Invalid salt: must be a valid hexadecimal string');\n  }\n\n  if (!isHex(bytecode)) {\n    throw new Error('Invalid bytecode: must be a valid hexadecimal string');\n  }\n\n  const terms = concat([contractAddress, pad(salt, { size: 32 }), bytecode]);\n\n  const {\n    caveatEnforcers: { DeployedEnforcer },\n  } = environment;\n\n  return {\n    enforcer: DeployedEnforcer!,\n    terms,\n    args: '0x',\n  };\n};\n","import type { Caveat, DeleGatorEnvironment } from '..';\nimport { type Hex, concat, isHex, toHex } from 'viem';\n\nexport const allowedCalldata = 'allowedCalldata';\n\n/**\n * Builds a caveat struct for AllowedCalldataEnforcer.\n *\n * @param environment - The DeleGator environment.\\\n * @param startIndex - The start index of the subset of calldata bytes.\n * @param value - The expected value for the subset of calldata.\n * @returns The Caveat.\n * @throws Error if the value is not a valid hex string, if startIndex is negative, or if startIndex is not a whole number.\n */\nexport const allowedCalldataBuilder = (\n  environment: DeleGatorEnvironment,\n  startIndex: number,\n  value: Hex,\n): Caveat => {\n  if (!isHex(value)) {\n    throw new Error('Invalid value: must be a valid hex string');\n  }\n\n  if (startIndex < 0) {\n    throw new Error('Invalid startIndex: must be zero or positive');\n  }\n\n  if (!Number.isInteger(startIndex)) {\n    throw new Error('Invalid startIndex: must be a whole number');\n  }\n\n  const startIndexHex = toHex(startIndex, { size: 32 });\n\n  const terms = concat([startIndexHex, value]);\n\n  const {\n    caveatEnforcers: { AllowedCalldataEnforcer },\n  } = environment;\n\n  return {\n    enforcer: AllowedCalldataEnforcer!,\n    terms,\n    args: '0x',\n  };\n};\n","import type { DeleGatorEnvironment, Caveat } from '..';\nimport { type Address, isAddress, encodePacked } from 'viem';\nimport { BalanceChangeType } from './types';\n\nexport const erc20BalanceChange = 'erc20BalanceChange';\n\n/**\n * Builds a caveat struct for the ERC20BalanceChangeEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param tokenAddress - The tokenAddress of the ERC20 token.\n * @param balance - The minimum balance amount required.\n * @param changeType - Whether the balance should increase or decrease.\n * @returns The Caveat.\n * @throws Error if the token address is invalid, the amount is not a positive number, or the change type is invalid.\n */\nexport const erc20BalanceChangeBuilder = (\n  environment: DeleGatorEnvironment,\n  tokenAddress: Address,\n  recipient: Address,\n  balance: bigint,\n  changeType: BalanceChangeType,\n): Caveat => {\n  if (!isAddress(tokenAddress, { strict: false })) {\n    throw new Error('Invalid tokenAddress: must be a valid address');\n  }\n\n  if (balance <= 0n) {\n    throw new Error('Invalid balance: must be a positive number');\n  }\n\n  if (\n    changeType !== BalanceChangeType.Increase &&\n    changeType !== BalanceChangeType.Decrease\n  ) {\n    throw new Error('Invalid changeType: must be either Increase or Decrease');\n  }\n\n  const terms = encodePacked(\n    ['uint8', 'address', 'address', 'uint256'],\n    [changeType, tokenAddress, recipient, balance],\n  );\n\n  const {\n    caveatEnforcers: { ERC20BalanceChangeEnforcer },\n  } = environment;\n\n  return {\n    enforcer: ERC20BalanceChangeEnforcer!,\n    terms,\n    args: '0x',\n  };\n};\n","export enum BalanceChangeType {\n  Increase = 0x0,\n  Decrease = 0x1,\n}\n","import type { Caveat, DeleGatorEnvironment } from '..';\nimport { concat, toHex } from 'viem';\n\nexport const valueLte = 'valueLte';\n\n/**\n * Builds a caveat struct for ValueLteEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param maxValue - The maximum value allowed for the transaction.\n * @returns The Caveat.\n * @throws Error if the maxValue is not a positive number.\n */\nexport const valueLteBuilder = (\n  environment: DeleGatorEnvironment,\n  maxValue: bigint,\n): Caveat => {\n  if (maxValue < 0n) {\n    throw new Error('Invalid maxValue: must be greater than zero');\n  }\n\n  const terms = concat([toHex(maxValue, { size: 32 })]);\n\n  const {\n    caveatEnforcers: { ValueLteEnforcer },\n  } = environment;\n\n  return {\n    enforcer: ValueLteEnforcer!,\n    terms,\n    args: '0x',\n  };\n};\n","import type { DeleGatorEnvironment, Caveat } from '..';\nimport { type Hex, toHex, pad } from 'viem';\n\nexport const limitedCalls = 'limitedCalls';\n\n/**\n * Builds a caveat struct for the LimitedCallsEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param limit - The maximum number of calls allowed.\n * @returns The Caveat.\n * @throws Error if the limit is not a positive integer.\n */\nexport const limitedCallsBuilder = (\n  environment: DeleGatorEnvironment,\n  limit: number,\n): Caveat => {\n  if (!Number.isInteger(limit)) {\n    throw new Error('Invalid limit: must be an integer');\n  }\n\n  if (limit <= 0) {\n    throw new Error('Invalid limit: must be a positive integer');\n  }\n\n  const terms: Hex = pad(toHex(limit), { size: 32 });\n\n  const {\n    caveatEnforcers: { LimitedCallsEnforcer },\n  } = environment;\n\n  return {\n    enforcer: LimitedCallsEnforcer!,\n    terms,\n    args: '0x',\n  };\n};\n","import type { DeleGatorEnvironment, Caveat } from '..';\nimport { toHex } from 'viem';\n\nexport const id = 'id';\n\n/**\n * Builds a caveat struct for the IdEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param id - The id to be enforced.\n * @returns The Caveat.\n * @throws Error if the provided id is not a number, not an integer, or is > 32 bytes.\n */\nexport const idBuilder = (\n  environment: DeleGatorEnvironment,\n  id: number,\n): Caveat => {\n  if (typeof id !== 'number') {\n    throw new Error('Invalid id: must be a number');\n  }\n\n  if (!Number.isInteger(id)) {\n    throw new Error('Invalid id: must be an integer');\n  }\n\n  if (id >= 2 ** 32) {\n    throw new Error('Invalid id: must be 32 bytes or fewer in length');\n  }\n\n  const terms = toHex(id, { size: 32 });\n\n  const {\n    caveatEnforcers: { IdEnforcer },\n  } = environment;\n\n  return {\n    enforcer: IdEnforcer!,\n    terms,\n    args: '0x',\n  };\n};\n","import type { DeleGatorEnvironment, Caveat } from '..';\nimport { type Hex, isHex, pad } from 'viem';\n\nexport const nonce = 'nonce';\n\n// char length of 32 byte hex string\nconst MAX_NONCE_STRING_LENGTH = 66;\n\n/**\n * Builds a caveat struct for the NonceEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param nonce - The nonce value as a hexadecimal string.\n * @returns The Caveat.\n * @throws Error if the nonce is invalid.\n */\nexport const nonceBuilder = (\n  environment: DeleGatorEnvironment,\n  nonce: Hex,\n): Caveat => {\n  if (!nonce || nonce === '0x') {\n    throw new Error('Invalid nonce: must be a non-empty hex string');\n  }\n\n  if (!isHex(nonce)) {\n    throw new Error('Invalid nonce: must be a valid hex string');\n  }\n\n  if (nonce.length > MAX_NONCE_STRING_LENGTH) {\n    throw new Error('Invalid nonce: must be 32 bytes or less in length');\n  }\n\n  const {\n    caveatEnforcers: { NonceEnforcer },\n  } = environment;\n\n  return {\n    enforcer: NonceEnforcer!,\n    terms: pad(nonce, { size: 32 }),\n    args: '0x',\n  };\n};\n","import type { Caveat, DeleGatorEnvironment } from '..';\nimport { type Hex, concat, toHex } from 'viem';\nimport { TIMESTAMP_UPPER_BOUND_SECONDS } from './shared';\n\nexport const timestamp = 'timestamp';\n\n/**\n * Builds a caveat struct for the TimestampEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param timestampAfterThreshold - The timestamp (in seconds) after which the delegation can be used.\n * @param timestampBeforeThreshold - The timestamp (in seconds) before which the delegation can be used.\n * @returns The Caveat.\n * @throws Error if the timestamps are invalid.\n */\nexport const timestampBuilder = (\n  environment: DeleGatorEnvironment,\n  timestampAfterThreshold: number,\n  timestampBeforeThreshold: number,\n): Caveat => {\n  if (timestampAfterThreshold < 0) {\n    throw new Error(\n      'Invalid timestampAfterThreshold: must be zero or positive',\n    );\n  }\n\n  if (timestampBeforeThreshold < 0) {\n    throw new Error(\n      'Invalid timestampBeforeThreshold: must be zero or positive',\n    );\n  }\n\n  if (timestampBeforeThreshold > TIMESTAMP_UPPER_BOUND_SECONDS) {\n    throw new Error(\n      'Invalid timestampBeforeThreshold: must be less than or equal to 253402300799',\n    );\n  }\n\n  if (timestampAfterThreshold > TIMESTAMP_UPPER_BOUND_SECONDS) {\n    throw new Error(\n      'Invalid timestampAfterThreshold: must be less than or equal to 253402300799',\n    );\n  }\n\n  if (\n    timestampBeforeThreshold !== 0 &&\n    timestampAfterThreshold >= timestampBeforeThreshold\n  ) {\n    throw new Error(\n      'Invalid thresholds: timestampBeforeThreshold must be greater than timestampAfterThreshold when both are specified',\n    );\n  }\n\n  const afterThresholdHex = toHex(timestampAfterThreshold, { size: 16 });\n  const beforeThresholdHex = toHex(timestampBeforeThreshold, { size: 16 });\n\n  const terms: Hex = concat([afterThresholdHex, beforeThresholdHex]);\n\n  const {\n    caveatEnforcers: { TimestampEnforcer },\n  } = environment;\n\n  return {\n    enforcer: TimestampEnforcer!,\n    terms,\n    args: '0x',\n  };\n};\n","export const TIMESTAMP_UPPER_BOUND_SECONDS = 253402300799; // 9999-12-31 23:59:59 UTC\n","import type { DeleGatorEnvironment, Caveat } from '..';\nimport { concat, toHex } from 'viem';\n\nexport const blockNumber = 'blockNumber';\n\n/**\n * Builds a caveat struct for the BlockNumberEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param blockAfterThreshold - The earliest block number after which the delegation can be used.\n * @param blockBeforeThreshold - The latest block number before which the delegation can be used.\n * @returns The Caveat.\n * @throws Error if both thresholds are zero, if blockAfterThreshold is greater than or equal to blockBeforeThreshold, or if BlockNumberEnforcer is not available in the environment.\n */\nexport const blockNumberBuilder = (\n  environment: DeleGatorEnvironment,\n  blockAfterThreshold: bigint,\n  blockBeforeThreshold: bigint,\n): Caveat => {\n  if (blockAfterThreshold === 0n && blockBeforeThreshold === 0n) {\n    throw new Error(\n      'Invalid thresholds: At least one of blockAfterThreshold or blockBeforeThreshold must be specified',\n    );\n  }\n\n  if (\n    blockBeforeThreshold !== 0n &&\n    blockAfterThreshold >= blockBeforeThreshold\n  ) {\n    throw new Error(\n      'Invalid thresholds: blockAfterThreshold must be less than blockBeforeThreshold if both are specified',\n    );\n  }\n\n  const terms = concat([\n    toHex(blockAfterThreshold, {\n      size: 16,\n    }),\n    toHex(blockBeforeThreshold, {\n      size: 16,\n    }),\n  ]);\n\n  const {\n    caveatEnforcers: { BlockNumberEnforcer },\n  } = environment;\n\n  return {\n    enforcer: BlockNumberEnforcer!,\n    terms,\n    args: '0x',\n  };\n};\n","import type { Caveat, DeleGatorEnvironment } from '..';\nimport { concat, isAddress, toHex, Address } from 'viem';\n\nexport const erc20TransferAmount = 'erc20TransferAmount';\n\n/**\n * Builds a caveat struct for ERC20TransferAmountEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param tokenAddress - The address of the ERC20 token contract.\n * @param maxAmount - The maximum amount of tokens that can be transferred.\n * @returns The Caveat.\n * @throws Error if the token address is invalid or if the max amount is not a positive number.\n */\nexport const erc20TransferAmountBuilder = (\n  environment: DeleGatorEnvironment,\n  tokenAddress: Address,\n  maxAmount: bigint,\n): Caveat => {\n  if (!isAddress(tokenAddress, { strict: false })) {\n    throw new Error('Invalid tokenAddress: must be a valid address');\n  }\n\n  if (maxAmount <= 0n) {\n    throw new Error('Invalid maxAmount: must be a positive number');\n  }\n\n  const terms = concat([tokenAddress, toHex(maxAmount, { size: 32 })]);\n\n  const {\n    caveatEnforcers: { ERC20TransferAmountEnforcer },\n  } = environment;\n\n  return {\n    enforcer: ERC20TransferAmountEnforcer!,\n    terms,\n    args: '0x',\n  };\n};\n","import type { DeleGatorEnvironment, Caveat } from '..';\nimport { type Address, isAddress, encodePacked } from 'viem';\nimport { TIMESTAMP_UPPER_BOUND_SECONDS } from './shared';\n\nexport const erc20Streaming = 'erc20Streaming';\n\n/**\n * Builds a caveat struct for the ERC20StreamingEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param tokenAddress - The tokenAddress of the ERC20 token.\n * @param initialAmount - The initial amount of tokens to release at start time.\n * @param maxAmount - The maxium amount of tokens that can be released.\n * @param amountPerSecond - The rate at which the allowance increases per second.\n * @param startTime The timestamp from which the allowance streaming begins\n * @returns The Caveat.\n * @throws Error if the token address is invalid.\n * @throws Error if the initial amount is a negative number.\n * @throws Error if the max amount is not greater than 0.\n * @throws Error if the max amount is less than the initial amount.\n * @throws Error if the amount per second is not a positive number.\n * @throws Error if the start time is not a positive number.\n */\nexport const erc20StreamingBuilder = (\n  environment: DeleGatorEnvironment,\n  tokenAddress: Address,\n  initialAmount: bigint,\n  maxAmount: bigint,\n  amountPerSecond: bigint,\n  startTime: number,\n): Caveat => {\n  if (!isAddress(tokenAddress, { strict: false })) {\n    throw new Error('Invalid tokenAddress: must be a valid address');\n  }\n\n  if (initialAmount < 0n) {\n    throw new Error('Invalid initialAmount: must be greater than zero');\n  }\n\n  if (maxAmount <= 0n) {\n    throw new Error('Invalid maxAmount: must be a positive number');\n  }\n\n  if (maxAmount < initialAmount) {\n    throw new Error('Invalid maxAmount: must be greater than initialAmount');\n  }\n\n  if (amountPerSecond <= 0n) {\n    throw new Error('Invalid amountPerSecond: must be a positive number');\n  }\n\n  if (startTime <= 0) {\n    throw new Error('Invalid startTime: must be a positive number');\n  }\n\n  if (startTime > TIMESTAMP_UPPER_BOUND_SECONDS) {\n    throw new Error(\n      'Invalid startTime: must be less than or equal to 253402300799',\n    );\n  }\n\n  const terms = encodePacked(\n    ['address', 'uint256', 'uint256', 'uint256', 'uint256'],\n    [\n      tokenAddress,\n      initialAmount,\n      maxAmount,\n      amountPerSecond,\n      BigInt(startTime),\n    ],\n  );\n\n  const {\n    caveatEnforcers: { ERC20StreamingEnforcer },\n  } = environment;\n\n  return {\n    enforcer: ERC20StreamingEnforcer!,\n    terms,\n    args: '0x',\n  };\n};\n","import type { DeleGatorEnvironment, Caveat } from '..';\nimport { encodePacked } from 'viem';\nimport { TIMESTAMP_UPPER_BOUND_SECONDS } from './shared';\n\nexport const nativeTokenStreaming = 'nativeTokenStreaming';\n\n/**\n * Builds a caveat struct for the NativeTokenStreamingEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param initialAmount - The initial amount of tokens to release at start time.\n * @param maxAmount - The maxium amount of tokens that can be released.\n * @param amountPerSecond - The rate at which the allowance increases per second.\n * @param startTime The timestamp from which the allowance streaming begins\n * @returns The Caveat.\n * @throws Error if the initial amount is a negative number.\n * @throws Error if the max amount is not greater than 0.\n * @throws Error if the max amount is less than the initial amount.\n * @throws Error if the amount per second is not a positive number.\n * @throws Error if the start time is not a positive number.\n */\nexport const nativeTokenStreamingBuilder = (\n  environment: DeleGatorEnvironment,\n  initialAmount: bigint,\n  maxAmount: bigint,\n  amountPerSecond: bigint,\n  startTime: number,\n): Caveat => {\n  if (initialAmount < 0n) {\n    throw new Error('Invalid initialAmount: must be greater than zero');\n  }\n\n  if (maxAmount <= 0n) {\n    throw new Error('Invalid maxAmount: must be a positive number');\n  }\n\n  if (maxAmount < initialAmount) {\n    throw new Error('Invalid maxAmount: must be greater than initialAmount');\n  }\n\n  if (amountPerSecond <= 0n) {\n    throw new Error('Invalid amountPerSecond: must be a positive number');\n  }\n\n  if (startTime <= 0) {\n    throw new Error('Invalid startTime: must be a positive number');\n  }\n\n  if (startTime > TIMESTAMP_UPPER_BOUND_SECONDS) {\n    throw new Error(\n      'Invalid startTime: must be less than or equal to 253402300799',\n    );\n  }\n\n  const terms = encodePacked(\n    ['uint256', 'uint256', 'uint256', 'uint256'],\n    [initialAmount, maxAmount, amountPerSecond, BigInt(startTime)],\n  );\n\n  const {\n    caveatEnforcers: { NativeTokenStreamingEnforcer },\n  } = environment;\n\n  return {\n    enforcer: NativeTokenStreamingEnforcer!,\n    terms,\n    args: '0x',\n  };\n};\n","import type { Caveat, DeleGatorEnvironment } from '..';\nimport { encodePacked } from 'viem';\n\nexport const nativeTokenTransferAmount = 'nativeTokenTransferAmount';\n\n/**\n * Builds a caveat struct for the NativeTokenTransferAmountEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param allowance - The maximum amount of native tokens allowed (in wei).\n * @returns The Caveat.\n * @throws Error if the maxAmount is invalid.\n */\nexport const nativeTokenTransferAmountBuilder = (\n  environment: DeleGatorEnvironment,\n  allowance: bigint,\n): Caveat => {\n  if (allowance < 0n) {\n    throw new Error('Invalid allowance: must be zero or positive');\n  }\n\n  const terms = encodePacked(['uint256'], [allowance]);\n\n  const {\n    caveatEnforcers: { NativeTokenTransferAmountEnforcer },\n  } = environment;\n\n  return {\n    enforcer: NativeTokenTransferAmountEnforcer!,\n    terms,\n    args: '0x',\n  };\n};\n","import type { DeleGatorEnvironment, Caveat } from '..';\nimport { type Address, isAddress, encodePacked } from 'viem';\nimport { BalanceChangeType } from './types';\n\nexport const nativeBalanceChange = 'nativeBalanceChange';\n\n/**\n * Builds a caveat struct for the NativeBalanceChangeEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param recipient - The address that should receive the balance change.\n * @param balance - The minimum balance amount required.\n * @param changeType - Whether the balance should increase or decrease.\n * @returns The Caveat.\n * @throws Error if the recipient address is invalid or the amount is not a positive number.\n */\nexport const nativeBalanceChangeBuilder = (\n  environment: DeleGatorEnvironment,\n  recipient: Address,\n  balance: bigint,\n  changeType: BalanceChangeType,\n): Caveat => {\n  if (!isAddress(recipient)) {\n    throw new Error('Invalid recipient: must be a valid Address');\n  }\n\n  if (balance <= 0n) {\n    throw new Error('Invalid balance: must be a positive number');\n  }\n\n  if (\n    changeType !== BalanceChangeType.Increase &&\n    changeType !== BalanceChangeType.Decrease\n  ) {\n    throw new Error('Invalid changeType: must be either Increase or Decrease');\n  }\n\n  const terms = encodePacked(\n    ['uint8', 'address', 'uint256'],\n    [changeType, recipient, balance],\n  );\n\n  const {\n    caveatEnforcers: { NativeBalanceChangeEnforcer },\n  } = environment;\n\n  return {\n    enforcer: NativeBalanceChangeEnforcer!,\n    terms,\n    args: '0x',\n  };\n};\n","import type { Caveat, DeleGatorEnvironment } from '..';\nimport { type Address, concat, isAddress } from 'viem';\n\nexport const redeemer = 'redeemer';\n\n/**\n * Builds a caveat struct for the RedeemerEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param redeemer[] - The addresses which will be allowed as the redeemer.\n * @returns The Caveat.\n * @throws Error if the redeemer address is invalid.\n */\nexport const redeemerBuilder = (\n  environment: DeleGatorEnvironment,\n  redeemers: Address[],\n): Caveat => {\n  if (redeemers.length === 0) {\n    throw new Error(\n      'Invalid redeemers: must specify at least one redeemer address',\n    );\n  }\n\n  for (let i = 0; i < redeemers.length; i++) {\n    if (!isAddress(redeemers[i]!)) {\n      throw new Error('Invalid redeemers: must be a valid address');\n    }\n  }\n\n  const terms = concat(redeemers);\n\n  const {\n    caveatEnforcers: { RedeemerEnforcer },\n  } = environment;\n\n  return {\n    enforcer: RedeemerEnforcer!,\n    terms,\n    args: '0x',\n  };\n};\n","import type { Caveat, DeleGatorEnvironment } from '..';\nimport { type Hex, encodePacked, isAddress } from 'viem';\n\nexport const nativeTokenPayment = 'nativeTokenPayment';\n\n/**\n * Builds a caveat struct for the NativeTokenPaymentEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param recipient - The address of the recipient of the payment.\n * @param amount - The amount of native tokens required for the payment.\n * @returns The Caveat.\n * @throws Error if the amount is invalid or the recipient address is invalid.\n */\nexport const nativeTokenPaymentBuilder = (\n  environment: DeleGatorEnvironment,\n  recipient: Hex,\n  amount: bigint,\n): Caveat => {\n  if (amount <= 0n) {\n    throw new Error('Invalid amount: must be positive');\n  }\n\n  if (!isAddress(recipient)) {\n    throw new Error('Invalid recipient: must be a valid address');\n  }\n\n  const terms = encodePacked(['address', 'uint256'], [recipient, amount]);\n\n  const {\n    caveatEnforcers: { NativeTokenPaymentEnforcer },\n  } = environment;\n\n  return {\n    enforcer: NativeTokenPaymentEnforcer!,\n    terms,\n    args: '0x',\n  };\n};\n","import type { DeleGatorEnvironment, Caveat } from '..';\nimport { type Hex, isHex } from 'viem';\n\nexport const argsEqualityCheck = 'argsEqualityCheck';\n\n/**\n * Builds a caveat struct for the ArgsEqualityCheckEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param args - The expected value for args.\n * @returns The Caveat.\n * @throws Error if the args is invalid.\n */\nexport const argsEqualityCheckBuilder = (\n  environment: DeleGatorEnvironment,\n  args: Hex,\n): Caveat => {\n  if (!isHex(args)) {\n    throw new Error('Invalid args: must be a valid hex string');\n  }\n\n  const terms = args;\n\n  const {\n    caveatEnforcers: { ArgsEqualityCheckEnforcer },\n  } = environment;\n\n  return {\n    enforcer: ArgsEqualityCheckEnforcer!,\n    terms,\n    args: '0x',\n  };\n};\n","import type { DeleGatorEnvironment, Caveat } from '..';\nimport { type Address, isAddress, encodePacked } from 'viem';\nimport { BalanceChangeType } from './types';\n\nexport const erc1155BalanceChange = 'erc1155BalanceChange';\n\n/**\n * Builds a caveat struct for the ERC1155BalanceChangeEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param tokenAddress - The tokenAddress of the ERC1155 token.\n * @param recipient - The address of the recipient whose balance must change.\n * @param tokenId - The ID of the ERC1155 token.\n * @param balance - The amount by which the recipient's balance must change.\n * @param changeType - The type of balance change (increase or decrease).\n * @returns The Caveat.\n * @throws Error if the token address is invalid, the recipient address is invalid, or the amount is not a positive number.\n */\nexport const erc1155BalanceChangeBuilder = (\n  environment: DeleGatorEnvironment,\n  tokenAddress: Address,\n  recipient: Address,\n  tokenId: bigint,\n  balance: bigint,\n  changeType: BalanceChangeType,\n): Caveat => {\n  if (!isAddress(tokenAddress, { strict: false })) {\n    throw new Error('Invalid tokenAddress: must be a valid address');\n  }\n\n  if (!isAddress(recipient, { strict: false })) {\n    throw new Error('Invalid recipient: must be a valid address');\n  }\n\n  if (balance <= 0n) {\n    throw new Error('Invalid balance: must be a positive number');\n  }\n\n  if (tokenId < 0) {\n    throw new Error('Invalid tokenId: must be a non-negative number');\n  }\n\n  if (\n    changeType !== BalanceChangeType.Increase &&\n    changeType !== BalanceChangeType.Decrease\n  ) {\n    throw new Error('Invalid changeType: must be either Increase or Decrease');\n  }\n\n  const terms = encodePacked(\n    ['uint8', 'address', 'address', 'uint256', 'uint256'],\n    [changeType, tokenAddress, recipient, tokenId, balance],\n  );\n\n  const {\n    caveatEnforcers: { ERC1155BalanceChangeEnforcer },\n  } = environment;\n\n  return {\n    enforcer: ERC1155BalanceChangeEnforcer!,\n    terms,\n    args: '0x',\n  };\n};\n","import type { DeleGatorEnvironment, Caveat } from '..';\nimport { type Address, isAddress, encodePacked } from 'viem';\nimport { BalanceChangeType } from './types';\n\nexport const erc721BalanceChange = 'erc721BalanceChange';\n\n/**\n * Builds a caveat struct for the ERC721BalanceChangeEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param tokenAddress - The tokenAddress of the ERC721 token.\n * @param recipient - The address of the recipient whose balance must change.\n * @param amount - The amount by which the recipient's balance must change.\n * @param changeType - The type of balance change (increase or decrease).\n * @returns The Caveat.\n * @throws Error if the token address is invalid, the recipient address is invalid, or the amount is not a positive number.\n */\nexport const erc721BalanceChangeBuilder = (\n  environment: DeleGatorEnvironment,\n  tokenAddress: Address,\n  recipient: Address,\n  amount: bigint,\n  changeType: BalanceChangeType,\n): Caveat => {\n  if (!isAddress(tokenAddress, { strict: false })) {\n    throw new Error('Invalid tokenAddress: must be a valid address');\n  }\n\n  if (!isAddress(recipient, { strict: false })) {\n    throw new Error('Invalid recipient: must be a valid address');\n  }\n\n  if (amount <= 0) {\n    throw new Error('Invalid balance: must be a positive number');\n  }\n\n  if (\n    changeType !== BalanceChangeType.Increase &&\n    changeType !== BalanceChangeType.Decrease\n  ) {\n    throw new Error('Invalid changeType: must be either Increase or Decrease');\n  }\n\n  const terms = encodePacked(\n    ['uint8', 'address', 'address', 'uint256'],\n    [changeType, tokenAddress, recipient, amount],\n  );\n\n  const {\n    caveatEnforcers: { ERC721BalanceChangeEnforcer },\n  } = environment;\n\n  return {\n    enforcer: ERC721BalanceChangeEnforcer!,\n    terms,\n    args: '0x',\n  };\n};\n","import type { DeleGatorEnvironment, Caveat } from '..';\nimport { type Address, isAddress, toHex, concat } from 'viem';\n\nexport const erc721Transfer = 'erc721Transfer';\n\n/**\n * Builds a caveat struct for the ERC721TransferEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param permittedContract - The permitted contract address for the ERC721 token.\n * @param permittedTokenId - The permitted token ID as a bigint.\n * @returns The Caveat representing the caveat for ERC721 transfer.\n * @throws Error if the permitted contract address is invalid.\n */\nexport const erc721TransferBuilder = (\n  environment: DeleGatorEnvironment,\n  permittedContract: Address,\n  permittedTokenId: bigint,\n): Caveat => {\n  if (!isAddress(permittedContract, { strict: false })) {\n    throw new Error('Invalid tokenAddress: must be a valid address');\n  }\n\n  if (permittedTokenId < 0) {\n    throw new Error('Invalid permittedTokenId: must be a non-negative number');\n  }\n\n  const terms = concat([\n    permittedContract,\n    toHex(permittedTokenId, { size: 32 }),\n  ]);\n\n  const {\n    caveatEnforcers: { ERC721TransferEnforcer },\n  } = environment;\n\n  return {\n    enforcer: ERC721TransferEnforcer!,\n    terms,\n    args: '0x',\n  };\n};\n","import type { Caveat, DeleGatorEnvironment } from '..';\nimport { concat, isAddress, toHex, type Address, type Hex } from 'viem';\n\nexport const specificActionERC20TransferBatch =\n  'specificActionERC20TransferBatch';\n\n/**\n * Builds a caveat struct for SpecificActionERC20TransferBatchEnforcer.\n * This enforcer validates a batch of exactly 2 transactions where:\n * 1. First transaction must match specific target, method and calldata\n * 2. Second transaction must be an ERC20 transfer with specific parameters\n *\n * @param environment - The DeleGator environment.\n * @param tokenAddress - The address of the ERC20 token contract.\n * @param recipient - The address that will receive the tokens.\n * @param amount - The amount of tokens to transfer.\n * @param firstTarget - The target address for the first transaction.\n * @param firstCalldata - The calldata for the first transaction.\n * @returns The Caveat.\n * @throws Error if any of the addresses are invalid or if the amount is not a positive number.\n */\nexport const specificActionERC20TransferBatchBuilder = (\n  environment: DeleGatorEnvironment,\n  tokenAddress: Address,\n  recipient: Address,\n  amount: bigint,\n  firstTarget: Address,\n  firstCalldata: Hex,\n): Caveat => {\n  if (!isAddress(tokenAddress, { strict: false })) {\n    throw new Error('Invalid tokenAddress: must be a valid address');\n  }\n\n  if (!isAddress(recipient, { strict: false })) {\n    throw new Error('Invalid recipient: must be a valid address');\n  }\n\n  if (!isAddress(firstTarget, { strict: false })) {\n    throw new Error('Invalid firstTarget: must be a valid address');\n  }\n\n  if (amount <= 0n) {\n    throw new Error('Invalid amount: must be a positive number');\n  }\n\n  const terms = concat([\n    tokenAddress,\n    recipient,\n    toHex(amount, { size: 32 }),\n    firstTarget,\n    firstCalldata,\n  ]);\n\n  const {\n    caveatEnforcers: { SpecificActionERC20TransferBatchEnforcer },\n  } = environment;\n\n  return {\n    enforcer: SpecificActionERC20TransferBatchEnforcer!,\n    terms,\n    args: '0x',\n  };\n};\n","import type { Caveat } from '../caveats';\nimport type { DeleGatorEnvironment } from '../types';\nimport { concat, isAddress, toHex } from 'viem';\nimport type { Address } from 'viem';\n\nexport const erc20PeriodTransfer = 'erc20PeriodTransfer';\n\n/**\n * Builds a caveat struct for ERC20PeriodTransferEnforcer.\n * This enforcer validates that ERC20 token transfers do not exceed a specified amount\n * within a given time period. The transferable amount resets at the beginning of each period,\n * and any unused tokens are forfeited once the period ends.\n *\n * @param environment - The DeleGator environment.\n * @param tokenAddress - The address of the ERC20 token contract.\n * @param periodAmount - The maximum amount of tokens that can be transferred per period.\n * @param periodDuration - The duration of each period in seconds.\n * @param startDate - The timestamp when the first period begins.\n * @returns The Caveat.\n * @throws Error if the token address is invalid or if any of the numeric parameters are invalid.\n */\nexport const erc20PeriodTransferBuilder = (\n  environment: DeleGatorEnvironment,\n  tokenAddress: Address,\n  periodAmount: bigint,\n  periodDuration: number,\n  startDate: number,\n): Caveat => {\n  if (!isAddress(tokenAddress)) {\n    throw new Error('Invalid tokenAddress: must be a valid address');\n  }\n\n  if (periodAmount <= 0n) {\n    throw new Error('Invalid periodAmount: must be a positive number');\n  }\n\n  if (periodDuration <= 0) {\n    throw new Error('Invalid periodDuration: must be a positive number');\n  }\n\n  if (startDate <= 0) {\n    throw new Error('Invalid startDate: must be a positive number');\n  }\n\n  const terms = concat([\n    tokenAddress,\n    toHex(periodAmount, { size: 32 }),\n    toHex(periodDuration, { size: 32 }),\n    toHex(startDate, { size: 32 }),\n  ]);\n\n  return {\n    enforcer: environment.caveatEnforcers.ERC20PeriodTransferEnforcer!,\n    terms,\n    args: '0x',\n  };\n};\n","import type { Caveat, DeleGatorEnvironment } from '..';\nimport { concat, toHex } from 'viem';\n\nexport const nativeTokenPeriodTransfer = 'nativeTokenPeriodTransfer';\n\n/**\n * Builds a caveat struct for NativeTokenPeriodTransferEnforcer.\n * This enforcer validates that native token (ETH) transfers do not exceed a specified amount\n * within a given time period. The transferable amount resets at the beginning of each period,\n * and any unused ETH is forfeited once the period ends.\n *\n * @param environment - The DeleGator environment.\n * @param periodAmount - The maximum amount of ETH (in wei) that can be transferred per period.\n * @param periodDuration - The duration of each period in seconds.\n * @param startDate - The timestamp when the first period begins.\n * @returns The Caveat.\n * @throws Error if any of the numeric parameters are invalid.\n */\nexport const nativeTokenPeriodTransferBuilder = (\n  environment: DeleGatorEnvironment,\n  periodAmount: bigint,\n  periodDuration: number,\n  startDate: number,\n): Caveat => {\n  if (periodAmount <= 0n) {\n    throw new Error('Invalid periodAmount: must be a positive number');\n  }\n\n  if (periodDuration <= 0) {\n    throw new Error('Invalid periodDuration: must be a positive number');\n  }\n\n  if (startDate <= 0) {\n    throw new Error('Invalid startDate: must be a positive number');\n  }\n\n  const terms = concat([\n    toHex(periodAmount, { size: 32 }),\n    toHex(periodDuration, { size: 32 }),\n    toHex(startDate, { size: 32 }),\n  ]);\n\n  const {\n    caveatEnforcers: { NativeTokenPeriodTransferEnforcer },\n  } = environment;\n\n  return {\n    enforcer: NativeTokenPeriodTransferEnforcer!,\n    terms,\n    args: '0x',\n  };\n};\n","import type { Caveat, DeleGatorEnvironment } from '..';\nimport {\n  concat,\n  encodeAbiParameters,\n  isAddress,\n  parseAbiParameters,\n  toHex,\n} from 'viem';\nimport type { ExecutionStruct } from '../executions';\n\nexport const exactCalldataBatch = 'exactCalldataBatch';\n\n/**\n * Builds a caveat struct for ExactCalldataBatchEnforcer.\n * This enforcer ensures that the provided batch execution calldata matches exactly\n * the expected calldata for each execution.\n *\n * @param environment - The DeleGator environment.\n * @param executions - Array of expected executions, each containing target address, value, and calldata.\n * @returns The Caveat.\n * @throws Error if any of the executions have invalid parameters.\n */\nexport const exactCalldataBatchBuilder = (\n  environment: DeleGatorEnvironment,\n  executions: ExecutionStruct[],\n): Caveat => {\n  if (executions.length === 0) {\n    throw new Error('Invalid executions: array cannot be empty');\n  }\n\n  // Validate each execution\n  for (const execution of executions) {\n    if (!isAddress(execution.target, { strict: false })) {\n      throw new Error('Invalid target: must be a valid address');\n    }\n\n    if (execution.value < 0n) {\n      throw new Error('Invalid value: must be a non-negative number');\n    }\n\n    if (!execution.callData.startsWith('0x')) {\n      throw new Error(\n        'Invalid callData: must be a hex string starting with 0x',\n      );\n    }\n  }\n\n  // Encode the executions using the approach implemented in ExecutionLib.sol encodeBatch()\n  const terms = encodeAbiParameters(\n    [\n      {\n        type: 'tuple[]',\n        components: [\n          { type: 'address', name: 'target' },\n          { type: 'uint256', name: 'value' },\n          { type: 'bytes', name: 'callData' },\n        ],\n      },\n    ],\n    [executions],\n  );\n\n  const {\n    caveatEnforcers: { ExactCalldataBatchEnforcer },\n  } = environment;\n\n  return {\n    enforcer: ExactCalldataBatchEnforcer!,\n    terms,\n    args: '0x',\n  };\n};\n","import type { Caveat, DeleGatorEnvironment } from '..';\n\nexport const exactCalldata = 'exactCalldata';\n\n/**\n * Builds a caveat struct for ExactCalldataEnforcer.\n * This enforcer ensures that the provided execution calldata matches exactly\n * the expected calldata.\n *\n * @param environment - The DeleGator environment.\n * @param callData - The expected calldata to match against.\n * @returns The Caveat.\n * @throws Error if the callData is invalid.\n */\nexport const exactCalldataBuilder = (\n  environment: DeleGatorEnvironment,\n  callData: `0x${string}`,\n): Caveat => {\n  if (!callData.startsWith('0x')) {\n    throw new Error('Invalid callData: must be a hex string starting with 0x');\n  }\n\n  const {\n    caveatEnforcers: { ExactCalldataEnforcer },\n  } = environment;\n\n  return {\n    enforcer: ExactCalldataEnforcer!,\n    terms: callData,\n    args: '0x',\n  };\n};\n","import type { Caveat, DeleGatorEnvironment } from '..';\nimport { isAddress, concat, toHex } from 'viem';\nimport type { ExecutionStruct } from '../executions';\n\nexport const exactExecution = 'exactExecution';\n\n/**\n * Builds a caveat struct for ExactExecutionEnforcer.\n * This enforcer ensures that the provided execution matches exactly\n * with the expected execution (target, value, and calldata).\n *\n * @param environment - The DeleGator environment.\n * @param execution - The expected execution to match against.\n * @returns The Caveat.\n * @throws Error if any of the execution parameters are invalid.\n */\nexport const exactExecutionBuilder = (\n  environment: DeleGatorEnvironment,\n  execution: ExecutionStruct,\n): Caveat => {\n  if (!isAddress(execution.target, { strict: false })) {\n    throw new Error('Invalid target: must be a valid address');\n  }\n\n  if (execution.value < 0n) {\n    throw new Error('Invalid value: must be a non-negative number');\n  }\n\n  if (!execution.callData.startsWith('0x')) {\n    throw new Error('Invalid callData: must be a hex string starting with 0x');\n  }\n\n  const terms = concat([\n    execution.target,\n    toHex(execution.value, { size: 32 }),\n    execution.callData,\n  ]);\n\n  const {\n    caveatEnforcers: { ExactExecutionEnforcer },\n  } = environment;\n\n  return {\n    enforcer: ExactExecutionEnforcer!,\n    terms,\n    args: '0x',\n  };\n};\n","import type { Caveat, DeleGatorEnvironment } from '..';\nimport { concat, encodeAbiParameters, isAddress, toHex } from 'viem';\nimport type { ExecutionStruct } from '../executions';\n\nexport const exactExecutionBatch = 'exactExecutionBatch';\n\n/**\n * Builds a caveat struct for ExactExecutionBatchEnforcer.\n * This enforcer ensures that each execution in the batch matches exactly\n * with the expected execution (target, value, and calldata).\n *\n * @param environment - The DeleGator environment.\n * @param executions - Array of expected executions to match against.\n * @returns The Caveat.\n * @throws Error if any of the execution parameters are invalid.\n */\nexport const exactExecutionBatchBuilder = (\n  environment: DeleGatorEnvironment,\n  executions: ExecutionStruct[],\n): Caveat => {\n  if (executions.length === 0) {\n    throw new Error('Invalid executions: array cannot be empty');\n  }\n\n  // Validate each execution\n  for (const execution of executions) {\n    if (!isAddress(execution.target, { strict: false })) {\n      throw new Error('Invalid target: must be a valid address');\n    }\n\n    if (execution.value < 0n) {\n      throw new Error('Invalid value: must be a non-negative number');\n    }\n\n    if (!execution.callData.startsWith('0x')) {\n      throw new Error(\n        'Invalid callData: must be a hex string starting with 0x',\n      );\n    }\n  }\n\n  // Encode the executions using the approach implemented in ExecutionLib.sol encodeBatch()\n  const terms = encodeAbiParameters(\n    [\n      {\n        type: 'tuple[]',\n        components: [\n          { type: 'address', name: 'target' },\n          { type: 'uint256', name: 'value' },\n          { type: 'bytes', name: 'callData' },\n        ],\n      },\n    ],\n    [executions],\n  );\n\n  const {\n    caveatEnforcers: { ExactExecutionBatchEnforcer },\n  } = environment;\n\n  return {\n    enforcer: ExactExecutionBatchEnforcer!,\n    terms,\n    args: '0x',\n  };\n};\n","import { concat, Hex, isAddress, pad, toHex } from 'viem';\nimport type { DeleGatorEnvironment, Caveat } from '..';\n\nexport type TokenPeriodConfig = {\n  token: Hex;\n  periodAmount: bigint;\n  periodDuration: number;\n  startDate: number;\n};\n\nexport const multiTokenPeriod = 'multiTokenPeriod';\n\n/**\n * Creates a caveat for the MultiTokenPeriodEnforcer.\n * This enforcer allows setting periodic transfer limits for multiple tokens.\n * Each token can have its own period amount, duration, and start date.\n *\n * @param environment - The DeleGator environment\n * @param configs - Array of token period configurations\n * @returns The caveat object for the MultiTokenPeriodEnforcer\n */\nexport const multiTokenPeriodBuilder = (\n  environment: DeleGatorEnvironment,\n  configs: TokenPeriodConfig[],\n): Caveat => {\n  if (!configs || configs.length === 0) {\n    throw new Error('MultiTokenPeriodBuilder: configs array cannot be empty');\n  }\n\n  configs.forEach((config) => {\n    if (!isAddress(config.token)) {\n      throw new Error(`Invalid token address: ${config.token}`);\n    }\n\n    if (config.periodAmount <= 0) {\n      throw new Error('Invalid period amount: must be greater than 0');\n    }\n\n    if (config.periodDuration <= 0) {\n      throw new Error('Invalid period duration: must be greater than 0');\n    }\n  });\n\n  // Each config requires 116 bytes:\n  // - 20 bytes for token address\n  // - 32 bytes for periodAmount\n  // - 32 bytes for periodDuration\n  // - 32 bytes for startDate\n  const termsArray = configs.reduce<Hex[]>(\n    (acc, { token, periodAmount, periodDuration, startDate }) => [\n      ...acc,\n      pad(token, { size: 20 }),\n      toHex(periodAmount, { size: 32 }),\n      toHex(periodDuration, { size: 32 }),\n      toHex(startDate, { size: 32 }),\n    ],\n    [],\n  );\n\n  const terms = concat(termsArray);\n\n  const {\n    caveatEnforcers: { MultiTokenPeriodEnforcer },\n  } = environment;\n\n  return {\n    enforcer: MultiTokenPeriodEnforcer!,\n    terms,\n    args: '0x',\n  };\n};\n","import type { DeleGatorEnvironment } from '..';\n\nimport { allowedMethods, allowedMethodsBuilder } from './allowedMethodsBuilder';\nimport { allowedTargets, allowedTargetsBuilder } from './allowedTargetsBuilder';\nimport { CaveatBuilder, CaveatBuilderConfig } from './caveatBuilder';\nimport { deployed, deployedBuilder } from './deployedBuilder';\nimport {\n  allowedCalldata,\n  allowedCalldataBuilder,\n} from './allowedCalldataBuilder';\nimport {\n  erc20BalanceChange,\n  erc20BalanceChangeBuilder,\n} from './erc20BalanceChangeBuilder';\nimport { valueLte, valueLteBuilder } from './valueLteBuilder';\nimport { limitedCalls, limitedCallsBuilder } from './limitedCallsBuilder';\nimport { id, idBuilder } from './idBuilder';\nimport { nonce, nonceBuilder } from './nonceBuilder';\nimport { timestamp, timestampBuilder } from './timestampBuilder';\nimport { blockNumber, blockNumberBuilder } from './blockNumberBuilder';\nimport {\n  erc20TransferAmount,\n  erc20TransferAmountBuilder,\n} from './erc20TransferAmountBuilder';\nimport { erc20Streaming, erc20StreamingBuilder } from './erc20StreamingBuilder';\nimport {\n  nativeTokenStreaming,\n  nativeTokenStreamingBuilder,\n} from './nativeTokenStreamingBuilder';\nimport {\n  nativeTokenTransferAmount,\n  nativeTokenTransferAmountBuilder,\n} from './nativeTokenTransferAmountBuilder';\nimport {\n  nativeBalanceChange,\n  nativeBalanceChangeBuilder,\n} from './nativeBalanceChangeBuilder';\nimport { redeemer, redeemerBuilder } from './redeemerBuilder';\nimport {\n  nativeTokenPayment,\n  nativeTokenPaymentBuilder,\n} from './nativeTokenPaymentBuilder';\nimport {\n  argsEqualityCheck,\n  argsEqualityCheckBuilder,\n} from './argsEqualityCheckBuilder';\nimport {\n  erc1155BalanceChange,\n  erc1155BalanceChangeBuilder,\n} from './erc1155BalanceChangeBuilder';\nimport {\n  erc721BalanceChange,\n  erc721BalanceChangeBuilder,\n} from './erc721BalanceChangeBuilder';\nimport { erc721Transfer, erc721TransferBuilder } from './erc721TransferBuilder';\nimport {\n  specificActionERC20TransferBatch,\n  specificActionERC20TransferBatchBuilder,\n} from './specificActionERC20TransferBatchBuilder';\nimport {\n  erc20PeriodTransfer,\n  erc20PeriodTransferBuilder,\n} from './erc20PeriodTransferBuilder';\nimport {\n  nativeTokenPeriodTransfer,\n  nativeTokenPeriodTransferBuilder,\n} from './nativeTokenPeriodTransferBuilder';\nimport {\n  exactCalldataBatch,\n  exactCalldataBatchBuilder,\n} from './exactCalldataBatchBuilder';\nimport { exactCalldata, exactCalldataBuilder } from './exactCalldataBuilder';\nimport { exactExecution, exactExecutionBuilder } from './exactExecutionBuilder';\nimport {\n  exactExecutionBatch,\n  exactExecutionBatchBuilder,\n} from './exactExecutionBatchBuilder';\nimport {\n  multiTokenPeriod,\n  multiTokenPeriodBuilder,\n} from './multiTokenPeriodBuilder';\nimport { BalanceChangeType } from './types';\n\nexport { resolveCaveats } from './caveatBuilder';\nexport type { Caveats, CaveatBuilderConfig } from './caveatBuilder';\nexport { CaveatBuilder } from './caveatBuilder';\nexport { BalanceChangeType } from './types';\nexport { nativeBalanceChange } from './nativeBalanceChangeBuilder';\nexport { erc721BalanceChange } from './erc721BalanceChangeBuilder';\nexport { erc1155BalanceChange } from './erc1155BalanceChangeBuilder';\n\nexport const createCaveatBuilder = (\n  environment: DeleGatorEnvironment,\n  config?: CaveatBuilderConfig,\n) => {\n  const caveatBuilder = new CaveatBuilder(environment, config)\n    .extend(allowedMethods, allowedMethodsBuilder)\n    .extend(allowedTargets, allowedTargetsBuilder)\n    .extend(deployed, deployedBuilder)\n    .extend(allowedCalldata, allowedCalldataBuilder)\n    .extend(erc20BalanceChange, erc20BalanceChangeBuilder)\n    .extend(erc721BalanceChange, erc721BalanceChangeBuilder)\n    .extend(erc1155BalanceChange, erc1155BalanceChangeBuilder)\n    .extend(valueLte, valueLteBuilder)\n    .extend(limitedCalls, limitedCallsBuilder)\n    .extend(id, idBuilder)\n    .extend(nonce, nonceBuilder)\n    .extend(timestamp, timestampBuilder)\n    .extend(blockNumber, blockNumberBuilder)\n    .extend(erc20TransferAmount, erc20TransferAmountBuilder)\n    .extend(erc20Streaming, erc20StreamingBuilder)\n    .extend(nativeTokenStreaming, nativeTokenStreamingBuilder)\n    .extend(erc721Transfer, erc721TransferBuilder)\n    .extend(nativeTokenTransferAmount, nativeTokenTransferAmountBuilder)\n    .extend(nativeBalanceChange, nativeBalanceChangeBuilder)\n    .extend(redeemer, redeemerBuilder)\n    .extend(nativeTokenPayment, nativeTokenPaymentBuilder)\n    .extend(argsEqualityCheck, argsEqualityCheckBuilder)\n    .extend(\n      specificActionERC20TransferBatch,\n      specificActionERC20TransferBatchBuilder,\n    )\n    .extend(erc20PeriodTransfer, erc20PeriodTransferBuilder)\n    .extend(nativeTokenPeriodTransfer, nativeTokenPeriodTransferBuilder)\n    .extend(exactCalldataBatch, exactCalldataBatchBuilder)\n    .extend(exactCalldata, exactCalldataBuilder)\n    .extend(exactExecution, exactExecutionBuilder)\n    .extend(exactExecutionBatch, exactExecutionBatchBuilder)\n    .extend(multiTokenPeriod, multiTokenPeriodBuilder);\n\n  return caveatBuilder;\n};\n\nexport type CoreCaveatBuilder = ReturnType<typeof createCaveatBuilder>;\n","import type { Chain, Hex, PublicClient, WalletClient } from 'viem';\nimport { DELEGATOR_CONTRACTS } from '@metamask/delegation-deployments';\nimport { ContractMetaData, DeleGatorEnvironment } from './types';\nimport {\n  EntryPoint,\n  SimpleFactory,\n  DelegationManager,\n  MultiSigDeleGator,\n  HybridDeleGator,\n  SCL_RIP7212,\n  AllowedTargetsEnforcer,\n  AllowedMethodsEnforcer,\n  DeployedEnforcer,\n  TimestampEnforcer,\n  NonceEnforcer,\n  AllowedCalldataEnforcer,\n  BlockNumberEnforcer,\n  LimitedCallsEnforcer,\n  ERC20BalanceChangeEnforcer,\n  ERC20StreamingEnforcer,\n  IdEnforcer,\n  ERC20TransferAmountEnforcer,\n  ValueLteEnforcer,\n  NativeTokenTransferAmountEnforcer,\n  NativeBalanceChangeEnforcer,\n  NativeTokenStreamingEnforcer,\n  NativeTokenPaymentEnforcer,\n  RedeemerEnforcer,\n  ArgsEqualityCheckEnforcer,\n  ERC721BalanceChangeEnforcer,\n  ERC721TransferEnforcer,\n  ERC1155BalanceChangeEnforcer,\n  OwnershipTransferEnforcer,\n  SpecificActionERC20TransferBatchEnforcer,\n  ERC20PeriodTransferEnforcer,\n  NativeTokenPeriodTransferEnforcer,\n  ExactCalldataBatchEnforcer,\n  ExactCalldataEnforcer,\n  ExactExecutionEnforcer,\n  ExactExecutionBatchEnforcer,\n  MultiTokenPeriodEnforcer,\n} from '@metamask/delegation-abis';\nimport { deployContract } from './write';\n\ntype SupportedVersion = '1.0.0' | '1.1.0' | '1.2.0' | '1.3.0';\nexport const PREFERRED_VERSION: SupportedVersion = '1.3.0';\n\ntype DeployedEnvironments = Record<\n  SupportedVersion,\n  Record<number, DeleGatorEnvironment>\n>;\n\nconst contractOverrides: DeployedEnvironments = {\n  '1.0.0': {},\n  '1.1.0': {},\n  '1.2.0': {},\n  '1.3.0': {},\n};\n\nexport function overrideDeployedEnvironment(\n  chainId: number,\n  version: SupportedVersion,\n  environment: DeleGatorEnvironment,\n) {\n  contractOverrides[version][chainId] = environment;\n}\n\n// Utilities to parse a \"DeleGator Environment\" from the store of delegation contracts given a chainId and version number.\n// Version numbers are tied to GitHub tags on the Delegation Framework Repository.\n// ABIs and interfaces are tightly coupled with the versions set below.\nexport function getDeleGatorEnvironment(\n  chainId: number,\n  version: SupportedVersion = PREFERRED_VERSION,\n) {\n  const override = contractOverrides[version][chainId];\n  if (override) {\n    return override;\n  }\n\n  const c = DELEGATOR_CONTRACTS[version]?.[chainId];\n  if (!c) {\n    throw new Error(\n      `No contracts found for version ${version} chain ${chainId}`,\n    );\n  }\n  return getDeleGatorEnvironment_v1(c);\n}\n\nexport function getDeleGatorEnvironment_v1(c: { [contract: string]: Hex }) {\n  return {\n    DelegationManager: c.DelegationManager,\n    EntryPoint: c.EntryPoint,\n    SimpleFactory: c.SimpleFactory,\n    implementations: {\n      MultiSigDeleGatorImpl: c.MultiSigDeleGatorImpl,\n      HybridDeleGatorImpl: c.HybridDeleGatorImpl,\n    },\n    caveatEnforcers: {\n      AllowedCalldataEnforcer: c.AllowedCalldataEnforcer,\n      AllowedMethodsEnforcer: c.AllowedMethodsEnforcer,\n      AllowedTargetsEnforcer: c.AllowedTargetsEnforcer,\n      ArgsEqualityCheckEnforcer: c.ArgsEqualityCheckEnforcer,\n      BlockNumberEnforcer: c.BlockNumberEnforcer,\n      DeployedEnforcer: c.DeployedEnforcer,\n      ERC20BalanceChangeEnforcer: c.ERC20BalanceChangeEnforcer,\n      ERC20TransferAmountEnforcer: c.ERC20TransferAmountEnforcer,\n      ERC20StreamingEnforcer: c.ERC20StreamingEnforcer,\n      ERC721BalanceChangeEnforcer: c.ERC721BalanceChangeEnforcer,\n      ERC721TransferEnforcer: c.ERC721TransferEnforcer,\n      ERC1155BalanceChangeEnforcer: c.ERC1155BalanceChangeEnforcer,\n      IdEnforcer: c.IdEnforcer,\n      LimitedCallsEnforcer: c.LimitedCallsEnforcer,\n      NonceEnforcer: c.NonceEnforcer,\n      TimestampEnforcer: c.TimestampEnforcer,\n      ValueLteEnforcer: c.ValueLteEnforcer,\n      NativeTokenTransferAmountEnforcer: c.NativeTokenTransferAmountEnforcer,\n      NativeBalanceChangeEnforcer: c.NativeBalanceChangeEnforcer,\n      NativeTokenStreamingEnforcer: c.NativeTokenStreamingEnforcer,\n      NativeTokenPaymentEnforcer: c.NativeTokenPaymentEnforcer,\n      OwnershipTransferEnforcer: c.OwnershipTransferEnforcer,\n      RedeemerEnforcer: c.RedeemerEnforcer,\n      SpecificActionERC20TransferBatchEnforcer:\n        c.SpecificActionERC20TransferBatchEnforcer,\n      ERC20PeriodTransferEnforcer: c.ERC20PeriodTransferEnforcer,\n      NativeTokenPeriodTransferEnforcer: c.NativeTokenPeriodTransferEnforcer,\n      ExactCalldataBatchEnforcer: c.ExactCalldataBatchEnforcer,\n      ExactCalldataEnforcer: c.ExactCalldataEnforcer,\n      ExactExecutionEnforcer: c.ExactExecutionEnforcer,\n      ExactExecutionBatchEnforcer: c.ExactExecutionBatchEnforcer,\n      MultiTokenPeriodEnforcer: c.MultiTokenPeriodEnforcer,\n    },\n  } as DeleGatorEnvironment;\n}\n\nexport type DeployedContract = {\n  name: string;\n  address: string;\n};\n\n/**\n * Deploys the contracts needed for the Delegation Framework and DeleGator SCA to be functional as well as all Caveat Enforcers.\n * @param walletClient\n * @param publicClient\n * @param chain\n */\nexport async function deployDeleGatorEnvironment(\n  walletClient: WalletClient,\n  publicClient: PublicClient,\n  chain: Chain,\n  deployedContracts: { [contract: string]: Hex } = {},\n) {\n  const deployContractCurried = async (\n    name: string,\n    contract: ContractMetaData,\n    params: any[] = [],\n  ) => {\n    if (deployedContracts[name]) {\n      return {\n        address: deployedContracts[name],\n        name,\n      };\n    }\n\n    const deployedContract = await deployContract(\n      walletClient,\n      publicClient,\n      chain,\n      contract,\n      params,\n    );\n\n    deployedContracts[name] = deployedContract.address as Hex;\n\n    return { ...deployedContract, name };\n  };\n\n  // Deploy v1.3.0 DeleGator contracts\n  // - deploy standalone contracts\n  const standaloneContracts = {\n    SimpleFactory,\n    AllowedCalldataEnforcer,\n    AllowedTargetsEnforcer,\n    AllowedMethodsEnforcer,\n    ArgsEqualityCheckEnforcer,\n    DeployedEnforcer,\n    TimestampEnforcer,\n    BlockNumberEnforcer,\n    LimitedCallsEnforcer,\n    ERC20BalanceChangeEnforcer,\n    ERC20TransferAmountEnforcer,\n    ERC20StreamingEnforcer,\n    ERC721BalanceChangeEnforcer,\n    ERC721TransferEnforcer,\n    ERC1155BalanceChangeEnforcer,\n    IdEnforcer,\n    NonceEnforcer,\n    ValueLteEnforcer,\n    NativeTokenTransferAmountEnforcer,\n    NativeBalanceChangeEnforcer,\n    NativeTokenStreamingEnforcer,\n    OwnershipTransferEnforcer,\n    RedeemerEnforcer,\n    SpecificActionERC20TransferBatchEnforcer,\n    ERC20PeriodTransferEnforcer,\n    NativeTokenPeriodTransferEnforcer,\n    ExactCalldataBatchEnforcer,\n    ExactCalldataEnforcer,\n    ExactExecutionEnforcer,\n    ExactExecutionBatchEnforcer,\n    MultiTokenPeriodEnforcer,\n  };\n  for (const [name, contract] of Object.entries(standaloneContracts)) {\n    await deployContractCurried(name, contract);\n  }\n\n  // - deploy dependencies\n  const delegationManager = await deployContractCurried(\n    'DelegationManager',\n    DelegationManager,\n    [walletClient.account?.address],\n  );\n\n  // - NativeTokenPaymentEnforcer DelegationManager and ArgsEqualityCheckEnforcer as constructor args\n  await deployContractCurried(\n    'NativeTokenPaymentEnforcer',\n    NativeTokenPaymentEnforcer,\n    [delegationManager.address, deployedContracts['ArgsEqualityCheckEnforcer']],\n  );\n\n  const entryPoint = await deployContractCurried('EntryPoint', EntryPoint);\n\n  // This is a hack to work around the SCL_RIP7212 being deployed as a library.\n  // Forge handles this gracefully, but in the tests we need to manually link\n  // the library.\n  // We don't use the curried function here because we don't need it added to\n  // the environment.\n  const { address: sclRIP7212 } = await deployContract(\n    walletClient,\n    publicClient,\n    chain,\n    SCL_RIP7212,\n    [],\n  );\n\n  // replace linked library address in bytecode https://docs.soliditylang.org/en/latest/using-the-compiler.html#library-linking\n  const hybridDeleGatorWithLinkedLibrary = {\n    ...HybridDeleGator,\n    bytecode: HybridDeleGator.bytecode.replace(\n      /__\\$b8f96b288d4d0429e38b8ed50fd423070f\\$__/g,\n      sclRIP7212.slice(2),\n    ) as Hex,\n  };\n\n  // - deploy DeleGator implementations\n  await deployContractCurried(\n    'HybridDeleGatorImpl',\n    hybridDeleGatorWithLinkedLibrary,\n    [delegationManager.address, entryPoint.address],\n  );\n\n  await deployContractCurried('MultiSigDeleGatorImpl', MultiSigDeleGator, [\n    delegationManager.address,\n    entryPoint.address,\n  ]);\n\n  // Format deployments\n  return getDeleGatorEnvironment_v1(deployedContracts);\n}\n","import type { Address, Chain, Hex, PublicClient, WalletClient } from 'viem';\nimport { SimpleFactory, DelegationManager } from '@metamask/delegation-abis';\nimport { Delegation, encodePermissionContexts } from './delegation';\nimport {\n  ExecutionStruct,\n  encodeExecutionCalldatas,\n  ExecutionMode,\n} from './executions';\nimport type { ContractMetaData, Redemption } from './types';\n\n/**\n * Deploys a contract using the SimpleFactory contract.\n * @param walletClient\n * @param publicClient\n * @param simpleFactoryAddress\n * @param creationCode\n * @param salt\n * @returns\n */\nexport const deployWithSimpleFactory = async (\n  walletClient: WalletClient,\n  publicClient: PublicClient,\n  simpleFactoryAddress: Address,\n  creationCode: Hex,\n  salt: Hex,\n) => {\n  const { request } = await publicClient.simulateContract({\n    account: walletClient.account,\n    address: simpleFactoryAddress,\n    abi: SimpleFactory.abi,\n    functionName: 'deploy',\n    args: [creationCode, salt],\n  });\n  return await walletClient.writeContract(request);\n};\n\n/**\n * Redeems a delegation and executes the provided execution.\n * @param walletClient the wallet to redeem with\n * @param publicClient the public client to use\n * @param delegationManagerAddress the address of the DelegationManager that the delegation is linked with\n * @param redemptions Contains the permissionContext, executions and execution mode.\n * @returns\n */\nexport const redeemDelegations = async (\n  walletClient: WalletClient,\n  publicClient: PublicClient,\n  delegationManagerAddress: Address,\n  redemptions: Redemption[],\n) => {\n  if (redemptions.length === 0) {\n    throw new Error(`RedeemDelegations invalid zero redemptions`);\n  }\n\n  const permissionContexts: Delegation[][] = [];\n  const executionsBatch: ExecutionStruct[][] = [];\n  const executionModes: ExecutionMode[] = [];\n\n  // Iterate over the Redemption array and extract the values\n  redemptions.forEach((redemption) => {\n    permissionContexts.push(redemption.permissionContext);\n    executionsBatch.push(redemption.executions);\n    executionModes.push(redemption.mode);\n  });\n\n  const encodedPermissionContexts =\n    encodePermissionContexts(permissionContexts);\n  const executionCalldatas = encodeExecutionCalldatas(executionsBatch);\n\n  // Simulate the redemption to validate the call succeeds, rather than failing\n  // in the transaction and spending gas\n  const { request } = await publicClient.simulateContract({\n    account: walletClient.account,\n    address: delegationManagerAddress,\n    abi: DelegationManager.abi,\n    functionName: 'redeemDelegations',\n    args: [encodedPermissionContexts, executionModes, executionCalldatas],\n  });\n  return await walletClient.writeContract(request);\n};\n\n/**\n *\n * @param walletClient The wallet to deploy with\n * @param publicClient Access to the public chain\n * @param chain The chain to deploy on\n * @param contractMetadata The metadata of the contract to deploy\n * @param args\n * @returns\n */\nexport async function deployContract(\n  walletClient: WalletClient,\n  publicClient: PublicClient,\n  chain: Chain,\n  { bytecode, abi }: ContractMetaData,\n  args: any[] = [],\n) {\n  const hash = await walletClient.deployContract({\n    abi,\n    bytecode,\n    args,\n    account: walletClient.account!,\n    chain,\n  });\n  const receipt = await publicClient.waitForTransactionReceipt({\n    hash,\n  });\n  const address = (await receipt).contractAddress!;\n\n  return { address, hash, receipt };\n}\n","export type JSONRPCError = { message: string; code: number; data?: any };\n\nexport class RpcError extends Error {\n  public readonly code: number;\n\n  public readonly data?: object;\n\n  public static INVALID_PARAMETERS = -32602;\n\n  public static INTERNAL_ERROR = -32603;\n\n  public static METHOD_NOT_SUPPORTED = -32601;\n\n  // implementation-defined server-error\n  public static CONNECTION_CLOSED = -32001;\n\n  public static from(error: RpcError | Error | string): RpcError {\n    if (error instanceof RpcError) {\n      return error;\n    }\n\n    const errorMessage = error instanceof Error ? error.message : error;\n\n    return new RpcError(errorMessage, RpcError.INTERNAL_ERROR);\n  }\n\n  public toJSONRPCError(): JSONRPCError {\n    const { message, code, data } = this;\n\n    return {\n      message,\n      code,\n      data,\n    };\n  }\n\n  constructor(message: string, code: number, data?: object) {\n    super(message);\n\n    // https://www.typescriptlang.org/docs/handbook/2/classes.html#inheriting-built-in-types\n    Object.setPrototypeOf(this, RpcError.prototype);\n\n    this.code = code;\n    this.data = data;\n  }\n}\n","import { concat, encodeAbiParameters, keccak256, pad, toHex } from 'viem';\nimport type {\n  Account,\n  Address,\n  Chain,\n  Hex,\n  Transport,\n  TypedData,\n  WalletClient,\n} from 'viem';\nimport type { OptionalUserOpProps, PackedUserOperationStruct } from './types';\nimport { toPackedUserOperation } from 'viem/account-abstraction';\n\n// v7 off-chain user operation, hexlified incoming data from rpc call\nexport type UserOperationV07Hexlify = {\n  sender: Hex;\n  nonce: Hex;\n  factory?: Hex;\n  factoryData?: Hex;\n  callData: Hex;\n  callGasLimit: Hex;\n\n  verificationGasLimit: Hex;\n  preVerificationGas: Hex;\n  maxFeePerGas: Hex;\n  maxPriorityFeePerGas: Hex;\n\n  paymaster?: Hex;\n  paymasterVerificationGasLimit?: Hex;\n  paymasterPostOpGasLimit?: Hex;\n  paymasterData?: Hex;\n\n  signature: Hex;\n};\n\n// v7 off-chain user operation with BigInt fields\nexport type UserOperationV07 = {\n  sender: Hex;\n  nonce: bigint;\n  factory?: Hex;\n  factoryData?: Hex;\n  callData: Hex;\n\n  callGasLimit: bigint;\n  verificationGasLimit: bigint;\n  preVerificationGas: bigint;\n  maxFeePerGas: bigint;\n  maxPriorityFeePerGas: bigint;\n\n  paymaster?: Hex;\n  paymasterVerificationGasLimit?: bigint;\n  paymasterPostOpGasLimit?: bigint;\n  paymasterData?: Hex;\n\n  signature: Hex;\n};\n\n/**\n * Creates a raw user operation data structure.\n * @param sender The smart account taking some action.\n * @param nonce A nonce, ideally fetched from the Entry Point.\n * @param callData Calldata to invoke on some contract.\n * @param options Optional properties for the user operation including:\n * - initCode bytecode to initialize a contract if necessary\n * - accountGasLimits Packed gas limits for validateUserOp and gas limit passed to the callData method call.\n * - preVerificationGas Gas not calculated by the handleOps method, but added to the gas paid.\n * - paymasterAndData If set, this field holds the paymaster address, verification gas limit, postOp gas limit and paymaster-specific extra data\n *  The paymaster will pay for the transaction instead of the sender.\n * @returns The created raw user operation data structure.\n */\nexport const createRawUserOp = (\n  sender: Hex,\n  nonce: bigint,\n  callData: Hex,\n  signature: Hex = '0x',\n  options?: OptionalUserOpProps,\n): UserOperationV07 => ({\n  sender,\n  nonce,\n  callData,\n  factory: options?.factory,\n  factoryData: options?.factoryData,\n  callGasLimit: options?.callGasLimit ?? 0n,\n  verificationGasLimit: options?.verificationGasLimit ?? 0n,\n  preVerificationGas: options?.preVerificationGas ?? 0n,\n  maxFeePerGas: options?.maxFeePerGas ?? 0n,\n  maxPriorityFeePerGas: options?.maxPriorityFeePerGas ?? 0n,\n  paymaster: options?.paymaster,\n  paymasterVerificationGasLimit: options?.paymasterVerificationGasLimit,\n  paymasterPostOpGasLimit: options?.paymasterPostOpGasLimit,\n  paymasterData: options?.paymasterData,\n  signature,\n});\n\n////////////////////////////////////////////////////////////////////////////////////////\n\n// TODO: These userOp functions are duplicated in ./apps/ew-client/src/utils/userOpBuilder.ts. We should move them to a shared location along with test(./apps/ew-client/test/UserOpBuilder.test.ts) to avoid duplication\n/**\n * Generates a salt value for address derivation, using a default value if none is provided.\n * @param salt - Optional salt value.\n * @returns The chosen salt value.\n */\nexport const getSalt = (salt?: Hex) => {\n  if (!salt) {\n    salt = '0x0';\n  }\n  return salt;\n};\n\nexport const getPaymasterAndData = (userOp: UserOperationV07): Hex => {\n  let paymasterAndData: Hex;\n  if (userOp.paymaster) {\n    paymasterAndData = concat([\n      userOp.paymaster,\n      pad(toHex(userOp.paymasterVerificationGasLimit || 0n), {\n        size: 16,\n      }),\n      pad(toHex(userOp.paymasterPostOpGasLimit || 0n), {\n        size: 16,\n      }),\n      userOp.paymasterData || ('0x' as Hex),\n    ]);\n  } else {\n    paymasterAndData = '0x';\n  }\n\n  return paymasterAndData;\n};\n\nexport const getInitCode = (userOp: UserOperationV07): Hex => {\n  return userOp.factory\n    ? concat([userOp.factory, userOp.factoryData ?? ('0x' as Hex)])\n    : '0x';\n};\n\nexport const getAccountGasLimits = (userOp: UserOperationV07): Hex => {\n  return concat([\n    pad(toHex(userOp.verificationGasLimit), {\n      size: 16,\n    }),\n    pad(toHex(userOp.callGasLimit), { size: 16 }),\n  ]);\n};\n\nexport const getGasFees = (userOp: UserOperationV07): Hex => {\n  return concat([\n    pad(toHex(userOp.maxPriorityFeePerGas), {\n      size: 16,\n    }),\n    pad(toHex(userOp.maxFeePerGas), { size: 16 }),\n  ]);\n};\n\n/**\n * Packs a user operation into a `PackedUserOperationStruct` object.\n *\n * @param userOp - The user operation to pack.\n * @returns The packed user operation.\n */\nexport const packUserOp = (\n  userOp: UserOperationV07,\n): PackedUserOperationStruct => {\n  const packedOp = {\n    sender: userOp.sender,\n    nonce: BigInt(userOp.nonce),\n    initCode: getInitCode(userOp),\n    callData: userOp.callData,\n    accountGasLimits: getAccountGasLimits(userOp),\n    preVerificationGas: BigInt(userOp.preVerificationGas),\n    gasFees: getGasFees(userOp),\n    paymasterAndData: getPaymasterAndData(userOp),\n    signature: userOp.signature,\n  };\n\n  return packedOp;\n};\n\n/*\n * Calculates the user operation hash for a given packed user operation.\n * @param packedOp - The packed user operation.\n * @param entryPoint - The entry point address.\n * @param chainId - The chain ID.\n * @returns The user operation hash.\n */\nexport const createUserOpHashV07 = (\n  packedOp: PackedUserOperationStruct,\n  entryPoint: Hex,\n  chainId: bigint,\n) => {\n  const hash = keccak256(\n    encodeAbiParameters(\n      [\n        {\n          name: 'sender',\n          type: 'address',\n        },\n        {\n          name: 'nonce',\n          type: 'uint256',\n        },\n        {\n          name: 'initCodeHash',\n          type: 'bytes32',\n        },\n        {\n          name: 'callDataHash',\n          type: 'bytes32',\n        },\n        {\n          name: 'accountGasLimits',\n          type: 'bytes32',\n        },\n        {\n          name: 'preVerificationGas',\n          type: 'uint256',\n        },\n        {\n          name: 'gasFees',\n          type: 'bytes32',\n        },\n        {\n          name: 'paymasterAndDataHash',\n          type: 'bytes32',\n        },\n      ],\n      [\n        packedOp.sender,\n        packedOp.nonce,\n        keccak256(packedOp.initCode),\n        keccak256(packedOp.callData),\n        packedOp.accountGasLimits,\n        packedOp.preVerificationGas,\n        packedOp.gasFees,\n        keccak256(packedOp.paymasterAndData),\n      ],\n    ),\n  );\n\n  return keccak256(\n    encodeAbiParameters(\n      [\n        {\n          name: 'userOpHash',\n          type: 'bytes32',\n        },\n        {\n          name: 'entryPointAddress',\n          type: 'address',\n        },\n        {\n          name: 'chainId',\n          type: 'uint256',\n        },\n      ],\n      [hash, entryPoint, chainId],\n    ),\n  );\n};\n\nexport const SIGNABLE_USER_OP_TYPED_DATA: TypedData = {\n  PackedUserOperation: [\n    { name: 'sender', type: 'address' },\n    { name: 'nonce', type: 'uint256' },\n    { name: 'initCode', type: 'bytes' },\n    { name: 'callData', type: 'bytes' },\n    { name: 'accountGasLimits', type: 'bytes32' },\n    { name: 'preVerificationGas', type: 'uint256' },\n    { name: 'gasFees', type: 'bytes32' },\n    { name: 'paymasterAndData', type: 'bytes' },\n    { name: 'entryPoint', type: 'address' },\n  ],\n} as const;\n\n/**\n * Signs a user operation using the provided signatory.\n * @param params - The parameters for signing the user operation\n * @param params.signer - The signatory to use for signing\n * @param params.userOp - The user operation to sign\n * @param params.address - The address of the smart account\n * @param params.entryPoint - The entry point contract address\n * @param params.chainId - The chain ID that the entry point is deployed on\n * @param params.name - The name of the domain of the implementation contract\n * @param params.version - The version of the domain of the implementation contract\n * @returns The signature of the user operation\n */\nexport const signUserOperation = async ({\n  signer,\n  userOperation,\n  entryPoint,\n  chainId,\n  name,\n  address,\n  version = '1',\n}: {\n  signer: WalletClient<Transport, Chain, Account>;\n  userOperation: Omit<UserOperationV07, 'signature'>;\n  entryPoint: { address: Address };\n  chainId: number;\n  address: Address;\n  name: 'HybridDeleGator' | 'MultiSigDeleGator';\n  version?: string;\n}) => {\n  const packedUserOp = toPackedUserOperation({\n    ...userOperation,\n    signature: '0x',\n  });\n\n  return signer.signTypedData({\n    account: signer.account,\n    domain: {\n      chainId,\n      name,\n      version,\n      verifyingContract: address,\n    },\n    types: SIGNABLE_USER_OP_TYPED_DATA,\n    primaryType: 'PackedUserOperation',\n    message: { ...packedUserOp, entryPoint: entryPoint.address },\n  });\n};\n","import { parseSignature } from 'webauthn-p256';\nimport {\n  parseAbiParameters,\n  encodeAbiParameters,\n  type Hex,\n  encodePacked,\n  keccak256,\n  concat,\n} from 'viem';\n\nexport const FIELD_MODULUS =\n  115792089210356248762697446949407573529996955224135760342422259061068512044369n;\nexport const MALLEABILITY_THRESHOLD = FIELD_MODULUS / 2n;\n\nexport const SIGNATURE_ABI_PARAMS = parseAbiParameters(\n  'bytes32, uint256, uint256, bytes, bool, string, string, uint256',\n);\n\n/**\n * This function is used to convert the client data returned from the credentials API\n * into a format that can be consumed by the DeleGator contracts.\n * ClientData looks like this:\n * {\n *  \"type\": \"webauthn.create\" | \"webauthn.get\",\n *   \"challenge\": \"{userOpHash}\",\n *   \"origin\": \"{Domain}\",\n *   \"crossOrigin\": boolean\n * }\n * We need the flattend JSON strings before and after the userOpHash/challenge.\n * This function provides those two client data string slices.\n * @param clientDataJson ClientData\n * @returns Returns [clientDataJSONPrefix and clientDataJSONSuffix]\n * ClientDataJSONPrefix contains the client data till the challengeHash\n * ClientDataJSONSuffix contains the client data after the challengeHash.\n */\nexport const splitOnChallenge = (\n  clientDataJson: string,\n): [clientDataJSONPrefix: string, clientDataJSONSuffix: string] => {\n  try {\n    const { challenge } = JSON.parse(clientDataJson);\n    if (challenge === undefined) {\n      throw new Error('No \"challenge\" found in the input string');\n    }\n    return clientDataJson.split(challenge) as [string, string];\n  } catch (error) {\n    throw new Error('No \"challenge\" found in the input string', {\n      cause: error,\n    });\n  }\n};\n\n/**\n * This function returns the index of '\"type\":' in the ClientData\n * @param clientDataJson Stringified ClientDataJSON\n */\nexport const getResponseTypeLocation = (clientDataJson: string): bigint => {\n  try {\n    // Find the index of the `\"type\":` key in the JSON string directly\n    const typeIndex = clientDataJson.indexOf('\"type\":');\n\n    if (typeIndex === -1)\n      throw new Error('No \"type\" found in the input string');\n    // Return the index of the `\"type\":` key\n    return BigInt(typeIndex);\n  } catch (error) {\n    // Handle any errors that occur during the search\n    throw new Error('No \"type\" found in the input string', {\n      cause: error,\n    });\n  }\n};\n\n/**\n * Encodes a signature to a hexadecimal signature that will be accepted\n * by the DeleGator contracts.\n *\n * @param keyId - The key used for the signature, represented as a hexadecimal string.\n * @param signature - The signature to convert, as Hex\n * @param clientData - The client data used in the creation of the signature.\n * @param authenticatorData - The authenticator data used in the creation of the\n * signature, represented as a hexadecimal string.\n * @returns The signature as a valid DeleGator signature encoded as Hexadecimal\n * string.\n */\nexport function encodeDeleGatorSignature(\n  keyId: string,\n  signature: Hex,\n  clientDataJSON: string,\n  authenticatorData: Hex,\n): Hex {\n  const keyIdHash = keccak256(encodePacked(['string'], [keyId]));\n\n  let { r, s } = parseSignature(signature);\n\n  while (s > MALLEABILITY_THRESHOLD) {\n    s = FIELD_MODULUS - s;\n  }\n\n  const [clientDataComponent1, clientDataComponent2] =\n    splitOnChallenge(clientDataJSON);\n\n  const { userVerified } = parseAuthenticatorFlags(authenticatorData);\n\n  const responseTypeLocation = getResponseTypeLocation(clientDataJSON);\n\n  const encodedSignature = encodeAbiParameters(SIGNATURE_ABI_PARAMS, [\n    keyIdHash,\n    r,\n    s,\n    authenticatorData,\n    userVerified,\n    clientDataComponent1,\n    clientDataComponent2,\n    responseTypeLocation,\n  ]);\n  return encodedSignature;\n}\n\n/**\n * Checks if a given string is a valid base64 or base64url encoded string.\n *\n * @param {string} base64 - The string to be checked.\n * @returns {boolean} Returns `true` if the string is a valid base64 or base64url encoded string, `false` otherwise.\n */\nfunction isBase64(base64: string): boolean {\n  const base64Regex =\n    /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}(==)?|[A-Za-z0-9+/]{3}=?|[A-Za-z0-9-_]{4})*(?:[A-Za-z0-9-_]{2}(==)?|[A-Za-z0-9-_]{3}=?)?$/gi;\n\n  return base64Regex.test(base64);\n}\n\nconst AUTHENTICATOR_DATA_FLAGS_OFFSET = 32;\n// We have all of the flag bits defined here for completeness, even though we only extract the userVerified flag.\nenum AUTHENTICATOR_DATA_FLAG_BIT_INDEX {\n  USER_PRESENCE = 0,\n  // reserved for future use: 1,\n  USER_VERIFIED = 2,\n  BACKUP_ELIGIBILITY = 3,\n  BACKUP_STATE = 4,\n  // reserved for future use: 5,\n  ATTESTED_CREDENTIAL_DATA = 6,\n  EXTENSION_DATA = 7,\n}\n\nexport type AuthenticatorFlags = {\n  userVerified: boolean;\n};\n\n/**\n * Parses the authenticator data from a base64 string and returns an\n * `AuthenticatorFlags` containing only the `userVerified` flag.\n *\n * See https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API/Authenticator_data\n *\n * @param {string} authenticatorDataBase64 - The base64 string representation of\n * the authenticator data.\n * @returns {AuthenticatorFlags} An object representing the parsed authenticator\n * flags.\n */\nexport function parseAuthenticatorFlags(\n  authenticatorData: Hex,\n): AuthenticatorFlags {\n  const authenticatorDataBuffer = Buffer.from(\n    authenticatorData.slice(2),\n    'hex',\n  );\n  const flags = authenticatorDataBuffer.readUInt8(\n    AUTHENTICATOR_DATA_FLAGS_OFFSET,\n  );\n\n  // Bit 0 is the least significant bit in the flags byte, so we left shift 0b1 by the bit index\n  const bitMask = 0b1 << AUTHENTICATOR_DATA_FLAG_BIT_INDEX.USER_VERIFIED;\n\n  return {\n    userVerified: (flags & bitMask) !== 0x0,\n  };\n}\n\n/**\n * Creates a dummy signature.\n *\n * This must meet all early-failure conditions of the real signature, but does not need to be a valid signature.\n *\n * See the tests for each of the early-failure conditions.\n *\n * @returns The encoded signature.\n */\nexport const createDummyWebAuthnSignature = (keyId: Hex) => {\n  // https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API/Authenticator_data#data_structure\n  const rpIdHash = keccak256(encodePacked(['string'], ['AuthenticatorData']));\n  const flags = '0x05';\n  const signCount = '0x00000000';\n  const authenticatorData = concat([rpIdHash, flags, signCount]);\n\n  const keyIdHash = keccak256(encodePacked(['string'], [keyId]));\n  const rs =\n    57896044605178124381348723474703786764998477612067880171211129530534256022184n;\n  const userVerification = true;\n  const clientDataPrefix = '{\"type\":\"webauthn.get\",\"challenge\":\"';\n  const clientDataSuffix = '\",\"origin\":\"passkey-domain\",\"crossOrigin\":false}';\n  const responseTypeLocation = 1n;\n\n  const encodedSignature = encodeAbiParameters(SIGNATURE_ABI_PARAMS, [\n    keyIdHash,\n    rs,\n    rs,\n    authenticatorData,\n    userVerification,\n    clientDataPrefix,\n    clientDataSuffix,\n    responseTypeLocation,\n  ]);\n\n  return encodedSignature;\n};\n","import { Address, concat, type Hex } from 'viem';\n\nconst signatureTypes = ['ECDSA'] as const;\n\nexport type SignatureType = (typeof signatureTypes)[number];\n\nexport type PartialSignature = {\n  signer: Address;\n  signature: Hex;\n  type: SignatureType;\n};\n\n/**\n * Aggregates signatures into a single signature as expected by the MultiSig implementation\n * @param signatures - The signatures to aggregate\n * @returns The aggregated signature\n */\nexport const aggregateSignature = ({\n  signatures,\n}: {\n  signatures: PartialSignature[];\n}): Hex => {\n  if (signatures.length === 0) {\n    return '0x';\n  }\n\n  for (const { type } of signatures) {\n    if (!signatureTypes.includes(type)) {\n      throw new Error(`Invalid signature type: ${type}`);\n    }\n  }\n\n  // Sort signatures by signer address as required by MutliSig implementation\n  const sortedSignatures = [...signatures].sort((a, b) =>\n    a.signer.localeCompare(b.signer),\n  );\n\n  // Concatenate all signatures\n  return concat(sortedSignatures.map(({ signature }) => signature));\n};\n"]}