"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _createStarExport(obj) { Object.keys(obj) .filter((key) => key !== "default" && key !== "__esModule") .forEach((key) => { if (exports.hasOwnProperty(key)) { return; } Object.defineProperty(exports, key, {enumerable: true, configurable: true, get: () => obj[key]}); }); } function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } } function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; } var _class; var _class2;// src/index.ts
var _delegationdeployments = require('@metamask/delegation-deployments'); _createStarExport(_delegationdeployments);
var _delegationabis = require('@metamask/delegation-abis'); _createStarExport(_delegationabis);

// src/executions.ts
var _viem = require('viem');
var createExecution = (target = _viem.zeroAddress, value = 0n, callData = "0x") => ({
  target,
  value,
  callData
});
var SINGLE_DEFAULT_MODE = "0x0000000000000000000000000000000000000000000000000000000000000000";
var SINGLE_TRY_MODE = "0x0001000000000000000000000000000000000000000000000000000000000000";
var BATCH_DEFAULT_MODE = "0x0100000000000000000000000000000000000000000000000000000000000000";
var BATCH_TRY_MODE = "0x0101000000000000000000000000000000000000000000000000000000000000";
var EXECUTION_ABI_TYPE_COMPONENTS = [
  { type: "address", name: "target" },
  { type: "uint256", name: "value" },
  { type: "bytes", name: "callData" }
];
var encodeSingleExecution = (execution) => {
  return _viem.encodePacked.call(void 0, 
    ["address", "uint256", "bytes"],
    [execution.target, execution.value, execution.callData]
  );
};
var encodeBatchExecution = (executions) => {
  return _viem.encodeAbiParameters.call(void 0, 
    [
      {
        components: EXECUTION_ABI_TYPE_COMPONENTS,
        name: "executions",
        type: "tuple[]"
      }
    ],
    [executions]
  );
};
var encodeExecutionCalldata = (executions) => {
  if (executions.length == 0) {
    throw new Error(
      `Error while getting the execution calldatas, executions is empty`
    );
  }
  if (executions.length == 1) {
    const execution = executions[0];
    return encodeSingleExecution(execution);
  }
  return encodeBatchExecution(executions);
};
var encodeExecutionCalldatas = (executionsBatch) => {
  if (executionsBatch.length == 0) {
    throw new Error(
      `Error while getting the execution calldatas, executionsBatch is empty`
    );
  }
  return executionsBatch.map(encodeExecutionCalldata);
};

// src/blockchain.ts

var getExplorerAddressLink = (chainId, address) => {
  const prefix = getExplorerLink(chainId);
  return `${prefix}/address/${address}`;
};
var getExplorerTransactionLink = (chainId, hash) => {
  const prefix = getExplorerLink(chainId);
  return `${prefix}/tx/${hash}`;
};
var CHAIN_EXPLORERS = {
  [_delegationdeployments.CHAIN_ID.mainnet]: "https://etherscan.io",
  [_delegationdeployments.CHAIN_ID.optimism]: "https://optimistic.etherscan.io",
  [_delegationdeployments.CHAIN_ID.polygon]: "https://polygonscan.com",
  [_delegationdeployments.CHAIN_ID.base]: "https://basescan.org",
  [_delegationdeployments.CHAIN_ID.arbitrum]: "https://arbiscan.io",
  [_delegationdeployments.CHAIN_ID.linea]: "https://lineascan.build",
  [_delegationdeployments.CHAIN_ID.sepolia]: "https://sepolia.etherscan.io",
  [_delegationdeployments.CHAIN_ID.lineaSepolia]: "https://sepolia.lineascan.build"
};
var getExplorerLink = (chainId) => {
  const url = CHAIN_EXPLORERS[chainId];
  if (!url) {
    throw new Error(`Unsupported chainId: ${chainId}`);
  }
  return url;
};
var shortenHash = (address) => !!address ? address.slice(0, 6) + "..." : "";
var getInfuraRpcUrl = (chainId, apiKey) => {
  if (!apiKey)
    throw new Error("Infura API key is required");
  switch (chainId) {
    case _delegationdeployments.CHAIN_ID.mainnet:
      return `https://mainnet.infura.io/v3/${apiKey}`;
    case _delegationdeployments.CHAIN_ID.optimism:
      return `https://optimism-mainnet.infura.io/v3/${apiKey}`;
    case _delegationdeployments.CHAIN_ID.polygon:
      return `https://polygon-mainnet.infura.io/v3/${apiKey}`;
    case _delegationdeployments.CHAIN_ID.arbitrum:
      return `https://arbitrum-mainnet.infura.io/v3/${apiKey}`;
    case _delegationdeployments.CHAIN_ID.linea:
      return `https://linea-mainnet.infura.io/v3/${apiKey}`;
    case _delegationdeployments.CHAIN_ID.sepolia:
      return `https://sepolia.infura.io/v3/${apiKey}`;
    case _delegationdeployments.CHAIN_ID.lineaSepolia:
      return `https://linea-sepolia.infura.io/v3/${apiKey}`;
    default:
      throw new Error(`Unsupported chainId: ${chainId}`);
  }
};

// src/caveats.ts







var CAVEAT_ABI_TYPE_COMPONENTS = [
  { type: "address", name: "enforcer" },
  { type: "bytes", name: "terms" },
  { type: "bytes", name: "args" }
];
var CAVEAT_TYPEHASH = _viem.keccak256.call(void 0, 
  _viem.toHex.call(void 0, "Caveat(address enforcer,bytes terms)")
);
var getCaveatArrayPacketHash = (input) => {
  let encoded = "0x";
  for (let i = 0; i < input.length; ++i) {
    const caveatPacketHash = getCaveatPacketHash(input[i]);
    encoded = _viem.encodePacked.call(void 0, ["bytes", "bytes32"], [encoded, caveatPacketHash]);
  }
  return _viem.keccak256.call(void 0, encoded);
};
var getCaveatPacketHash = (input) => {
  const encoded = _viem.encodeAbiParameters.call(void 0, 
    _viem.parseAbiParameters.call(void 0, "bytes32, address, bytes32"),
    [CAVEAT_TYPEHASH, input.enforcer, _viem.keccak256.call(void 0, input.terms)]
  );
  return _viem.keccak256.call(void 0, encoded);
};
var createCaveat = (enforcer, terms, args = "0x") => ({
  enforcer,
  terms,
  args
});

// src/constants.ts
var Implementation = /* @__PURE__ */ ((Implementation2) => {
  Implementation2[Implementation2["MultiSig"] = 0] = "MultiSig";
  Implementation2[Implementation2["Hybrid"] = 1] = "Hybrid";
  return Implementation2;
})(Implementation || {});

// src/data.ts

function isEqualHex(a, b) {
  return _viem.isHex.call(void 0, a) && a.toLowerCase() === b.toLowerCase();
}
function deepHexlify(obj) {
  if (typeof obj === "function") {
    return void 0;
  }
  if (obj == null || typeof obj === "string" || typeof obj === "boolean") {
    return obj;
  }
  if (typeof obj === "bigint") {
    return _viem.toHex.call(void 0, obj);
  }
  if (obj._isBigNumber != null || typeof obj !== "object") {
    return _viem.toHex.call(void 0, obj).replace(/^0x0/, "0x");
  }
  if (Array.isArray(obj)) {
    return obj.map((member) => deepHexlify(member));
  }
  return Object.keys(obj).reduce(
    (set, key) => Object.assign(Object.assign({}, set), {
      [key]: deepHexlify(obj[key])
    }),
    {}
  );
}

// src/delegation.ts










// src/caveatBuilder/allowedMethodsBuilder.ts

var allowedMethods = "allowedMethods";
var FUNCTION_SELECTOR_STRING_LENGTH = 10;
var allowedMethodsBuilder = (environment, selectors) => {
  if (selectors.length === 0) {
    throw new Error("Invalid selectors: must provide at least one selector");
  }
  const parsedSelectors = selectors.map(parseSelector);
  const terms = _viem.concat.call(void 0, parsedSelectors);
  const {
    caveatEnforcers: { AllowedMethodsEnforcer: AllowedMethodsEnforcer2 }
  } = environment;
  return {
    enforcer: AllowedMethodsEnforcer2,
    terms,
    args: "0x"
  };
};
function parseSelector(selector) {
  if (_viem.isHex.call(void 0, selector)) {
    if (selector.length !== FUNCTION_SELECTOR_STRING_LENGTH) {
      throw new Error(
        "Invalid selector: must be a 4 byte hex string, abi function signature, or AbiFunction"
      );
    } else {
      return selector;
    }
  }
  try {
    return _viem.toFunctionSelector.call(void 0, selector);
  } catch (rootError) {
    throw new Error(
      "Invalid selector: must be a 4 byte hex string, abi function signature, or AbiFunction",
      { cause: rootError }
    );
  }
}

// src/caveatBuilder/allowedTargetsBuilder.ts

var allowedTargets = "allowedTargets";
var allowedTargetsBuilder = (environment, targets) => {
  if (targets.length === 0) {
    throw new Error(
      "Invalid targets: must provide at least one target address"
    );
  }
  const invalidAddresses = targets.filter(
    (target) => !_viem.isAddress.call(void 0, target, { strict: false })
  );
  if (invalidAddresses.length > 0) {
    throw new Error("Invalid targets: must be valid addresses");
  }
  const terms = _viem.concat.call(void 0, targets);
  const {
    caveatEnforcers: { AllowedTargetsEnforcer: AllowedTargetsEnforcer2 }
  } = environment;
  return {
    enforcer: AllowedTargetsEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/caveatBuilder.ts
var resolveCaveats = (caveats) => {
  if (Array.isArray(caveats)) {
    return caveats;
  }
  return caveats.build();
};
var CaveatBuilder = (_class = class _CaveatBuilder {
  constructor(environment, config = {}, enforcerBuilders = {}, builtCaveats = []) {;_class.prototype.__init.call(this);_class.prototype.__init2.call(this);
    this.environment = environment;
    this.config = config;
    this.enforcerBuilders = enforcerBuilders;
    this.results = builtCaveats;
  }
  __init() {this.results = []}
  __init2() {this.hasBeenBuilt = false}
  /**
   * Extends the CaveatBuilder with a new enforcer function.
   *
   * @template TEnforcerName - The name of the enforcer.
   * @template TFunction - The type of the enforcer function.
   * @param name - The name of the enforcer.
   * @param fn - The enforcer function.
   * @returns The extended CaveatBuilder instance.
   */
  extend(name, fn) {
    return new _CaveatBuilder(
      this.environment,
      this.config,
      { ...this.enforcerBuilders, [name]: fn },
      this.results
    );
  }
  addCaveat(nameOrCaveat, ...args) {
    if (typeof nameOrCaveat === "object") {
      const caveat = {
        args: "0x",
        // defaults to "0x"
        ...nameOrCaveat
      };
      this.results = [...this.results, caveat];
      return this;
    } else {
      const name = nameOrCaveat;
      const func = this.enforcerBuilders[name];
      if (typeof func === "function") {
        const result = func(this.environment, ...args);
        this.results = [...this.results, result];
        return this;
      }
      throw new Error(`Function "${String(name)}" does not exist.`);
    }
  }
  /**
   * Returns the caveats that have been built using this CaveatBuilder.
   *
   * @returns The array of built caveats.
   */
  build() {
    if (this.hasBeenBuilt) {
      throw new Error("This CaveatBuilder has already been built.");
    }
    if (this.results.length === 0 && !this.config.allowEmptyCaveats) {
      throw new Error(
        "No caveats found. If you definitely want to create an empty caveat collection, set `allowEmptyCaveats`."
      );
    }
    this.hasBeenBuilt = true;
    return this.results;
  }
}, _class);

// src/caveatBuilder/deployedBuilder.ts

var deployed = "deployed";
var deployedBuilder = (environment, contractAddress, salt, bytecode) => {
  if (!_viem.isAddress.call(void 0, contractAddress, { strict: false })) {
    throw new Error(
      `Invalid contractAddress: must be a valid Ethereum address`
    );
  }
  if (!_viem.isHex.call(void 0, salt)) {
    throw new Error("Invalid salt: must be a valid hexadecimal string");
  }
  if (!_viem.isHex.call(void 0, bytecode)) {
    throw new Error("Invalid bytecode: must be a valid hexadecimal string");
  }
  const terms = _viem.concat.call(void 0, [contractAddress, _viem.pad.call(void 0, salt, { size: 32 }), bytecode]);
  const {
    caveatEnforcers: { DeployedEnforcer: DeployedEnforcer2 }
  } = environment;
  return {
    enforcer: DeployedEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/allowedCalldataBuilder.ts

var allowedCalldata = "allowedCalldata";
var allowedCalldataBuilder = (environment, startIndex, value) => {
  if (!_viem.isHex.call(void 0, value)) {
    throw new Error("Invalid value: must be a valid hex string");
  }
  if (startIndex < 0) {
    throw new Error("Invalid startIndex: must be zero or positive");
  }
  if (!Number.isInteger(startIndex)) {
    throw new Error("Invalid startIndex: must be a whole number");
  }
  const startIndexHex = _viem.toHex.call(void 0, startIndex, { size: 32 });
  const terms = _viem.concat.call(void 0, [startIndexHex, value]);
  const {
    caveatEnforcers: { AllowedCalldataEnforcer: AllowedCalldataEnforcer2 }
  } = environment;
  return {
    enforcer: AllowedCalldataEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/erc20BalanceChangeBuilder.ts


// src/caveatBuilder/types.ts
var BalanceChangeType = /* @__PURE__ */ ((BalanceChangeType2) => {
  BalanceChangeType2[BalanceChangeType2["Increase"] = 0] = "Increase";
  BalanceChangeType2[BalanceChangeType2["Decrease"] = 1] = "Decrease";
  return BalanceChangeType2;
})(BalanceChangeType || {});

// src/caveatBuilder/erc20BalanceChangeBuilder.ts
var erc20BalanceChange = "erc20BalanceChange";
var erc20BalanceChangeBuilder = (environment, tokenAddress, recipient, balance, changeType) => {
  if (!_viem.isAddress.call(void 0, tokenAddress, { strict: false })) {
    throw new Error("Invalid tokenAddress: must be a valid address");
  }
  if (balance <= 0n) {
    throw new Error("Invalid balance: must be a positive number");
  }
  if (changeType !== 0 /* Increase */ && changeType !== 1 /* Decrease */) {
    throw new Error("Invalid changeType: must be either Increase or Decrease");
  }
  const terms = _viem.encodePacked.call(void 0, 
    ["uint8", "address", "address", "uint256"],
    [changeType, tokenAddress, recipient, balance]
  );
  const {
    caveatEnforcers: { ERC20BalanceChangeEnforcer: ERC20BalanceChangeEnforcer2 }
  } = environment;
  return {
    enforcer: ERC20BalanceChangeEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/valueLteBuilder.ts

var valueLte = "valueLte";
var valueLteBuilder = (environment, maxValue) => {
  if (maxValue < 0n) {
    throw new Error("Invalid maxValue: must be greater than zero");
  }
  const terms = _viem.concat.call(void 0, [_viem.toHex.call(void 0, maxValue, { size: 32 })]);
  const {
    caveatEnforcers: { ValueLteEnforcer: ValueLteEnforcer2 }
  } = environment;
  return {
    enforcer: ValueLteEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/limitedCallsBuilder.ts

var limitedCalls = "limitedCalls";
var limitedCallsBuilder = (environment, limit) => {
  if (!Number.isInteger(limit)) {
    throw new Error("Invalid limit: must be an integer");
  }
  if (limit <= 0) {
    throw new Error("Invalid limit: must be a positive integer");
  }
  const terms = _viem.pad.call(void 0, _viem.toHex.call(void 0, limit), { size: 32 });
  const {
    caveatEnforcers: { LimitedCallsEnforcer: LimitedCallsEnforcer2 }
  } = environment;
  return {
    enforcer: LimitedCallsEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/idBuilder.ts

var id = "id";
var idBuilder = (environment, id2) => {
  if (typeof id2 !== "number") {
    throw new Error("Invalid id: must be a number");
  }
  if (!Number.isInteger(id2)) {
    throw new Error("Invalid id: must be an integer");
  }
  if (id2 >= 2 ** 32) {
    throw new Error("Invalid id: must be 32 bytes or fewer in length");
  }
  const terms = _viem.toHex.call(void 0, id2, { size: 32 });
  const {
    caveatEnforcers: { IdEnforcer: IdEnforcer2 }
  } = environment;
  return {
    enforcer: IdEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/nonceBuilder.ts

var nonce = "nonce";
var MAX_NONCE_STRING_LENGTH = 66;
var nonceBuilder = (environment, nonce2) => {
  if (!nonce2 || nonce2 === "0x") {
    throw new Error("Invalid nonce: must be a non-empty hex string");
  }
  if (!_viem.isHex.call(void 0, nonce2)) {
    throw new Error("Invalid nonce: must be a valid hex string");
  }
  if (nonce2.length > MAX_NONCE_STRING_LENGTH) {
    throw new Error("Invalid nonce: must be 32 bytes or less in length");
  }
  const {
    caveatEnforcers: { NonceEnforcer: NonceEnforcer2 }
  } = environment;
  return {
    enforcer: NonceEnforcer2,
    terms: _viem.pad.call(void 0, nonce2, { size: 32 }),
    args: "0x"
  };
};

// src/caveatBuilder/timestampBuilder.ts


// src/caveatBuilder/shared.ts
var TIMESTAMP_UPPER_BOUND_SECONDS = 253402300799;

// src/caveatBuilder/timestampBuilder.ts
var timestamp = "timestamp";
var timestampBuilder = (environment, timestampAfterThreshold, timestampBeforeThreshold) => {
  if (timestampAfterThreshold < 0) {
    throw new Error(
      "Invalid timestampAfterThreshold: must be zero or positive"
    );
  }
  if (timestampBeforeThreshold < 0) {
    throw new Error(
      "Invalid timestampBeforeThreshold: must be zero or positive"
    );
  }
  if (timestampBeforeThreshold > TIMESTAMP_UPPER_BOUND_SECONDS) {
    throw new Error(
      "Invalid timestampBeforeThreshold: must be less than or equal to 253402300799"
    );
  }
  if (timestampAfterThreshold > TIMESTAMP_UPPER_BOUND_SECONDS) {
    throw new Error(
      "Invalid timestampAfterThreshold: must be less than or equal to 253402300799"
    );
  }
  if (timestampBeforeThreshold !== 0 && timestampAfterThreshold >= timestampBeforeThreshold) {
    throw new Error(
      "Invalid thresholds: timestampBeforeThreshold must be greater than timestampAfterThreshold when both are specified"
    );
  }
  const afterThresholdHex = _viem.toHex.call(void 0, timestampAfterThreshold, { size: 16 });
  const beforeThresholdHex = _viem.toHex.call(void 0, timestampBeforeThreshold, { size: 16 });
  const terms = _viem.concat.call(void 0, [afterThresholdHex, beforeThresholdHex]);
  const {
    caveatEnforcers: { TimestampEnforcer: TimestampEnforcer2 }
  } = environment;
  return {
    enforcer: TimestampEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/blockNumberBuilder.ts

var blockNumber = "blockNumber";
var blockNumberBuilder = (environment, blockAfterThreshold, blockBeforeThreshold) => {
  if (blockAfterThreshold === 0n && blockBeforeThreshold === 0n) {
    throw new Error(
      "Invalid thresholds: At least one of blockAfterThreshold or blockBeforeThreshold must be specified"
    );
  }
  if (blockBeforeThreshold !== 0n && blockAfterThreshold >= blockBeforeThreshold) {
    throw new Error(
      "Invalid thresholds: blockAfterThreshold must be less than blockBeforeThreshold if both are specified"
    );
  }
  const terms = _viem.concat.call(void 0, [
    _viem.toHex.call(void 0, blockAfterThreshold, {
      size: 16
    }),
    _viem.toHex.call(void 0, blockBeforeThreshold, {
      size: 16
    })
  ]);
  const {
    caveatEnforcers: { BlockNumberEnforcer: BlockNumberEnforcer2 }
  } = environment;
  return {
    enforcer: BlockNumberEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/erc20TransferAmountBuilder.ts

var erc20TransferAmount = "erc20TransferAmount";
var erc20TransferAmountBuilder = (environment, tokenAddress, maxAmount) => {
  if (!_viem.isAddress.call(void 0, tokenAddress, { strict: false })) {
    throw new Error("Invalid tokenAddress: must be a valid address");
  }
  if (maxAmount <= 0n) {
    throw new Error("Invalid maxAmount: must be a positive number");
  }
  const terms = _viem.concat.call(void 0, [tokenAddress, _viem.toHex.call(void 0, maxAmount, { size: 32 })]);
  const {
    caveatEnforcers: { ERC20TransferAmountEnforcer: ERC20TransferAmountEnforcer2 }
  } = environment;
  return {
    enforcer: ERC20TransferAmountEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/erc20StreamingBuilder.ts

var erc20Streaming = "erc20Streaming";
var erc20StreamingBuilder = (environment, tokenAddress, initialAmount, maxAmount, amountPerSecond, startTime) => {
  if (!_viem.isAddress.call(void 0, tokenAddress, { strict: false })) {
    throw new Error("Invalid tokenAddress: must be a valid address");
  }
  if (initialAmount < 0n) {
    throw new Error("Invalid initialAmount: must be greater than zero");
  }
  if (maxAmount <= 0n) {
    throw new Error("Invalid maxAmount: must be a positive number");
  }
  if (maxAmount < initialAmount) {
    throw new Error("Invalid maxAmount: must be greater than initialAmount");
  }
  if (amountPerSecond <= 0n) {
    throw new Error("Invalid amountPerSecond: must be a positive number");
  }
  if (startTime <= 0) {
    throw new Error("Invalid startTime: must be a positive number");
  }
  if (startTime > TIMESTAMP_UPPER_BOUND_SECONDS) {
    throw new Error(
      "Invalid startTime: must be less than or equal to 253402300799"
    );
  }
  const terms = _viem.encodePacked.call(void 0, 
    ["address", "uint256", "uint256", "uint256", "uint256"],
    [
      tokenAddress,
      initialAmount,
      maxAmount,
      amountPerSecond,
      BigInt(startTime)
    ]
  );
  const {
    caveatEnforcers: { ERC20StreamingEnforcer: ERC20StreamingEnforcer2 }
  } = environment;
  return {
    enforcer: ERC20StreamingEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/nativeTokenStreamingBuilder.ts

var nativeTokenStreaming = "nativeTokenStreaming";
var nativeTokenStreamingBuilder = (environment, initialAmount, maxAmount, amountPerSecond, startTime) => {
  if (initialAmount < 0n) {
    throw new Error("Invalid initialAmount: must be greater than zero");
  }
  if (maxAmount <= 0n) {
    throw new Error("Invalid maxAmount: must be a positive number");
  }
  if (maxAmount < initialAmount) {
    throw new Error("Invalid maxAmount: must be greater than initialAmount");
  }
  if (amountPerSecond <= 0n) {
    throw new Error("Invalid amountPerSecond: must be a positive number");
  }
  if (startTime <= 0) {
    throw new Error("Invalid startTime: must be a positive number");
  }
  if (startTime > TIMESTAMP_UPPER_BOUND_SECONDS) {
    throw new Error(
      "Invalid startTime: must be less than or equal to 253402300799"
    );
  }
  const terms = _viem.encodePacked.call(void 0, 
    ["uint256", "uint256", "uint256", "uint256"],
    [initialAmount, maxAmount, amountPerSecond, BigInt(startTime)]
  );
  const {
    caveatEnforcers: { NativeTokenStreamingEnforcer: NativeTokenStreamingEnforcer2 }
  } = environment;
  return {
    enforcer: NativeTokenStreamingEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/nativeTokenTransferAmountBuilder.ts

var nativeTokenTransferAmount = "nativeTokenTransferAmount";
var nativeTokenTransferAmountBuilder = (environment, allowance) => {
  if (allowance < 0n) {
    throw new Error("Invalid allowance: must be zero or positive");
  }
  const terms = _viem.encodePacked.call(void 0, ["uint256"], [allowance]);
  const {
    caveatEnforcers: { NativeTokenTransferAmountEnforcer: NativeTokenTransferAmountEnforcer2 }
  } = environment;
  return {
    enforcer: NativeTokenTransferAmountEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/nativeBalanceChangeBuilder.ts

var nativeBalanceChange = "nativeBalanceChange";
var nativeBalanceChangeBuilder = (environment, recipient, balance, changeType) => {
  if (!_viem.isAddress.call(void 0, recipient)) {
    throw new Error("Invalid recipient: must be a valid Address");
  }
  if (balance <= 0n) {
    throw new Error("Invalid balance: must be a positive number");
  }
  if (changeType !== 0 /* Increase */ && changeType !== 1 /* Decrease */) {
    throw new Error("Invalid changeType: must be either Increase or Decrease");
  }
  const terms = _viem.encodePacked.call(void 0, 
    ["uint8", "address", "uint256"],
    [changeType, recipient, balance]
  );
  const {
    caveatEnforcers: { NativeBalanceChangeEnforcer: NativeBalanceChangeEnforcer2 }
  } = environment;
  return {
    enforcer: NativeBalanceChangeEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/redeemerBuilder.ts

var redeemer = "redeemer";
var redeemerBuilder = (environment, redeemers) => {
  if (redeemers.length === 0) {
    throw new Error(
      "Invalid redeemers: must specify at least one redeemer address"
    );
  }
  for (let i = 0; i < redeemers.length; i++) {
    if (!_viem.isAddress.call(void 0, redeemers[i])) {
      throw new Error("Invalid redeemers: must be a valid address");
    }
  }
  const terms = _viem.concat.call(void 0, redeemers);
  const {
    caveatEnforcers: { RedeemerEnforcer: RedeemerEnforcer2 }
  } = environment;
  return {
    enforcer: RedeemerEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/nativeTokenPaymentBuilder.ts

var nativeTokenPayment = "nativeTokenPayment";
var nativeTokenPaymentBuilder = (environment, recipient, amount) => {
  if (amount <= 0n) {
    throw new Error("Invalid amount: must be positive");
  }
  if (!_viem.isAddress.call(void 0, recipient)) {
    throw new Error("Invalid recipient: must be a valid address");
  }
  const terms = _viem.encodePacked.call(void 0, ["address", "uint256"], [recipient, amount]);
  const {
    caveatEnforcers: { NativeTokenPaymentEnforcer: NativeTokenPaymentEnforcer2 }
  } = environment;
  return {
    enforcer: NativeTokenPaymentEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/argsEqualityCheckBuilder.ts

var argsEqualityCheck = "argsEqualityCheck";
var argsEqualityCheckBuilder = (environment, args) => {
  if (!_viem.isHex.call(void 0, args)) {
    throw new Error("Invalid args: must be a valid hex string");
  }
  const terms = args;
  const {
    caveatEnforcers: { ArgsEqualityCheckEnforcer: ArgsEqualityCheckEnforcer2 }
  } = environment;
  return {
    enforcer: ArgsEqualityCheckEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/erc1155BalanceChangeBuilder.ts

var erc1155BalanceChange = "erc1155BalanceChange";
var erc1155BalanceChangeBuilder = (environment, tokenAddress, recipient, tokenId, balance, changeType) => {
  if (!_viem.isAddress.call(void 0, tokenAddress, { strict: false })) {
    throw new Error("Invalid tokenAddress: must be a valid address");
  }
  if (!_viem.isAddress.call(void 0, recipient, { strict: false })) {
    throw new Error("Invalid recipient: must be a valid address");
  }
  if (balance <= 0n) {
    throw new Error("Invalid balance: must be a positive number");
  }
  if (tokenId < 0) {
    throw new Error("Invalid tokenId: must be a non-negative number");
  }
  if (changeType !== 0 /* Increase */ && changeType !== 1 /* Decrease */) {
    throw new Error("Invalid changeType: must be either Increase or Decrease");
  }
  const terms = _viem.encodePacked.call(void 0, 
    ["uint8", "address", "address", "uint256", "uint256"],
    [changeType, tokenAddress, recipient, tokenId, balance]
  );
  const {
    caveatEnforcers: { ERC1155BalanceChangeEnforcer: ERC1155BalanceChangeEnforcer2 }
  } = environment;
  return {
    enforcer: ERC1155BalanceChangeEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/erc721BalanceChangeBuilder.ts

var erc721BalanceChange = "erc721BalanceChange";
var erc721BalanceChangeBuilder = (environment, tokenAddress, recipient, amount, changeType) => {
  if (!_viem.isAddress.call(void 0, tokenAddress, { strict: false })) {
    throw new Error("Invalid tokenAddress: must be a valid address");
  }
  if (!_viem.isAddress.call(void 0, recipient, { strict: false })) {
    throw new Error("Invalid recipient: must be a valid address");
  }
  if (amount <= 0) {
    throw new Error("Invalid balance: must be a positive number");
  }
  if (changeType !== 0 /* Increase */ && changeType !== 1 /* Decrease */) {
    throw new Error("Invalid changeType: must be either Increase or Decrease");
  }
  const terms = _viem.encodePacked.call(void 0, 
    ["uint8", "address", "address", "uint256"],
    [changeType, tokenAddress, recipient, amount]
  );
  const {
    caveatEnforcers: { ERC721BalanceChangeEnforcer: ERC721BalanceChangeEnforcer2 }
  } = environment;
  return {
    enforcer: ERC721BalanceChangeEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/erc721TransferBuilder.ts

var erc721Transfer = "erc721Transfer";
var erc721TransferBuilder = (environment, permittedContract, permittedTokenId) => {
  if (!_viem.isAddress.call(void 0, permittedContract, { strict: false })) {
    throw new Error("Invalid tokenAddress: must be a valid address");
  }
  if (permittedTokenId < 0) {
    throw new Error("Invalid permittedTokenId: must be a non-negative number");
  }
  const terms = _viem.concat.call(void 0, [
    permittedContract,
    _viem.toHex.call(void 0, permittedTokenId, { size: 32 })
  ]);
  const {
    caveatEnforcers: { ERC721TransferEnforcer: ERC721TransferEnforcer2 }
  } = environment;
  return {
    enforcer: ERC721TransferEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/specificActionERC20TransferBatchBuilder.ts

var specificActionERC20TransferBatch = "specificActionERC20TransferBatch";
var specificActionERC20TransferBatchBuilder = (environment, tokenAddress, recipient, amount, firstTarget, firstCalldata) => {
  if (!_viem.isAddress.call(void 0, tokenAddress, { strict: false })) {
    throw new Error("Invalid tokenAddress: must be a valid address");
  }
  if (!_viem.isAddress.call(void 0, recipient, { strict: false })) {
    throw new Error("Invalid recipient: must be a valid address");
  }
  if (!_viem.isAddress.call(void 0, firstTarget, { strict: false })) {
    throw new Error("Invalid firstTarget: must be a valid address");
  }
  if (amount <= 0n) {
    throw new Error("Invalid amount: must be a positive number");
  }
  const terms = _viem.concat.call(void 0, [
    tokenAddress,
    recipient,
    _viem.toHex.call(void 0, amount, { size: 32 }),
    firstTarget,
    firstCalldata
  ]);
  const {
    caveatEnforcers: { SpecificActionERC20TransferBatchEnforcer: SpecificActionERC20TransferBatchEnforcer2 }
  } = environment;
  return {
    enforcer: SpecificActionERC20TransferBatchEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/erc20PeriodTransferBuilder.ts

var erc20PeriodTransfer = "erc20PeriodTransfer";
var erc20PeriodTransferBuilder = (environment, tokenAddress, periodAmount, periodDuration, startDate) => {
  if (!_viem.isAddress.call(void 0, tokenAddress)) {
    throw new Error("Invalid tokenAddress: must be a valid address");
  }
  if (periodAmount <= 0n) {
    throw new Error("Invalid periodAmount: must be a positive number");
  }
  if (periodDuration <= 0) {
    throw new Error("Invalid periodDuration: must be a positive number");
  }
  if (startDate <= 0) {
    throw new Error("Invalid startDate: must be a positive number");
  }
  const terms = _viem.concat.call(void 0, [
    tokenAddress,
    _viem.toHex.call(void 0, periodAmount, { size: 32 }),
    _viem.toHex.call(void 0, periodDuration, { size: 32 }),
    _viem.toHex.call(void 0, startDate, { size: 32 })
  ]);
  return {
    enforcer: environment.caveatEnforcers.ERC20PeriodTransferEnforcer,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/nativeTokenPeriodTransferBuilder.ts

var nativeTokenPeriodTransfer = "nativeTokenPeriodTransfer";
var nativeTokenPeriodTransferBuilder = (environment, periodAmount, periodDuration, startDate) => {
  if (periodAmount <= 0n) {
    throw new Error("Invalid periodAmount: must be a positive number");
  }
  if (periodDuration <= 0) {
    throw new Error("Invalid periodDuration: must be a positive number");
  }
  if (startDate <= 0) {
    throw new Error("Invalid startDate: must be a positive number");
  }
  const terms = _viem.concat.call(void 0, [
    _viem.toHex.call(void 0, periodAmount, { size: 32 }),
    _viem.toHex.call(void 0, periodDuration, { size: 32 }),
    _viem.toHex.call(void 0, startDate, { size: 32 })
  ]);
  const {
    caveatEnforcers: { NativeTokenPeriodTransferEnforcer: NativeTokenPeriodTransferEnforcer2 }
  } = environment;
  return {
    enforcer: NativeTokenPeriodTransferEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/exactCalldataBatchBuilder.ts




var exactCalldataBatch = "exactCalldataBatch";
var exactCalldataBatchBuilder = (environment, executions) => {
  if (executions.length === 0) {
    throw new Error("Invalid executions: array cannot be empty");
  }
  for (const execution of executions) {
    if (!_viem.isAddress.call(void 0, execution.target, { strict: false })) {
      throw new Error("Invalid target: must be a valid address");
    }
    if (execution.value < 0n) {
      throw new Error("Invalid value: must be a non-negative number");
    }
    if (!execution.callData.startsWith("0x")) {
      throw new Error(
        "Invalid callData: must be a hex string starting with 0x"
      );
    }
  }
  const terms = _viem.encodeAbiParameters.call(void 0, 
    [
      {
        type: "tuple[]",
        components: [
          { type: "address", name: "target" },
          { type: "uint256", name: "value" },
          { type: "bytes", name: "callData" }
        ]
      }
    ],
    [executions]
  );
  const {
    caveatEnforcers: { ExactCalldataBatchEnforcer: ExactCalldataBatchEnforcer2 }
  } = environment;
  return {
    enforcer: ExactCalldataBatchEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/exactCalldataBuilder.ts
var exactCalldata = "exactCalldata";
var exactCalldataBuilder = (environment, callData) => {
  if (!callData.startsWith("0x")) {
    throw new Error("Invalid callData: must be a hex string starting with 0x");
  }
  const {
    caveatEnforcers: { ExactCalldataEnforcer: ExactCalldataEnforcer2 }
  } = environment;
  return {
    enforcer: ExactCalldataEnforcer2,
    terms: callData,
    args: "0x"
  };
};

// src/caveatBuilder/exactExecutionBuilder.ts

var exactExecution = "exactExecution";
var exactExecutionBuilder = (environment, execution) => {
  if (!_viem.isAddress.call(void 0, execution.target, { strict: false })) {
    throw new Error("Invalid target: must be a valid address");
  }
  if (execution.value < 0n) {
    throw new Error("Invalid value: must be a non-negative number");
  }
  if (!execution.callData.startsWith("0x")) {
    throw new Error("Invalid callData: must be a hex string starting with 0x");
  }
  const terms = _viem.concat.call(void 0, [
    execution.target,
    _viem.toHex.call(void 0, execution.value, { size: 32 }),
    execution.callData
  ]);
  const {
    caveatEnforcers: { ExactExecutionEnforcer: ExactExecutionEnforcer2 }
  } = environment;
  return {
    enforcer: ExactExecutionEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/exactExecutionBatchBuilder.ts

var exactExecutionBatch = "exactExecutionBatch";
var exactExecutionBatchBuilder = (environment, executions) => {
  if (executions.length === 0) {
    throw new Error("Invalid executions: array cannot be empty");
  }
  for (const execution of executions) {
    if (!_viem.isAddress.call(void 0, execution.target, { strict: false })) {
      throw new Error("Invalid target: must be a valid address");
    }
    if (execution.value < 0n) {
      throw new Error("Invalid value: must be a non-negative number");
    }
    if (!execution.callData.startsWith("0x")) {
      throw new Error(
        "Invalid callData: must be a hex string starting with 0x"
      );
    }
  }
  const terms = _viem.encodeAbiParameters.call(void 0, 
    [
      {
        type: "tuple[]",
        components: [
          { type: "address", name: "target" },
          { type: "uint256", name: "value" },
          { type: "bytes", name: "callData" }
        ]
      }
    ],
    [executions]
  );
  const {
    caveatEnforcers: { ExactExecutionBatchEnforcer: ExactExecutionBatchEnforcer2 }
  } = environment;
  return {
    enforcer: ExactExecutionBatchEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/multiTokenPeriodBuilder.ts

var multiTokenPeriod = "multiTokenPeriod";
var multiTokenPeriodBuilder = (environment, configs) => {
  if (!configs || configs.length === 0) {
    throw new Error("MultiTokenPeriodBuilder: configs array cannot be empty");
  }
  configs.forEach((config) => {
    if (!_viem.isAddress.call(void 0, config.token)) {
      throw new Error(`Invalid token address: ${config.token}`);
    }
    if (config.periodAmount <= 0) {
      throw new Error("Invalid period amount: must be greater than 0");
    }
    if (config.periodDuration <= 0) {
      throw new Error("Invalid period duration: must be greater than 0");
    }
  });
  const termsArray = configs.reduce(
    (acc, { token, periodAmount, periodDuration, startDate }) => [
      ...acc,
      _viem.pad.call(void 0, token, { size: 20 }),
      _viem.toHex.call(void 0, periodAmount, { size: 32 }),
      _viem.toHex.call(void 0, periodDuration, { size: 32 }),
      _viem.toHex.call(void 0, startDate, { size: 32 })
    ],
    []
  );
  const terms = _viem.concat.call(void 0, termsArray);
  const {
    caveatEnforcers: { MultiTokenPeriodEnforcer: MultiTokenPeriodEnforcer2 }
  } = environment;
  return {
    enforcer: MultiTokenPeriodEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/index.ts
var createCaveatBuilder = (environment, config) => {
  const caveatBuilder = new CaveatBuilder(environment, config).extend(allowedMethods, allowedMethodsBuilder).extend(allowedTargets, allowedTargetsBuilder).extend(deployed, deployedBuilder).extend(allowedCalldata, allowedCalldataBuilder).extend(erc20BalanceChange, erc20BalanceChangeBuilder).extend(erc721BalanceChange, erc721BalanceChangeBuilder).extend(erc1155BalanceChange, erc1155BalanceChangeBuilder).extend(valueLte, valueLteBuilder).extend(limitedCalls, limitedCallsBuilder).extend(id, idBuilder).extend(nonce, nonceBuilder).extend(timestamp, timestampBuilder).extend(blockNumber, blockNumberBuilder).extend(erc20TransferAmount, erc20TransferAmountBuilder).extend(erc20Streaming, erc20StreamingBuilder).extend(nativeTokenStreaming, nativeTokenStreamingBuilder).extend(erc721Transfer, erc721TransferBuilder).extend(nativeTokenTransferAmount, nativeTokenTransferAmountBuilder).extend(nativeBalanceChange, nativeBalanceChangeBuilder).extend(redeemer, redeemerBuilder).extend(nativeTokenPayment, nativeTokenPaymentBuilder).extend(argsEqualityCheck, argsEqualityCheckBuilder).extend(
    specificActionERC20TransferBatch,
    specificActionERC20TransferBatchBuilder
  ).extend(erc20PeriodTransfer, erc20PeriodTransferBuilder).extend(nativeTokenPeriodTransfer, nativeTokenPeriodTransferBuilder).extend(exactCalldataBatch, exactCalldataBatchBuilder).extend(exactCalldata, exactCalldataBuilder).extend(exactExecution, exactExecutionBuilder).extend(exactExecutionBatch, exactExecutionBatchBuilder).extend(multiTokenPeriod, multiTokenPeriodBuilder);
  return caveatBuilder;
};

// src/delegation.ts
var toDelegationStruct = (delegation) => {
  const caveats = delegation.caveats.map((caveat) => ({
    enforcer: _viem.getAddress.call(void 0, caveat.enforcer),
    terms: caveat.terms,
    args: caveat.args
  }));
  const salt = delegation.salt === "0x" ? 0n : BigInt(delegation.salt);
  return {
    delegate: _viem.getAddress.call(void 0, delegation.delegate),
    delegator: _viem.getAddress.call(void 0, delegation.delegator),
    authority: delegation.authority === void 0 ? ROOT_AUTHORITY : delegation.authority,
    caveats,
    salt,
    signature: delegation.signature
  };
};
var encodeDelegation = (delegations) => {
  const delegationStructs = delegations.map(toDelegationStruct);
  return _viem.encodeAbiParameters.call(void 0, 
    [
      {
        components: DELEGATION_ABI_TYPE_COMPONENTS,
        name: "delegations",
        type: "tuple[]"
      }
    ],
    [delegationStructs]
  );
};
var encodePermissionContexts = (delegations) => {
  const encodedDelegations = delegations.map(
    (delegationChain) => encodeDelegation(delegationChain)
  );
  return encodedDelegations;
};
var ROOT_AUTHORITY = "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff";
var ANY_BENEFICIARY = "0x0000000000000000000000000000000000000a11";
var DELEGATION_TYPEHASH = _viem.keccak256.call(void 0, 
  _viem.toHex.call(void 0, 
    "Delegation(address delegate,address delegator,bytes32 authority,Caveat[] caveats,uint256 salt)Caveat(address enforcer,bytes terms)"
  )
);
var DELEGATION_ABI_TYPE_COMPONENTS = [
  { type: "address", name: "delegate" },
  { type: "address", name: "delegator" },
  { type: "bytes32", name: "authority" },
  { type: "tuple[]", name: "caveats", components: CAVEAT_ABI_TYPE_COMPONENTS },
  { type: "uint256", name: "salt" },
  { type: "bytes", name: "signature" }
];
var SIGNABLE_DELEGATION_TYPED_DATA = {
  Caveat: [
    { name: "enforcer", type: "address" },
    { name: "terms", type: "bytes" }
  ],
  Delegation: [
    { name: "delegate", type: "address" },
    { name: "delegator", type: "address" },
    { name: "authority", type: "bytes32" },
    { name: "caveats", type: "Caveat[]" },
    { name: "salt", type: "uint256" }
  ]
};
var DELEGATION_ARRAY_ABI_TYPE = {
  type: "tuple[]",
  components: DELEGATION_ABI_TYPE_COMPONENTS
};
var encodeDelegations = (delegations) => _viem.encodeAbiParameters.call(void 0, [DELEGATION_ARRAY_ABI_TYPE], [delegations]);
var prepDelegationHashForPasskeySign = (delegationHash) => {
  return _viem.hashMessage.call(void 0, {
    raw: _viem.toBytes.call(void 0, delegationHash)
  });
};
var getDelegationHashOffchain = (input) => {
  const delegationStruct = toDelegationStruct(input);
  const encoded = _viem.encodeAbiParameters.call(void 0, 
    _viem.parseAbiParameters.call(void 0, "bytes32, address, address, bytes32, bytes32, uint"),
    [
      DELEGATION_TYPEHASH,
      delegationStruct.delegate,
      delegationStruct.delegator,
      delegationStruct.authority,
      getCaveatArrayPacketHash(delegationStruct.caveats),
      delegationStruct.salt
    ]
  );
  return _viem.keccak256.call(void 0, encoded);
};
var resolveAuthority = (parentDelegation) => {
  if (!parentDelegation) {
    return ROOT_AUTHORITY;
  }
  if (typeof parentDelegation === "string") {
    return parentDelegation;
  }
  return getDelegationHashOffchain(parentDelegation);
};
var createDelegation = (options) => {
  return {
    delegate: options.to,
    delegator: options.from,
    authority: resolveAuthority(options.parentDelegation),
    caveats: resolveCaveats(options.caveats),
    salt: "0x",
    signature: "0x"
  };
};
var createOpenDelegation = (options) => {
  return {
    delegate: ANY_BENEFICIARY,
    delegator: options.from,
    authority: resolveAuthority(options.parentDelegation),
    caveats: resolveCaveats(options.caveats),
    salt: "0x",
    signature: "0x"
  };
};
var signDelegation = async ({
  signer,
  delegation,
  delegationManager,
  chainId,
  name = "DelegationManager",
  version = "1"
}) => {
  const delegationStruct = toDelegationStruct({
    ...delegation,
    signature: "0x"
  });
  return signer.signTypedData({
    account: signer.account,
    domain: {
      chainId,
      name,
      version,
      verifyingContract: delegationManager
    },
    types: SIGNABLE_DELEGATION_TYPED_DATA,
    primaryType: "Delegation",
    message: delegationStruct
  });
};

// src/delegatorEnvironment.ts









































// src/write.ts

var deployWithSimpleFactory = async (walletClient, publicClient, simpleFactoryAddress, creationCode, salt) => {
  const { request } = await publicClient.simulateContract({
    account: walletClient.account,
    address: simpleFactoryAddress,
    abi: _delegationabis.SimpleFactory.abi,
    functionName: "deploy",
    args: [creationCode, salt]
  });
  return await walletClient.writeContract(request);
};
var redeemDelegations = async (walletClient, publicClient, delegationManagerAddress, redemptions) => {
  if (redemptions.length === 0) {
    throw new Error(`RedeemDelegations invalid zero redemptions`);
  }
  const permissionContexts = [];
  const executionsBatch = [];
  const executionModes = [];
  redemptions.forEach((redemption) => {
    permissionContexts.push(redemption.permissionContext);
    executionsBatch.push(redemption.executions);
    executionModes.push(redemption.mode);
  });
  const encodedPermissionContexts = encodePermissionContexts(permissionContexts);
  const executionCalldatas = encodeExecutionCalldatas(executionsBatch);
  const { request } = await publicClient.simulateContract({
    account: walletClient.account,
    address: delegationManagerAddress,
    abi: _delegationabis.DelegationManager.abi,
    functionName: "redeemDelegations",
    args: [encodedPermissionContexts, executionModes, executionCalldatas]
  });
  return await walletClient.writeContract(request);
};
async function deployContract(walletClient, publicClient, chain, { bytecode, abi }, args = []) {
  const hash = await walletClient.deployContract({
    abi,
    bytecode,
    args,
    account: walletClient.account,
    chain
  });
  const receipt = await publicClient.waitForTransactionReceipt({
    hash
  });
  const address = (await receipt).contractAddress;
  return { address, hash, receipt };
}

// src/delegatorEnvironment.ts
var PREFERRED_VERSION = "1.3.0";
var contractOverrides = {
  "1.0.0": {},
  "1.1.0": {},
  "1.2.0": {},
  "1.3.0": {}
};
function overrideDeployedEnvironment(chainId, version, environment) {
  contractOverrides[version][chainId] = environment;
}
function getDeleGatorEnvironment(chainId, version = PREFERRED_VERSION) {
  const override = contractOverrides[version][chainId];
  if (override) {
    return override;
  }
  const c = _optionalChain([_delegationdeployments.DELEGATOR_CONTRACTS, 'access', _ => _[version], 'optionalAccess', _2 => _2[chainId]]);
  if (!c) {
    throw new Error(
      `No contracts found for version ${version} chain ${chainId}`
    );
  }
  return getDeleGatorEnvironment_v1(c);
}
function getDeleGatorEnvironment_v1(c) {
  return {
    DelegationManager: c.DelegationManager,
    EntryPoint: c.EntryPoint,
    SimpleFactory: c.SimpleFactory,
    implementations: {
      MultiSigDeleGatorImpl: c.MultiSigDeleGatorImpl,
      HybridDeleGatorImpl: c.HybridDeleGatorImpl
    },
    caveatEnforcers: {
      AllowedCalldataEnforcer: c.AllowedCalldataEnforcer,
      AllowedMethodsEnforcer: c.AllowedMethodsEnforcer,
      AllowedTargetsEnforcer: c.AllowedTargetsEnforcer,
      ArgsEqualityCheckEnforcer: c.ArgsEqualityCheckEnforcer,
      BlockNumberEnforcer: c.BlockNumberEnforcer,
      DeployedEnforcer: c.DeployedEnforcer,
      ERC20BalanceChangeEnforcer: c.ERC20BalanceChangeEnforcer,
      ERC20TransferAmountEnforcer: c.ERC20TransferAmountEnforcer,
      ERC20StreamingEnforcer: c.ERC20StreamingEnforcer,
      ERC721BalanceChangeEnforcer: c.ERC721BalanceChangeEnforcer,
      ERC721TransferEnforcer: c.ERC721TransferEnforcer,
      ERC1155BalanceChangeEnforcer: c.ERC1155BalanceChangeEnforcer,
      IdEnforcer: c.IdEnforcer,
      LimitedCallsEnforcer: c.LimitedCallsEnforcer,
      NonceEnforcer: c.NonceEnforcer,
      TimestampEnforcer: c.TimestampEnforcer,
      ValueLteEnforcer: c.ValueLteEnforcer,
      NativeTokenTransferAmountEnforcer: c.NativeTokenTransferAmountEnforcer,
      NativeBalanceChangeEnforcer: c.NativeBalanceChangeEnforcer,
      NativeTokenStreamingEnforcer: c.NativeTokenStreamingEnforcer,
      NativeTokenPaymentEnforcer: c.NativeTokenPaymentEnforcer,
      OwnershipTransferEnforcer: c.OwnershipTransferEnforcer,
      RedeemerEnforcer: c.RedeemerEnforcer,
      SpecificActionERC20TransferBatchEnforcer: c.SpecificActionERC20TransferBatchEnforcer,
      ERC20PeriodTransferEnforcer: c.ERC20PeriodTransferEnforcer,
      NativeTokenPeriodTransferEnforcer: c.NativeTokenPeriodTransferEnforcer,
      ExactCalldataBatchEnforcer: c.ExactCalldataBatchEnforcer,
      ExactCalldataEnforcer: c.ExactCalldataEnforcer,
      ExactExecutionEnforcer: c.ExactExecutionEnforcer,
      ExactExecutionBatchEnforcer: c.ExactExecutionBatchEnforcer,
      MultiTokenPeriodEnforcer: c.MultiTokenPeriodEnforcer
    }
  };
}
async function deployDeleGatorEnvironment(walletClient, publicClient, chain, deployedContracts = {}) {
  const deployContractCurried = async (name, contract, params = []) => {
    if (deployedContracts[name]) {
      return {
        address: deployedContracts[name],
        name
      };
    }
    const deployedContract = await deployContract(
      walletClient,
      publicClient,
      chain,
      contract,
      params
    );
    deployedContracts[name] = deployedContract.address;
    return { ...deployedContract, name };
  };
  const standaloneContracts = {
    SimpleFactory: _delegationabis.SimpleFactory,
    AllowedCalldataEnforcer: _delegationabis.AllowedCalldataEnforcer,
    AllowedTargetsEnforcer: _delegationabis.AllowedTargetsEnforcer,
    AllowedMethodsEnforcer: _delegationabis.AllowedMethodsEnforcer,
    ArgsEqualityCheckEnforcer: _delegationabis.ArgsEqualityCheckEnforcer,
    DeployedEnforcer: _delegationabis.DeployedEnforcer,
    TimestampEnforcer: _delegationabis.TimestampEnforcer,
    BlockNumberEnforcer: _delegationabis.BlockNumberEnforcer,
    LimitedCallsEnforcer: _delegationabis.LimitedCallsEnforcer,
    ERC20BalanceChangeEnforcer: _delegationabis.ERC20BalanceChangeEnforcer,
    ERC20TransferAmountEnforcer: _delegationabis.ERC20TransferAmountEnforcer,
    ERC20StreamingEnforcer: _delegationabis.ERC20StreamingEnforcer,
    ERC721BalanceChangeEnforcer: _delegationabis.ERC721BalanceChangeEnforcer,
    ERC721TransferEnforcer: _delegationabis.ERC721TransferEnforcer,
    ERC1155BalanceChangeEnforcer: _delegationabis.ERC1155BalanceChangeEnforcer,
    IdEnforcer: _delegationabis.IdEnforcer,
    NonceEnforcer: _delegationabis.NonceEnforcer,
    ValueLteEnforcer: _delegationabis.ValueLteEnforcer,
    NativeTokenTransferAmountEnforcer: _delegationabis.NativeTokenTransferAmountEnforcer,
    NativeBalanceChangeEnforcer: _delegationabis.NativeBalanceChangeEnforcer,
    NativeTokenStreamingEnforcer: _delegationabis.NativeTokenStreamingEnforcer,
    OwnershipTransferEnforcer: _delegationabis.OwnershipTransferEnforcer,
    RedeemerEnforcer: _delegationabis.RedeemerEnforcer,
    SpecificActionERC20TransferBatchEnforcer: _delegationabis.SpecificActionERC20TransferBatchEnforcer,
    ERC20PeriodTransferEnforcer: _delegationabis.ERC20PeriodTransferEnforcer,
    NativeTokenPeriodTransferEnforcer: _delegationabis.NativeTokenPeriodTransferEnforcer,
    ExactCalldataBatchEnforcer: _delegationabis.ExactCalldataBatchEnforcer,
    ExactCalldataEnforcer: _delegationabis.ExactCalldataEnforcer,
    ExactExecutionEnforcer: _delegationabis.ExactExecutionEnforcer,
    ExactExecutionBatchEnforcer: _delegationabis.ExactExecutionBatchEnforcer,
    MultiTokenPeriodEnforcer: _delegationabis.MultiTokenPeriodEnforcer
  };
  for (const [name, contract] of Object.entries(standaloneContracts)) {
    await deployContractCurried(name, contract);
  }
  const delegationManager = await deployContractCurried(
    "DelegationManager",
    _delegationabis.DelegationManager,
    [_optionalChain([walletClient, 'access', _3 => _3.account, 'optionalAccess', _4 => _4.address])]
  );
  await deployContractCurried(
    "NativeTokenPaymentEnforcer",
    _delegationabis.NativeTokenPaymentEnforcer,
    [delegationManager.address, deployedContracts["ArgsEqualityCheckEnforcer"]]
  );
  const entryPoint = await deployContractCurried("EntryPoint", _delegationabis.EntryPoint);
  const { address: sclRIP7212 } = await deployContract(
    walletClient,
    publicClient,
    chain,
    _delegationabis.SCL_RIP7212,
    []
  );
  const hybridDeleGatorWithLinkedLibrary = {
    ..._delegationabis.HybridDeleGator,
    bytecode: _delegationabis.HybridDeleGator.bytecode.replace(
      /__\$b8f96b288d4d0429e38b8ed50fd423070f\$__/g,
      sclRIP7212.slice(2)
    )
  };
  await deployContractCurried(
    "HybridDeleGatorImpl",
    hybridDeleGatorWithLinkedLibrary,
    [delegationManager.address, entryPoint.address]
  );
  await deployContractCurried("MultiSigDeleGatorImpl", _delegationabis.MultiSigDeleGator, [
    delegationManager.address,
    entryPoint.address
  ]);
  return getDeleGatorEnvironment_v1(deployedContracts);
}

// src/rpcError.ts
var RpcError = (_class2 = class _RpcError extends Error {
  
  
  static __initStatic() {this.INVALID_PARAMETERS = -32602}
  static __initStatic2() {this.INTERNAL_ERROR = -32603}
  static __initStatic3() {this.METHOD_NOT_SUPPORTED = -32601}
  // implementation-defined server-error
  static __initStatic4() {this.CONNECTION_CLOSED = -32001}
  static from(error) {
    if (error instanceof _RpcError) {
      return error;
    }
    const errorMessage = error instanceof Error ? error.message : error;
    return new _RpcError(errorMessage, _RpcError.INTERNAL_ERROR);
  }
  toJSONRPCError() {
    const { message, code, data } = this;
    return {
      message,
      code,
      data
    };
  }
  constructor(message, code, data) {
    super(message);
    Object.setPrototypeOf(this, _RpcError.prototype);
    this.code = code;
    this.data = data;
  }
}, _class2.__initStatic(), _class2.__initStatic2(), _class2.__initStatic3(), _class2.__initStatic4(), _class2);

// src/userOp.ts

var _accountabstraction = require('viem/account-abstraction');
var createRawUserOp = (sender, nonce2, callData, signature = "0x", options) => ({
  sender,
  nonce: nonce2,
  callData,
  factory: _optionalChain([options, 'optionalAccess', _5 => _5.factory]),
  factoryData: _optionalChain([options, 'optionalAccess', _6 => _6.factoryData]),
  callGasLimit: _nullishCoalesce(_optionalChain([options, 'optionalAccess', _7 => _7.callGasLimit]), () => ( 0n)),
  verificationGasLimit: _nullishCoalesce(_optionalChain([options, 'optionalAccess', _8 => _8.verificationGasLimit]), () => ( 0n)),
  preVerificationGas: _nullishCoalesce(_optionalChain([options, 'optionalAccess', _9 => _9.preVerificationGas]), () => ( 0n)),
  maxFeePerGas: _nullishCoalesce(_optionalChain([options, 'optionalAccess', _10 => _10.maxFeePerGas]), () => ( 0n)),
  maxPriorityFeePerGas: _nullishCoalesce(_optionalChain([options, 'optionalAccess', _11 => _11.maxPriorityFeePerGas]), () => ( 0n)),
  paymaster: _optionalChain([options, 'optionalAccess', _12 => _12.paymaster]),
  paymasterVerificationGasLimit: _optionalChain([options, 'optionalAccess', _13 => _13.paymasterVerificationGasLimit]),
  paymasterPostOpGasLimit: _optionalChain([options, 'optionalAccess', _14 => _14.paymasterPostOpGasLimit]),
  paymasterData: _optionalChain([options, 'optionalAccess', _15 => _15.paymasterData]),
  signature
});
var getSalt = (salt) => {
  if (!salt) {
    salt = "0x0";
  }
  return salt;
};
var getPaymasterAndData = (userOp) => {
  let paymasterAndData;
  if (userOp.paymaster) {
    paymasterAndData = _viem.concat.call(void 0, [
      userOp.paymaster,
      _viem.pad.call(void 0, _viem.toHex.call(void 0, userOp.paymasterVerificationGasLimit || 0n), {
        size: 16
      }),
      _viem.pad.call(void 0, _viem.toHex.call(void 0, userOp.paymasterPostOpGasLimit || 0n), {
        size: 16
      }),
      userOp.paymasterData || "0x"
    ]);
  } else {
    paymasterAndData = "0x";
  }
  return paymasterAndData;
};
var getInitCode = (userOp) => {
  return userOp.factory ? _viem.concat.call(void 0, [userOp.factory, _nullishCoalesce(userOp.factoryData, () => ( "0x"))]) : "0x";
};
var getAccountGasLimits = (userOp) => {
  return _viem.concat.call(void 0, [
    _viem.pad.call(void 0, _viem.toHex.call(void 0, userOp.verificationGasLimit), {
      size: 16
    }),
    _viem.pad.call(void 0, _viem.toHex.call(void 0, userOp.callGasLimit), { size: 16 })
  ]);
};
var getGasFees = (userOp) => {
  return _viem.concat.call(void 0, [
    _viem.pad.call(void 0, _viem.toHex.call(void 0, userOp.maxPriorityFeePerGas), {
      size: 16
    }),
    _viem.pad.call(void 0, _viem.toHex.call(void 0, userOp.maxFeePerGas), { size: 16 })
  ]);
};
var packUserOp = (userOp) => {
  const packedOp = {
    sender: userOp.sender,
    nonce: BigInt(userOp.nonce),
    initCode: getInitCode(userOp),
    callData: userOp.callData,
    accountGasLimits: getAccountGasLimits(userOp),
    preVerificationGas: BigInt(userOp.preVerificationGas),
    gasFees: getGasFees(userOp),
    paymasterAndData: getPaymasterAndData(userOp),
    signature: userOp.signature
  };
  return packedOp;
};
var createUserOpHashV07 = (packedOp, entryPoint, chainId) => {
  const hash = _viem.keccak256.call(void 0, 
    _viem.encodeAbiParameters.call(void 0, 
      [
        {
          name: "sender",
          type: "address"
        },
        {
          name: "nonce",
          type: "uint256"
        },
        {
          name: "initCodeHash",
          type: "bytes32"
        },
        {
          name: "callDataHash",
          type: "bytes32"
        },
        {
          name: "accountGasLimits",
          type: "bytes32"
        },
        {
          name: "preVerificationGas",
          type: "uint256"
        },
        {
          name: "gasFees",
          type: "bytes32"
        },
        {
          name: "paymasterAndDataHash",
          type: "bytes32"
        }
      ],
      [
        packedOp.sender,
        packedOp.nonce,
        _viem.keccak256.call(void 0, packedOp.initCode),
        _viem.keccak256.call(void 0, packedOp.callData),
        packedOp.accountGasLimits,
        packedOp.preVerificationGas,
        packedOp.gasFees,
        _viem.keccak256.call(void 0, packedOp.paymasterAndData)
      ]
    )
  );
  return _viem.keccak256.call(void 0, 
    _viem.encodeAbiParameters.call(void 0, 
      [
        {
          name: "userOpHash",
          type: "bytes32"
        },
        {
          name: "entryPointAddress",
          type: "address"
        },
        {
          name: "chainId",
          type: "uint256"
        }
      ],
      [hash, entryPoint, chainId]
    )
  );
};
var SIGNABLE_USER_OP_TYPED_DATA = {
  PackedUserOperation: [
    { name: "sender", type: "address" },
    { name: "nonce", type: "uint256" },
    { name: "initCode", type: "bytes" },
    { name: "callData", type: "bytes" },
    { name: "accountGasLimits", type: "bytes32" },
    { name: "preVerificationGas", type: "uint256" },
    { name: "gasFees", type: "bytes32" },
    { name: "paymasterAndData", type: "bytes" },
    { name: "entryPoint", type: "address" }
  ]
};
var signUserOperation = async ({
  signer,
  userOperation,
  entryPoint,
  chainId,
  name,
  address,
  version = "1"
}) => {
  const packedUserOp = _accountabstraction.toPackedUserOperation.call(void 0, {
    ...userOperation,
    signature: "0x"
  });
  return signer.signTypedData({
    account: signer.account,
    domain: {
      chainId,
      name,
      version,
      verifyingContract: address
    },
    types: SIGNABLE_USER_OP_TYPED_DATA,
    primaryType: "PackedUserOperation",
    message: { ...packedUserOp, entryPoint: entryPoint.address }
  });
};

// src/webAuthn.ts
var _webauthnp256 = require('webauthn-p256');







var FIELD_MODULUS = 115792089210356248762697446949407573529996955224135760342422259061068512044369n;
var MALLEABILITY_THRESHOLD = FIELD_MODULUS / 2n;
var SIGNATURE_ABI_PARAMS = _viem.parseAbiParameters.call(void 0, 
  "bytes32, uint256, uint256, bytes, bool, string, string, uint256"
);
var splitOnChallenge = (clientDataJson) => {
  try {
    const { challenge } = JSON.parse(clientDataJson);
    if (challenge === void 0) {
      throw new Error('No "challenge" found in the input string');
    }
    return clientDataJson.split(challenge);
  } catch (error) {
    throw new Error('No "challenge" found in the input string', {
      cause: error
    });
  }
};
var getResponseTypeLocation = (clientDataJson) => {
  try {
    const typeIndex = clientDataJson.indexOf('"type":');
    if (typeIndex === -1)
      throw new Error('No "type" found in the input string');
    return BigInt(typeIndex);
  } catch (error) {
    throw new Error('No "type" found in the input string', {
      cause: error
    });
  }
};
function encodeDeleGatorSignature(keyId, signature, clientDataJSON, authenticatorData) {
  const keyIdHash = _viem.keccak256.call(void 0, _viem.encodePacked.call(void 0, ["string"], [keyId]));
  let { r, s } = _webauthnp256.parseSignature.call(void 0, signature);
  while (s > MALLEABILITY_THRESHOLD) {
    s = FIELD_MODULUS - s;
  }
  const [clientDataComponent1, clientDataComponent2] = splitOnChallenge(clientDataJSON);
  const { userVerified } = parseAuthenticatorFlags(authenticatorData);
  const responseTypeLocation = getResponseTypeLocation(clientDataJSON);
  const encodedSignature = _viem.encodeAbiParameters.call(void 0, SIGNATURE_ABI_PARAMS, [
    keyIdHash,
    r,
    s,
    authenticatorData,
    userVerified,
    clientDataComponent1,
    clientDataComponent2,
    responseTypeLocation
  ]);
  return encodedSignature;
}
var AUTHENTICATOR_DATA_FLAGS_OFFSET = 32;
function parseAuthenticatorFlags(authenticatorData) {
  const authenticatorDataBuffer = Buffer.from(
    authenticatorData.slice(2),
    "hex"
  );
  const flags = authenticatorDataBuffer.readUInt8(
    AUTHENTICATOR_DATA_FLAGS_OFFSET
  );
  const bitMask = 1 << 2 /* USER_VERIFIED */;
  return {
    userVerified: (flags & bitMask) !== 0
  };
}
var createDummyWebAuthnSignature = (keyId) => {
  const rpIdHash = _viem.keccak256.call(void 0, _viem.encodePacked.call(void 0, ["string"], ["AuthenticatorData"]));
  const flags = "0x05";
  const signCount = "0x00000000";
  const authenticatorData = _viem.concat.call(void 0, [rpIdHash, flags, signCount]);
  const keyIdHash = _viem.keccak256.call(void 0, _viem.encodePacked.call(void 0, ["string"], [keyId]));
  const rs = 57896044605178124381348723474703786764998477612067880171211129530534256022184n;
  const userVerification = true;
  const clientDataPrefix = '{"type":"webauthn.get","challenge":"';
  const clientDataSuffix = '","origin":"passkey-domain","crossOrigin":false}';
  const responseTypeLocation = 1n;
  const encodedSignature = _viem.encodeAbiParameters.call(void 0, SIGNATURE_ABI_PARAMS, [
    keyIdHash,
    rs,
    rs,
    authenticatorData,
    userVerification,
    clientDataPrefix,
    clientDataSuffix,
    responseTypeLocation
  ]);
  return encodedSignature;
};

// src/signatures.ts

var signatureTypes = ["ECDSA"];
var aggregateSignature = ({
  signatures
}) => {
  if (signatures.length === 0) {
    return "0x";
  }
  for (const { type } of signatures) {
    if (!signatureTypes.includes(type)) {
      throw new Error(`Invalid signature type: ${type}`);
    }
  }
  const sortedSignatures = [...signatures].sort(
    (a, b) => a.signer.localeCompare(b.signer)
  );
  return _viem.concat.call(void 0, sortedSignatures.map(({ signature }) => signature));
};










































































exports.ANY_BENEFICIARY = ANY_BENEFICIARY; exports.BATCH_DEFAULT_MODE = BATCH_DEFAULT_MODE; exports.BATCH_TRY_MODE = BATCH_TRY_MODE; exports.BalanceChangeType = BalanceChangeType; exports.CAVEAT_ABI_TYPE_COMPONENTS = CAVEAT_ABI_TYPE_COMPONENTS; exports.CAVEAT_TYPEHASH = CAVEAT_TYPEHASH; exports.CaveatBuilder = CaveatBuilder; exports.DELEGATION_ABI_TYPE_COMPONENTS = DELEGATION_ABI_TYPE_COMPONENTS; exports.DELEGATION_ARRAY_ABI_TYPE = DELEGATION_ARRAY_ABI_TYPE; exports.DELEGATION_TYPEHASH = DELEGATION_TYPEHASH; exports.EXECUTION_ABI_TYPE_COMPONENTS = EXECUTION_ABI_TYPE_COMPONENTS; exports.FIELD_MODULUS = FIELD_MODULUS; exports.Implementation = Implementation; exports.MALLEABILITY_THRESHOLD = MALLEABILITY_THRESHOLD; exports.PREFERRED_VERSION = PREFERRED_VERSION; exports.ROOT_AUTHORITY = ROOT_AUTHORITY; exports.RpcError = RpcError; exports.SIGNABLE_DELEGATION_TYPED_DATA = SIGNABLE_DELEGATION_TYPED_DATA; exports.SIGNABLE_USER_OP_TYPED_DATA = SIGNABLE_USER_OP_TYPED_DATA; exports.SIGNATURE_ABI_PARAMS = SIGNATURE_ABI_PARAMS; exports.SINGLE_DEFAULT_MODE = SINGLE_DEFAULT_MODE; exports.SINGLE_TRY_MODE = SINGLE_TRY_MODE; exports.aggregateSignature = aggregateSignature; exports.createCaveat = createCaveat; exports.createCaveatBuilder = createCaveatBuilder; exports.createDelegation = createDelegation; exports.createDummyWebAuthnSignature = createDummyWebAuthnSignature; exports.createExecution = createExecution; exports.createOpenDelegation = createOpenDelegation; exports.createRawUserOp = createRawUserOp; exports.createUserOpHashV07 = createUserOpHashV07; exports.deepHexlify = deepHexlify; exports.deployContract = deployContract; exports.deployDeleGatorEnvironment = deployDeleGatorEnvironment; exports.deployWithSimpleFactory = deployWithSimpleFactory; exports.encodeBatchExecution = encodeBatchExecution; exports.encodeDeleGatorSignature = encodeDeleGatorSignature; exports.encodeDelegation = encodeDelegation; exports.encodeDelegations = encodeDelegations; exports.encodeExecutionCalldata = encodeExecutionCalldata; exports.encodeExecutionCalldatas = encodeExecutionCalldatas; exports.encodePermissionContexts = encodePermissionContexts; exports.encodeSingleExecution = encodeSingleExecution; exports.erc1155BalanceChange = erc1155BalanceChange; exports.erc721BalanceChange = erc721BalanceChange; exports.getAccountGasLimits = getAccountGasLimits; exports.getCaveatArrayPacketHash = getCaveatArrayPacketHash; exports.getCaveatPacketHash = getCaveatPacketHash; exports.getDeleGatorEnvironment = getDeleGatorEnvironment; exports.getDeleGatorEnvironment_v1 = getDeleGatorEnvironment_v1; exports.getDelegationHashOffchain = getDelegationHashOffchain; exports.getExplorerAddressLink = getExplorerAddressLink; exports.getExplorerTransactionLink = getExplorerTransactionLink; exports.getGasFees = getGasFees; exports.getInfuraRpcUrl = getInfuraRpcUrl; exports.getInitCode = getInitCode; exports.getPaymasterAndData = getPaymasterAndData; exports.getResponseTypeLocation = getResponseTypeLocation; exports.getSalt = getSalt; exports.isEqualHex = isEqualHex; exports.nativeBalanceChange = nativeBalanceChange; exports.overrideDeployedEnvironment = overrideDeployedEnvironment; exports.packUserOp = packUserOp; exports.parseAuthenticatorFlags = parseAuthenticatorFlags; exports.prepDelegationHashForPasskeySign = prepDelegationHashForPasskeySign; exports.redeemDelegations = redeemDelegations; exports.resolveAuthority = resolveAuthority; exports.resolveCaveats = resolveCaveats; exports.shortenHash = shortenHash; exports.signDelegation = signDelegation; exports.signUserOperation = signUserOperation; exports.splitOnChallenge = splitOnChallenge; exports.toDelegationStruct = toDelegationStruct;
//# sourceMappingURL=index.js.map