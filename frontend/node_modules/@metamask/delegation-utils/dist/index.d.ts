export * from '@metamask/delegation-deployments';
export * from '@metamask/delegation-abis';
import * as viem from 'viem';
import { Hex, AbiFunction, TypedData, AbiParameter, WalletClient, Transport, Chain, Account, Address, Abi, TypedDataDefinition, PublicClient } from 'viem';

type ExecutionStruct = {
    target: Hex;
    value: bigint;
    callData: Hex;
};
declare const createExecution: (target?: Hex, value?: bigint, callData?: Hex) => ExecutionStruct;
declare const SINGLE_DEFAULT_MODE = "0x0000000000000000000000000000000000000000000000000000000000000000";
declare const SINGLE_TRY_MODE = "0x0001000000000000000000000000000000000000000000000000000000000000";
declare const BATCH_DEFAULT_MODE = "0x0100000000000000000000000000000000000000000000000000000000000000";
declare const BATCH_TRY_MODE = "0x0101000000000000000000000000000000000000000000000000000000000000";
type ExecutionMode = typeof SINGLE_DEFAULT_MODE | typeof SINGLE_TRY_MODE | typeof BATCH_DEFAULT_MODE | typeof BATCH_TRY_MODE;
declare const EXECUTION_ABI_TYPE_COMPONENTS: {
    type: string;
    name: string;
}[];
declare const encodeSingleExecution: (execution: ExecutionStruct) => Hex;
declare const encodeBatchExecution: (executions: ExecutionStruct[]) => Hex;
declare const encodeExecutionCalldata: (executions: ExecutionStruct[]) => Hex;
declare const encodeExecutionCalldatas: (executionsBatch: ExecutionStruct[][]) => Hex[];

declare const getExplorerAddressLink: (chainId: number, address: string) => string;
declare const getExplorerTransactionLink: (chainId: number, hash: string) => string;
declare const shortenHash: (address: string | undefined) => string;
declare const getInfuraRpcUrl: (chainId: number, apiKey?: string) => string;

declare const CAVEAT_ABI_TYPE_COMPONENTS: {
    type: string;
    name: string;
}[];
type Caveat = {
    enforcer: Hex;
    terms: Hex;
    args: Hex;
};
declare const CAVEAT_TYPEHASH: Hex;
declare const getCaveatArrayPacketHash: (input: Caveat[]) => Hex;
declare const getCaveatPacketHash: (input: Caveat) => Hex;
declare const createCaveat: (enforcer: Hex, terms: Hex, args?: Hex) => Caveat;

declare enum Implementation {
    MultiSig = 0,
    Hybrid = 1
}

declare function isEqualHex(a: Hex, b: Hex): boolean;
declare function deepHexlify(obj: any): any;

type TokenPeriodConfig = {
    token: Hex;
    periodAmount: bigint;
    periodDuration: number;
    startDate: number;
};

type MethodSelector = Hex | string | AbiFunction;

type Caveats = CaveatBuilder | Caveat[];
type CaveatWithOptionalArgs = Omit<Caveat, 'args'> & {
    args?: Caveat['args'];
};
declare const resolveCaveats: (caveats: Caveats) => Caveat[];
type RemoveFirst<T extends any[]> = T extends [any, ...infer Rest] ? Rest : never;
type CaveatBuilderMap = {
    [key: string]: (environment: DeleGatorEnvironment, ...args: [...any]) => Caveat;
};
type CaveatBuilderConfig = {
    allowEmptyCaveats?: boolean;
};
declare class CaveatBuilder<TCaveatBuilderMap extends CaveatBuilderMap = {}> {
    private readonly environment;
    private readonly config;
    private readonly enforcerBuilders;
    private results;
    private hasBeenBuilt;
    constructor(environment: DeleGatorEnvironment, config?: CaveatBuilderConfig, enforcerBuilders?: TCaveatBuilderMap, builtCaveats?: Caveat[]);
    extend<TEnforcerName extends string, TFunction extends (environment: DeleGatorEnvironment, ...args: [...any]) => Caveat>(name: TEnforcerName, fn: TFunction): CaveatBuilder<TCaveatBuilderMap & Record<TEnforcerName, TFunction>>;
    addCaveat(caveat: CaveatWithOptionalArgs): CaveatBuilder<TCaveatBuilderMap>;
    addCaveat<TEnforcerName extends keyof TCaveatBuilderMap>(name: TEnforcerName, ...args: RemoveFirst<Parameters<TCaveatBuilderMap[TEnforcerName]>>): CaveatBuilder<TCaveatBuilderMap>;
    build(): Caveat[];
}

declare enum BalanceChangeType {
    Increase = 0,
    Decrease = 1
}

declare const nativeBalanceChange = "nativeBalanceChange";

declare const erc721BalanceChange = "erc721BalanceChange";

declare const erc1155BalanceChange = "erc1155BalanceChange";

declare const createCaveatBuilder: (environment: DeleGatorEnvironment, config?: CaveatBuilderConfig) => CaveatBuilder<Record<"allowedMethods", (environment: DeleGatorEnvironment, selectors: MethodSelector[]) => Caveat> & Record<"allowedTargets", (environment: DeleGatorEnvironment, targets: `0x${string}`[]) => Caveat> & Record<"deployed", (environment: DeleGatorEnvironment, contractAddress: `0x${string}`, salt: `0x${string}`, bytecode: `0x${string}`) => Caveat> & Record<"allowedCalldata", (environment: DeleGatorEnvironment, startIndex: number, value: `0x${string}`) => Caveat> & Record<"erc20BalanceChange", (environment: DeleGatorEnvironment, tokenAddress: `0x${string}`, recipient: `0x${string}`, balance: bigint, changeType: BalanceChangeType) => Caveat> & Record<"erc721BalanceChange", (environment: DeleGatorEnvironment, tokenAddress: `0x${string}`, recipient: `0x${string}`, amount: bigint, changeType: BalanceChangeType) => Caveat> & Record<"erc1155BalanceChange", (environment: DeleGatorEnvironment, tokenAddress: `0x${string}`, recipient: `0x${string}`, tokenId: bigint, balance: bigint, changeType: BalanceChangeType) => Caveat> & Record<"valueLte", (environment: DeleGatorEnvironment, maxValue: bigint) => Caveat> & Record<"limitedCalls", (environment: DeleGatorEnvironment, limit: number) => Caveat> & Record<"id", (environment: DeleGatorEnvironment, id: number) => Caveat> & Record<"nonce", (environment: DeleGatorEnvironment, nonce: `0x${string}`) => Caveat> & Record<"timestamp", (environment: DeleGatorEnvironment, timestampAfterThreshold: number, timestampBeforeThreshold: number) => Caveat> & Record<"blockNumber", (environment: DeleGatorEnvironment, blockAfterThreshold: bigint, blockBeforeThreshold: bigint) => Caveat> & Record<"erc20TransferAmount", (environment: DeleGatorEnvironment, tokenAddress: `0x${string}`, maxAmount: bigint) => Caveat> & Record<"erc20Streaming", (environment: DeleGatorEnvironment, tokenAddress: `0x${string}`, initialAmount: bigint, maxAmount: bigint, amountPerSecond: bigint, startTime: number) => Caveat> & Record<"nativeTokenStreaming", (environment: DeleGatorEnvironment, initialAmount: bigint, maxAmount: bigint, amountPerSecond: bigint, startTime: number) => Caveat> & Record<"erc721Transfer", (environment: DeleGatorEnvironment, permittedContract: `0x${string}`, permittedTokenId: bigint) => Caveat> & Record<"nativeTokenTransferAmount", (environment: DeleGatorEnvironment, allowance: bigint) => Caveat> & Record<"nativeBalanceChange", (environment: DeleGatorEnvironment, recipient: `0x${string}`, balance: bigint, changeType: BalanceChangeType) => Caveat> & Record<"redeemer", (environment: DeleGatorEnvironment, redeemers: `0x${string}`[]) => Caveat> & Record<"nativeTokenPayment", (environment: DeleGatorEnvironment, recipient: `0x${string}`, amount: bigint) => Caveat> & Record<"argsEqualityCheck", (environment: DeleGatorEnvironment, args: `0x${string}`) => Caveat> & Record<"specificActionERC20TransferBatch", (environment: DeleGatorEnvironment, tokenAddress: `0x${string}`, recipient: `0x${string}`, amount: bigint, firstTarget: `0x${string}`, firstCalldata: `0x${string}`) => Caveat> & Record<"erc20PeriodTransfer", (environment: DeleGatorEnvironment, tokenAddress: `0x${string}`, periodAmount: bigint, periodDuration: number, startDate: number) => Caveat> & Record<"nativeTokenPeriodTransfer", (environment: DeleGatorEnvironment, periodAmount: bigint, periodDuration: number, startDate: number) => Caveat> & Record<"exactCalldataBatch", (environment: DeleGatorEnvironment, executions: ExecutionStruct[]) => Caveat> & Record<"exactCalldata", (environment: DeleGatorEnvironment, callData: `0x${string}`) => Caveat> & Record<"exactExecution", (environment: DeleGatorEnvironment, execution: ExecutionStruct) => Caveat> & Record<"exactExecutionBatch", (environment: DeleGatorEnvironment, executions: ExecutionStruct[]) => Caveat> & Record<"multiTokenPeriod", (environment: DeleGatorEnvironment, configs: TokenPeriodConfig[]) => Caveat>>;
type CoreCaveatBuilder = ReturnType<typeof createCaveatBuilder>;

declare const toDelegationStruct: (delegation: Delegation) => DelegationStruct;
type Delegation = {
    delegate: Hex;
    delegator: Hex;
    authority: Hex;
    caveats: Caveat[];
    salt: Hex;
    signature: Hex;
};
type DelegationStruct = Omit<Delegation, 'salt'> & {
    salt: bigint;
};
declare const encodeDelegation: (delegations: Delegation[]) => `0x${string}`;
declare const encodePermissionContexts: (delegations: Delegation[][]) => `0x${string}`[];
declare const ROOT_AUTHORITY = "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff";
declare const ANY_BENEFICIARY = "0x0000000000000000000000000000000000000a11";
declare const DELEGATION_TYPEHASH: `0x${string}`;
declare const DELEGATION_ABI_TYPE_COMPONENTS: ({
    type: string;
    name: string;
    components?: undefined;
} | {
    type: string;
    name: string;
    components: {
        type: string;
        name: string;
    }[];
})[];
declare const SIGNABLE_DELEGATION_TYPED_DATA: TypedData;
declare const DELEGATION_ARRAY_ABI_TYPE: AbiParameter;
declare const encodeDelegations: (delegations: Delegation[]) => `0x${string}`;
declare const prepDelegationHashForPasskeySign: (delegationHash: Hex) => `0x${string}`;
declare const getDelegationHashOffchain: (input: Delegation) => Hex;
type BaseCreateDelegationOptions = {
    from: Hex;
    caveats: Caveats;
    parentDelegation?: Delegation | Hex;
};
type CreateDelegationOptions = BaseCreateDelegationOptions & {
    to: Hex;
};
type CreateOpenDelegationOptions = BaseCreateDelegationOptions;
declare const resolveAuthority: (parentDelegation?: Delegation | Hex) => Hex;
declare const createDelegation: (options: CreateDelegationOptions) => Delegation;
declare const createOpenDelegation: (options: CreateOpenDelegationOptions) => Delegation;
declare const signDelegation: ({ signer, delegation, delegationManager, chainId, name, version, }: {
    signer: WalletClient<Transport, Chain, Account>;
    delegation: Omit<Delegation, 'signature'>;
    delegationManager: Address;
    chainId: number;
    name?: string | undefined;
    version?: string | undefined;
}) => Promise<`0x${string}`>;

type UserOperationV07Hexlify = {
    sender: Hex;
    nonce: Hex;
    factory?: Hex;
    factoryData?: Hex;
    callData: Hex;
    callGasLimit: Hex;
    verificationGasLimit: Hex;
    preVerificationGas: Hex;
    maxFeePerGas: Hex;
    maxPriorityFeePerGas: Hex;
    paymaster?: Hex;
    paymasterVerificationGasLimit?: Hex;
    paymasterPostOpGasLimit?: Hex;
    paymasterData?: Hex;
    signature: Hex;
};
type UserOperationV07 = {
    sender: Hex;
    nonce: bigint;
    factory?: Hex;
    factoryData?: Hex;
    callData: Hex;
    callGasLimit: bigint;
    verificationGasLimit: bigint;
    preVerificationGas: bigint;
    maxFeePerGas: bigint;
    maxPriorityFeePerGas: bigint;
    paymaster?: Hex;
    paymasterVerificationGasLimit?: bigint;
    paymasterPostOpGasLimit?: bigint;
    paymasterData?: Hex;
    signature: Hex;
};
declare const createRawUserOp: (sender: Hex, nonce: bigint, callData: Hex, signature?: Hex, options?: OptionalUserOpProps) => UserOperationV07;
declare const getSalt: (salt?: Hex) => `0x${string}`;
declare const getPaymasterAndData: (userOp: UserOperationV07) => Hex;
declare const getInitCode: (userOp: UserOperationV07) => Hex;
declare const getAccountGasLimits: (userOp: UserOperationV07) => Hex;
declare const getGasFees: (userOp: UserOperationV07) => Hex;
declare const packUserOp: (userOp: UserOperationV07) => PackedUserOperationStruct;
declare const createUserOpHashV07: (packedOp: PackedUserOperationStruct, entryPoint: Hex, chainId: bigint) => `0x${string}`;
declare const SIGNABLE_USER_OP_TYPED_DATA: TypedData;
declare const signUserOperation: ({ signer, userOperation, entryPoint, chainId, name, address, version, }: {
    signer: WalletClient<Transport, Chain, Account>;
    userOperation: Omit<UserOperationV07, 'signature'>;
    entryPoint: {
        address: Address;
    };
    chainId: number;
    address: Address;
    name: 'HybridDeleGator' | 'MultiSigDeleGator';
    version?: string | undefined;
}) => Promise<`0x${string}`>;

type Optional<T, K extends keyof T> = Omit<T, K> & Partial<T>;
type ContractMetaData = {
    bytecode: Hex;
    abi: Abi;
};
type DeleGatorEnvironment = {
    DelegationManager: Hex;
    EntryPoint: Hex;
    SimpleFactory: Hex;
    implementations: {
        [implementation: string]: Hex;
    };
    caveatEnforcers: {
        [enforcer: string]: Hex;
    };
};
type UnsignedDelegation = Omit<Delegation, 'signature'>;
type PackedUserOperationStruct = {
    sender: Hex;
    nonce: bigint;
    initCode: Hex;
    callData: Hex;
    accountGasLimits: Hex;
    preVerificationGas: bigint;
    gasFees: Hex;
    paymasterAndData: Hex;
    signature: Hex;
};
type GasDelegationStruct = {
    delegate: Hex;
    delegator: Hex;
    authority: Hex;
    allowList: Hex[];
    limitCount: bigint;
    limitCost: bigint;
    salt: bigint;
    signer: Hex;
    signature: Hex;
};
type EIP712DomainStruct = {
    name: string;
    version: string;
    chainId: bigint;
    verifyingContract: Hex;
};
type DelegationRedeemConfig = {
    delegationHash?: Hex;
    delegationChain?: Delegation[];
};
type OptionalUserOpConfig = Omit<OptionalUserOpProps, 'factory' | 'factoryData'>;
type OptionalUserOpProps = {
    factory?: Hex;
    factoryData?: Hex;
    callGasLimit?: bigint;
    verificationGasLimit?: bigint;
    preVerificationGas?: bigint;
    maxFeePerGas?: bigint;
    maxPriorityFeePerGas?: bigint;
    paymaster?: Hex;
    paymasterVerificationGasLimit?: bigint;
    paymasterPostOpGasLimit?: bigint;
    paymasterData?: Hex;
};
type OptionalGasDelegationConfig = {
    salt?: Hex;
    allowList?: Hex[];
    authority?: Hex;
    signer?: Hex;
};
type MultiSigDeleGatorDeployParams = [signers: Hex[], threshold: bigint];
type HybridDeleGatorDeployParams = [
    owner: Hex,
    keyIds: string[],
    xValues: bigint[],
    yValues: bigint[]
];
type UserOperationGasEstimate = {
    preVerificationGas: bigint;
    verificationGas: bigint;
    validAfter: bigint;
    validUntil: bigint;
    callGasLimit: bigint;
};
type ExtendedUserOpStruct = UserOperationV07 & {
    entryPoint: Hex;
    blockNumber: any;
    blockHash: Hex;
    transactionHash: Hex;
};
type PaymasterFeeData = {
    feeBase: bigint;
    feeCap: bigint;
    systemFee: bigint;
};
type Redemption = {
    permissionContext: Delegation[];
    executions: ExecutionStruct[];
    mode: ExecutionMode;
};
type DelegatorTypedData = TypedData | Record<string, unknown>;
type DelegatorPrimaryType = keyof DelegatorTypedData | 'EIP712Domain';
type DelegatorTypedDataDefinition = TypedDataDefinition<DelegatorTypedData, DelegatorPrimaryType>;

type SupportedVersion = '1.0.0' | '1.1.0' | '1.2.0' | '1.3.0';
declare const PREFERRED_VERSION: SupportedVersion;
declare function overrideDeployedEnvironment(chainId: number, version: SupportedVersion, environment: DeleGatorEnvironment): void;
declare function getDeleGatorEnvironment(chainId: number, version?: SupportedVersion): DeleGatorEnvironment;
declare function getDeleGatorEnvironment_v1(c: {
    [contract: string]: Hex;
}): DeleGatorEnvironment;
type DeployedContract = {
    name: string;
    address: string;
};
declare function deployDeleGatorEnvironment(walletClient: WalletClient, publicClient: PublicClient, chain: Chain, deployedContracts?: {
    [contract: string]: Hex;
}): Promise<DeleGatorEnvironment>;

type JSONRPCError = {
    message: string;
    code: number;
    data?: any;
};
declare class RpcError extends Error {
    readonly code: number;
    readonly data?: object;
    static INVALID_PARAMETERS: number;
    static INTERNAL_ERROR: number;
    static METHOD_NOT_SUPPORTED: number;
    static CONNECTION_CLOSED: number;
    static from(error: RpcError | Error | string): RpcError;
    toJSONRPCError(): JSONRPCError;
    constructor(message: string, code: number, data?: object);
}

declare const FIELD_MODULUS = 115792089210356248762697446949407573529996955224135760342422259061068512044369n;
declare const MALLEABILITY_THRESHOLD: bigint;
declare const SIGNATURE_ABI_PARAMS: readonly [{
    readonly type: "bytes32";
}, {
    readonly type: "uint256";
}, {
    readonly type: "uint256";
}, {
    readonly type: "bytes";
}, {
    readonly type: "bool";
}, {
    readonly type: "string";
}, {
    readonly type: "string";
}, {
    readonly type: "uint256";
}];
declare const splitOnChallenge: (clientDataJson: string) => [clientDataJSONPrefix: string, clientDataJSONSuffix: string];
declare const getResponseTypeLocation: (clientDataJson: string) => bigint;
declare function encodeDeleGatorSignature(keyId: string, signature: Hex, clientDataJSON: string, authenticatorData: Hex): Hex;
type AuthenticatorFlags = {
    userVerified: boolean;
};
declare function parseAuthenticatorFlags(authenticatorData: Hex): AuthenticatorFlags;
declare const createDummyWebAuthnSignature: (keyId: Hex) => `0x${string}`;

declare const deployWithSimpleFactory: (walletClient: WalletClient, publicClient: PublicClient, simpleFactoryAddress: Address, creationCode: Hex, salt: Hex) => Promise<`0x${string}`>;
declare const redeemDelegations: (walletClient: WalletClient, publicClient: PublicClient, delegationManagerAddress: Address, redemptions: Redemption[]) => Promise<`0x${string}`>;
declare function deployContract(walletClient: WalletClient, publicClient: PublicClient, chain: Chain, { bytecode, abi }: ContractMetaData, args?: any[]): Promise<{
    address: `0x${string}`;
    hash: `0x${string}`;
    receipt: viem.TransactionReceipt;
}>;

declare const signatureTypes: readonly ["ECDSA"];
type SignatureType = (typeof signatureTypes)[number];
type PartialSignature = {
    signer: Address;
    signature: Hex;
    type: SignatureType;
};
declare const aggregateSignature: ({ signatures, }: {
    signatures: PartialSignature[];
}) => Hex;

export { ANY_BENEFICIARY, AuthenticatorFlags, BATCH_DEFAULT_MODE, BATCH_TRY_MODE, BalanceChangeType, CAVEAT_ABI_TYPE_COMPONENTS, CAVEAT_TYPEHASH, Caveat, CaveatBuilder, CaveatBuilderConfig, Caveats, ContractMetaData, CoreCaveatBuilder, CreateDelegationOptions, CreateOpenDelegationOptions, DELEGATION_ABI_TYPE_COMPONENTS, DELEGATION_ARRAY_ABI_TYPE, DELEGATION_TYPEHASH, DeleGatorEnvironment, Delegation, DelegationRedeemConfig, DelegationStruct, DelegatorPrimaryType, DelegatorTypedData, DelegatorTypedDataDefinition, DeployedContract, EIP712DomainStruct, EXECUTION_ABI_TYPE_COMPONENTS, ExecutionMode, ExecutionStruct, ExtendedUserOpStruct, FIELD_MODULUS, GasDelegationStruct, HybridDeleGatorDeployParams, Implementation, JSONRPCError, MALLEABILITY_THRESHOLD, MultiSigDeleGatorDeployParams, Optional, OptionalGasDelegationConfig, OptionalUserOpConfig, OptionalUserOpProps, PREFERRED_VERSION, PackedUserOperationStruct, PartialSignature, PaymasterFeeData, ROOT_AUTHORITY, Redemption, RpcError, SIGNABLE_DELEGATION_TYPED_DATA, SIGNABLE_USER_OP_TYPED_DATA, SIGNATURE_ABI_PARAMS, SINGLE_DEFAULT_MODE, SINGLE_TRY_MODE, UnsignedDelegation, UserOperationGasEstimate, UserOperationV07, UserOperationV07Hexlify, aggregateSignature, createCaveat, createCaveatBuilder, createDelegation, createDummyWebAuthnSignature, createExecution, createOpenDelegation, createRawUserOp, createUserOpHashV07, deepHexlify, deployContract, deployDeleGatorEnvironment, deployWithSimpleFactory, encodeBatchExecution, encodeDeleGatorSignature, encodeDelegation, encodeDelegations, encodeExecutionCalldata, encodeExecutionCalldatas, encodePermissionContexts, encodeSingleExecution, erc1155BalanceChange, erc721BalanceChange, getAccountGasLimits, getCaveatArrayPacketHash, getCaveatPacketHash, getDeleGatorEnvironment, getDeleGatorEnvironment_v1, getDelegationHashOffchain, getExplorerAddressLink, getExplorerTransactionLink, getGasFees, getInfuraRpcUrl, getInitCode, getPaymasterAndData, getResponseTypeLocation, getSalt, isEqualHex, nativeBalanceChange, overrideDeployedEnvironment, packUserOp, parseAuthenticatorFlags, prepDelegationHashForPasskeySign, redeemDelegations, resolveAuthority, resolveCaveats, shortenHash, signDelegation, signUserOperation, splitOnChallenge, toDelegationStruct };
