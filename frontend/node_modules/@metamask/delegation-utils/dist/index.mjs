// src/index.ts
export * from "@metamask/delegation-deployments";
export * from "@metamask/delegation-abis";

// src/executions.ts
import { encodeAbiParameters, encodePacked, zeroAddress } from "viem";
var createExecution = (target = zeroAddress, value = 0n, callData = "0x") => ({
  target,
  value,
  callData
});
var SINGLE_DEFAULT_MODE = "0x0000000000000000000000000000000000000000000000000000000000000000";
var SINGLE_TRY_MODE = "0x0001000000000000000000000000000000000000000000000000000000000000";
var BATCH_DEFAULT_MODE = "0x0100000000000000000000000000000000000000000000000000000000000000";
var BATCH_TRY_MODE = "0x0101000000000000000000000000000000000000000000000000000000000000";
var EXECUTION_ABI_TYPE_COMPONENTS = [
  { type: "address", name: "target" },
  { type: "uint256", name: "value" },
  { type: "bytes", name: "callData" }
];
var encodeSingleExecution = (execution) => {
  return encodePacked(
    ["address", "uint256", "bytes"],
    [execution.target, execution.value, execution.callData]
  );
};
var encodeBatchExecution = (executions) => {
  return encodeAbiParameters(
    [
      {
        components: EXECUTION_ABI_TYPE_COMPONENTS,
        name: "executions",
        type: "tuple[]"
      }
    ],
    [executions]
  );
};
var encodeExecutionCalldata = (executions) => {
  if (executions.length == 0) {
    throw new Error(
      `Error while getting the execution calldatas, executions is empty`
    );
  }
  if (executions.length == 1) {
    const execution = executions[0];
    return encodeSingleExecution(execution);
  }
  return encodeBatchExecution(executions);
};
var encodeExecutionCalldatas = (executionsBatch) => {
  if (executionsBatch.length == 0) {
    throw new Error(
      `Error while getting the execution calldatas, executionsBatch is empty`
    );
  }
  return executionsBatch.map(encodeExecutionCalldata);
};

// src/blockchain.ts
import { CHAIN_ID } from "@metamask/delegation-deployments";
var getExplorerAddressLink = (chainId, address) => {
  const prefix = getExplorerLink(chainId);
  return `${prefix}/address/${address}`;
};
var getExplorerTransactionLink = (chainId, hash) => {
  const prefix = getExplorerLink(chainId);
  return `${prefix}/tx/${hash}`;
};
var CHAIN_EXPLORERS = {
  [CHAIN_ID.mainnet]: "https://etherscan.io",
  [CHAIN_ID.optimism]: "https://optimistic.etherscan.io",
  [CHAIN_ID.polygon]: "https://polygonscan.com",
  [CHAIN_ID.base]: "https://basescan.org",
  [CHAIN_ID.arbitrum]: "https://arbiscan.io",
  [CHAIN_ID.linea]: "https://lineascan.build",
  [CHAIN_ID.sepolia]: "https://sepolia.etherscan.io",
  [CHAIN_ID.lineaSepolia]: "https://sepolia.lineascan.build"
};
var getExplorerLink = (chainId) => {
  const url = CHAIN_EXPLORERS[chainId];
  if (!url) {
    throw new Error(`Unsupported chainId: ${chainId}`);
  }
  return url;
};
var shortenHash = (address) => !!address ? address.slice(0, 6) + "..." : "";
var getInfuraRpcUrl = (chainId, apiKey) => {
  if (!apiKey)
    throw new Error("Infura API key is required");
  switch (chainId) {
    case CHAIN_ID.mainnet:
      return `https://mainnet.infura.io/v3/${apiKey}`;
    case CHAIN_ID.optimism:
      return `https://optimism-mainnet.infura.io/v3/${apiKey}`;
    case CHAIN_ID.polygon:
      return `https://polygon-mainnet.infura.io/v3/${apiKey}`;
    case CHAIN_ID.arbitrum:
      return `https://arbitrum-mainnet.infura.io/v3/${apiKey}`;
    case CHAIN_ID.linea:
      return `https://linea-mainnet.infura.io/v3/${apiKey}`;
    case CHAIN_ID.sepolia:
      return `https://sepolia.infura.io/v3/${apiKey}`;
    case CHAIN_ID.lineaSepolia:
      return `https://linea-sepolia.infura.io/v3/${apiKey}`;
    default:
      throw new Error(`Unsupported chainId: ${chainId}`);
  }
};

// src/caveats.ts
import {
  encodePacked as encodePacked2,
  encodeAbiParameters as encodeAbiParameters2,
  parseAbiParameters,
  keccak256,
  toHex
} from "viem";
var CAVEAT_ABI_TYPE_COMPONENTS = [
  { type: "address", name: "enforcer" },
  { type: "bytes", name: "terms" },
  { type: "bytes", name: "args" }
];
var CAVEAT_TYPEHASH = keccak256(
  toHex("Caveat(address enforcer,bytes terms)")
);
var getCaveatArrayPacketHash = (input) => {
  let encoded = "0x";
  for (let i = 0; i < input.length; ++i) {
    const caveatPacketHash = getCaveatPacketHash(input[i]);
    encoded = encodePacked2(["bytes", "bytes32"], [encoded, caveatPacketHash]);
  }
  return keccak256(encoded);
};
var getCaveatPacketHash = (input) => {
  const encoded = encodeAbiParameters2(
    parseAbiParameters("bytes32, address, bytes32"),
    [CAVEAT_TYPEHASH, input.enforcer, keccak256(input.terms)]
  );
  return keccak256(encoded);
};
var createCaveat = (enforcer, terms, args = "0x") => ({
  enforcer,
  terms,
  args
});

// src/constants.ts
var Implementation = /* @__PURE__ */ ((Implementation2) => {
  Implementation2[Implementation2["MultiSig"] = 0] = "MultiSig";
  Implementation2[Implementation2["Hybrid"] = 1] = "Hybrid";
  return Implementation2;
})(Implementation || {});

// src/data.ts
import { isHex, toHex as toHex2 } from "viem";
function isEqualHex(a, b) {
  return isHex(a) && a.toLowerCase() === b.toLowerCase();
}
function deepHexlify(obj) {
  if (typeof obj === "function") {
    return void 0;
  }
  if (obj == null || typeof obj === "string" || typeof obj === "boolean") {
    return obj;
  }
  if (typeof obj === "bigint") {
    return toHex2(obj);
  }
  if (obj._isBigNumber != null || typeof obj !== "object") {
    return toHex2(obj).replace(/^0x0/, "0x");
  }
  if (Array.isArray(obj)) {
    return obj.map((member) => deepHexlify(member));
  }
  return Object.keys(obj).reduce(
    (set, key) => Object.assign(Object.assign({}, set), {
      [key]: deepHexlify(obj[key])
    }),
    {}
  );
}

// src/delegation.ts
import {
  encodeAbiParameters as encodeAbiParameters5,
  parseAbiParameters as parseAbiParameters3,
  keccak256 as keccak2562,
  hashMessage,
  toBytes,
  toHex as toHex18,
  getAddress
} from "viem";

// src/caveatBuilder/allowedMethodsBuilder.ts
import { isHex as isHex2, concat, toFunctionSelector } from "viem";
var allowedMethods = "allowedMethods";
var FUNCTION_SELECTOR_STRING_LENGTH = 10;
var allowedMethodsBuilder = (environment, selectors) => {
  if (selectors.length === 0) {
    throw new Error("Invalid selectors: must provide at least one selector");
  }
  const parsedSelectors = selectors.map(parseSelector);
  const terms = concat(parsedSelectors);
  const {
    caveatEnforcers: { AllowedMethodsEnforcer: AllowedMethodsEnforcer2 }
  } = environment;
  return {
    enforcer: AllowedMethodsEnforcer2,
    terms,
    args: "0x"
  };
};
function parseSelector(selector) {
  if (isHex2(selector)) {
    if (selector.length !== FUNCTION_SELECTOR_STRING_LENGTH) {
      throw new Error(
        "Invalid selector: must be a 4 byte hex string, abi function signature, or AbiFunction"
      );
    } else {
      return selector;
    }
  }
  try {
    return toFunctionSelector(selector);
  } catch (rootError) {
    throw new Error(
      "Invalid selector: must be a 4 byte hex string, abi function signature, or AbiFunction",
      { cause: rootError }
    );
  }
}

// src/caveatBuilder/allowedTargetsBuilder.ts
import { concat as concat2, isAddress } from "viem";
var allowedTargets = "allowedTargets";
var allowedTargetsBuilder = (environment, targets) => {
  if (targets.length === 0) {
    throw new Error(
      "Invalid targets: must provide at least one target address"
    );
  }
  const invalidAddresses = targets.filter(
    (target) => !isAddress(target, { strict: false })
  );
  if (invalidAddresses.length > 0) {
    throw new Error("Invalid targets: must be valid addresses");
  }
  const terms = concat2(targets);
  const {
    caveatEnforcers: { AllowedTargetsEnforcer: AllowedTargetsEnforcer2 }
  } = environment;
  return {
    enforcer: AllowedTargetsEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/caveatBuilder.ts
var resolveCaveats = (caveats) => {
  if (Array.isArray(caveats)) {
    return caveats;
  }
  return caveats.build();
};
var CaveatBuilder = class _CaveatBuilder {
  constructor(environment, config = {}, enforcerBuilders = {}, builtCaveats = []) {
    this.environment = environment;
    this.config = config;
    this.enforcerBuilders = enforcerBuilders;
    this.results = builtCaveats;
  }
  results = [];
  hasBeenBuilt = false;
  /**
   * Extends the CaveatBuilder with a new enforcer function.
   *
   * @template TEnforcerName - The name of the enforcer.
   * @template TFunction - The type of the enforcer function.
   * @param name - The name of the enforcer.
   * @param fn - The enforcer function.
   * @returns The extended CaveatBuilder instance.
   */
  extend(name, fn) {
    return new _CaveatBuilder(
      this.environment,
      this.config,
      { ...this.enforcerBuilders, [name]: fn },
      this.results
    );
  }
  addCaveat(nameOrCaveat, ...args) {
    if (typeof nameOrCaveat === "object") {
      const caveat = {
        args: "0x",
        // defaults to "0x"
        ...nameOrCaveat
      };
      this.results = [...this.results, caveat];
      return this;
    } else {
      const name = nameOrCaveat;
      const func = this.enforcerBuilders[name];
      if (typeof func === "function") {
        const result = func(this.environment, ...args);
        this.results = [...this.results, result];
        return this;
      }
      throw new Error(`Function "${String(name)}" does not exist.`);
    }
  }
  /**
   * Returns the caveats that have been built using this CaveatBuilder.
   *
   * @returns The array of built caveats.
   */
  build() {
    if (this.hasBeenBuilt) {
      throw new Error("This CaveatBuilder has already been built.");
    }
    if (this.results.length === 0 && !this.config.allowEmptyCaveats) {
      throw new Error(
        "No caveats found. If you definitely want to create an empty caveat collection, set `allowEmptyCaveats`."
      );
    }
    this.hasBeenBuilt = true;
    return this.results;
  }
};

// src/caveatBuilder/deployedBuilder.ts
import { concat as concat3, isAddress as isAddress2, isHex as isHex3, pad } from "viem";
var deployed = "deployed";
var deployedBuilder = (environment, contractAddress, salt, bytecode) => {
  if (!isAddress2(contractAddress, { strict: false })) {
    throw new Error(
      `Invalid contractAddress: must be a valid Ethereum address`
    );
  }
  if (!isHex3(salt)) {
    throw new Error("Invalid salt: must be a valid hexadecimal string");
  }
  if (!isHex3(bytecode)) {
    throw new Error("Invalid bytecode: must be a valid hexadecimal string");
  }
  const terms = concat3([contractAddress, pad(salt, { size: 32 }), bytecode]);
  const {
    caveatEnforcers: { DeployedEnforcer: DeployedEnforcer2 }
  } = environment;
  return {
    enforcer: DeployedEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/allowedCalldataBuilder.ts
import { concat as concat4, isHex as isHex4, toHex as toHex3 } from "viem";
var allowedCalldata = "allowedCalldata";
var allowedCalldataBuilder = (environment, startIndex, value) => {
  if (!isHex4(value)) {
    throw new Error("Invalid value: must be a valid hex string");
  }
  if (startIndex < 0) {
    throw new Error("Invalid startIndex: must be zero or positive");
  }
  if (!Number.isInteger(startIndex)) {
    throw new Error("Invalid startIndex: must be a whole number");
  }
  const startIndexHex = toHex3(startIndex, { size: 32 });
  const terms = concat4([startIndexHex, value]);
  const {
    caveatEnforcers: { AllowedCalldataEnforcer: AllowedCalldataEnforcer2 }
  } = environment;
  return {
    enforcer: AllowedCalldataEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/erc20BalanceChangeBuilder.ts
import { isAddress as isAddress3, encodePacked as encodePacked3 } from "viem";

// src/caveatBuilder/types.ts
var BalanceChangeType = /* @__PURE__ */ ((BalanceChangeType2) => {
  BalanceChangeType2[BalanceChangeType2["Increase"] = 0] = "Increase";
  BalanceChangeType2[BalanceChangeType2["Decrease"] = 1] = "Decrease";
  return BalanceChangeType2;
})(BalanceChangeType || {});

// src/caveatBuilder/erc20BalanceChangeBuilder.ts
var erc20BalanceChange = "erc20BalanceChange";
var erc20BalanceChangeBuilder = (environment, tokenAddress, recipient, balance, changeType) => {
  if (!isAddress3(tokenAddress, { strict: false })) {
    throw new Error("Invalid tokenAddress: must be a valid address");
  }
  if (balance <= 0n) {
    throw new Error("Invalid balance: must be a positive number");
  }
  if (changeType !== 0 /* Increase */ && changeType !== 1 /* Decrease */) {
    throw new Error("Invalid changeType: must be either Increase or Decrease");
  }
  const terms = encodePacked3(
    ["uint8", "address", "address", "uint256"],
    [changeType, tokenAddress, recipient, balance]
  );
  const {
    caveatEnforcers: { ERC20BalanceChangeEnforcer: ERC20BalanceChangeEnforcer2 }
  } = environment;
  return {
    enforcer: ERC20BalanceChangeEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/valueLteBuilder.ts
import { concat as concat5, toHex as toHex4 } from "viem";
var valueLte = "valueLte";
var valueLteBuilder = (environment, maxValue) => {
  if (maxValue < 0n) {
    throw new Error("Invalid maxValue: must be greater than zero");
  }
  const terms = concat5([toHex4(maxValue, { size: 32 })]);
  const {
    caveatEnforcers: { ValueLteEnforcer: ValueLteEnforcer2 }
  } = environment;
  return {
    enforcer: ValueLteEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/limitedCallsBuilder.ts
import { toHex as toHex5, pad as pad2 } from "viem";
var limitedCalls = "limitedCalls";
var limitedCallsBuilder = (environment, limit) => {
  if (!Number.isInteger(limit)) {
    throw new Error("Invalid limit: must be an integer");
  }
  if (limit <= 0) {
    throw new Error("Invalid limit: must be a positive integer");
  }
  const terms = pad2(toHex5(limit), { size: 32 });
  const {
    caveatEnforcers: { LimitedCallsEnforcer: LimitedCallsEnforcer2 }
  } = environment;
  return {
    enforcer: LimitedCallsEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/idBuilder.ts
import { toHex as toHex6 } from "viem";
var id = "id";
var idBuilder = (environment, id2) => {
  if (typeof id2 !== "number") {
    throw new Error("Invalid id: must be a number");
  }
  if (!Number.isInteger(id2)) {
    throw new Error("Invalid id: must be an integer");
  }
  if (id2 >= 2 ** 32) {
    throw new Error("Invalid id: must be 32 bytes or fewer in length");
  }
  const terms = toHex6(id2, { size: 32 });
  const {
    caveatEnforcers: { IdEnforcer: IdEnforcer2 }
  } = environment;
  return {
    enforcer: IdEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/nonceBuilder.ts
import { isHex as isHex5, pad as pad3 } from "viem";
var nonce = "nonce";
var MAX_NONCE_STRING_LENGTH = 66;
var nonceBuilder = (environment, nonce2) => {
  if (!nonce2 || nonce2 === "0x") {
    throw new Error("Invalid nonce: must be a non-empty hex string");
  }
  if (!isHex5(nonce2)) {
    throw new Error("Invalid nonce: must be a valid hex string");
  }
  if (nonce2.length > MAX_NONCE_STRING_LENGTH) {
    throw new Error("Invalid nonce: must be 32 bytes or less in length");
  }
  const {
    caveatEnforcers: { NonceEnforcer: NonceEnforcer2 }
  } = environment;
  return {
    enforcer: NonceEnforcer2,
    terms: pad3(nonce2, { size: 32 }),
    args: "0x"
  };
};

// src/caveatBuilder/timestampBuilder.ts
import { concat as concat6, toHex as toHex7 } from "viem";

// src/caveatBuilder/shared.ts
var TIMESTAMP_UPPER_BOUND_SECONDS = 253402300799;

// src/caveatBuilder/timestampBuilder.ts
var timestamp = "timestamp";
var timestampBuilder = (environment, timestampAfterThreshold, timestampBeforeThreshold) => {
  if (timestampAfterThreshold < 0) {
    throw new Error(
      "Invalid timestampAfterThreshold: must be zero or positive"
    );
  }
  if (timestampBeforeThreshold < 0) {
    throw new Error(
      "Invalid timestampBeforeThreshold: must be zero or positive"
    );
  }
  if (timestampBeforeThreshold > TIMESTAMP_UPPER_BOUND_SECONDS) {
    throw new Error(
      "Invalid timestampBeforeThreshold: must be less than or equal to 253402300799"
    );
  }
  if (timestampAfterThreshold > TIMESTAMP_UPPER_BOUND_SECONDS) {
    throw new Error(
      "Invalid timestampAfterThreshold: must be less than or equal to 253402300799"
    );
  }
  if (timestampBeforeThreshold !== 0 && timestampAfterThreshold >= timestampBeforeThreshold) {
    throw new Error(
      "Invalid thresholds: timestampBeforeThreshold must be greater than timestampAfterThreshold when both are specified"
    );
  }
  const afterThresholdHex = toHex7(timestampAfterThreshold, { size: 16 });
  const beforeThresholdHex = toHex7(timestampBeforeThreshold, { size: 16 });
  const terms = concat6([afterThresholdHex, beforeThresholdHex]);
  const {
    caveatEnforcers: { TimestampEnforcer: TimestampEnforcer2 }
  } = environment;
  return {
    enforcer: TimestampEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/blockNumberBuilder.ts
import { concat as concat7, toHex as toHex8 } from "viem";
var blockNumber = "blockNumber";
var blockNumberBuilder = (environment, blockAfterThreshold, blockBeforeThreshold) => {
  if (blockAfterThreshold === 0n && blockBeforeThreshold === 0n) {
    throw new Error(
      "Invalid thresholds: At least one of blockAfterThreshold or blockBeforeThreshold must be specified"
    );
  }
  if (blockBeforeThreshold !== 0n && blockAfterThreshold >= blockBeforeThreshold) {
    throw new Error(
      "Invalid thresholds: blockAfterThreshold must be less than blockBeforeThreshold if both are specified"
    );
  }
  const terms = concat7([
    toHex8(blockAfterThreshold, {
      size: 16
    }),
    toHex8(blockBeforeThreshold, {
      size: 16
    })
  ]);
  const {
    caveatEnforcers: { BlockNumberEnforcer: BlockNumberEnforcer2 }
  } = environment;
  return {
    enforcer: BlockNumberEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/erc20TransferAmountBuilder.ts
import { concat as concat8, isAddress as isAddress4, toHex as toHex9 } from "viem";
var erc20TransferAmount = "erc20TransferAmount";
var erc20TransferAmountBuilder = (environment, tokenAddress, maxAmount) => {
  if (!isAddress4(tokenAddress, { strict: false })) {
    throw new Error("Invalid tokenAddress: must be a valid address");
  }
  if (maxAmount <= 0n) {
    throw new Error("Invalid maxAmount: must be a positive number");
  }
  const terms = concat8([tokenAddress, toHex9(maxAmount, { size: 32 })]);
  const {
    caveatEnforcers: { ERC20TransferAmountEnforcer: ERC20TransferAmountEnforcer2 }
  } = environment;
  return {
    enforcer: ERC20TransferAmountEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/erc20StreamingBuilder.ts
import { isAddress as isAddress5, encodePacked as encodePacked4 } from "viem";
var erc20Streaming = "erc20Streaming";
var erc20StreamingBuilder = (environment, tokenAddress, initialAmount, maxAmount, amountPerSecond, startTime) => {
  if (!isAddress5(tokenAddress, { strict: false })) {
    throw new Error("Invalid tokenAddress: must be a valid address");
  }
  if (initialAmount < 0n) {
    throw new Error("Invalid initialAmount: must be greater than zero");
  }
  if (maxAmount <= 0n) {
    throw new Error("Invalid maxAmount: must be a positive number");
  }
  if (maxAmount < initialAmount) {
    throw new Error("Invalid maxAmount: must be greater than initialAmount");
  }
  if (amountPerSecond <= 0n) {
    throw new Error("Invalid amountPerSecond: must be a positive number");
  }
  if (startTime <= 0) {
    throw new Error("Invalid startTime: must be a positive number");
  }
  if (startTime > TIMESTAMP_UPPER_BOUND_SECONDS) {
    throw new Error(
      "Invalid startTime: must be less than or equal to 253402300799"
    );
  }
  const terms = encodePacked4(
    ["address", "uint256", "uint256", "uint256", "uint256"],
    [
      tokenAddress,
      initialAmount,
      maxAmount,
      amountPerSecond,
      BigInt(startTime)
    ]
  );
  const {
    caveatEnforcers: { ERC20StreamingEnforcer: ERC20StreamingEnforcer2 }
  } = environment;
  return {
    enforcer: ERC20StreamingEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/nativeTokenStreamingBuilder.ts
import { encodePacked as encodePacked5 } from "viem";
var nativeTokenStreaming = "nativeTokenStreaming";
var nativeTokenStreamingBuilder = (environment, initialAmount, maxAmount, amountPerSecond, startTime) => {
  if (initialAmount < 0n) {
    throw new Error("Invalid initialAmount: must be greater than zero");
  }
  if (maxAmount <= 0n) {
    throw new Error("Invalid maxAmount: must be a positive number");
  }
  if (maxAmount < initialAmount) {
    throw new Error("Invalid maxAmount: must be greater than initialAmount");
  }
  if (amountPerSecond <= 0n) {
    throw new Error("Invalid amountPerSecond: must be a positive number");
  }
  if (startTime <= 0) {
    throw new Error("Invalid startTime: must be a positive number");
  }
  if (startTime > TIMESTAMP_UPPER_BOUND_SECONDS) {
    throw new Error(
      "Invalid startTime: must be less than or equal to 253402300799"
    );
  }
  const terms = encodePacked5(
    ["uint256", "uint256", "uint256", "uint256"],
    [initialAmount, maxAmount, amountPerSecond, BigInt(startTime)]
  );
  const {
    caveatEnforcers: { NativeTokenStreamingEnforcer: NativeTokenStreamingEnforcer2 }
  } = environment;
  return {
    enforcer: NativeTokenStreamingEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/nativeTokenTransferAmountBuilder.ts
import { encodePacked as encodePacked6 } from "viem";
var nativeTokenTransferAmount = "nativeTokenTransferAmount";
var nativeTokenTransferAmountBuilder = (environment, allowance) => {
  if (allowance < 0n) {
    throw new Error("Invalid allowance: must be zero or positive");
  }
  const terms = encodePacked6(["uint256"], [allowance]);
  const {
    caveatEnforcers: { NativeTokenTransferAmountEnforcer: NativeTokenTransferAmountEnforcer2 }
  } = environment;
  return {
    enforcer: NativeTokenTransferAmountEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/nativeBalanceChangeBuilder.ts
import { isAddress as isAddress6, encodePacked as encodePacked7 } from "viem";
var nativeBalanceChange = "nativeBalanceChange";
var nativeBalanceChangeBuilder = (environment, recipient, balance, changeType) => {
  if (!isAddress6(recipient)) {
    throw new Error("Invalid recipient: must be a valid Address");
  }
  if (balance <= 0n) {
    throw new Error("Invalid balance: must be a positive number");
  }
  if (changeType !== 0 /* Increase */ && changeType !== 1 /* Decrease */) {
    throw new Error("Invalid changeType: must be either Increase or Decrease");
  }
  const terms = encodePacked7(
    ["uint8", "address", "uint256"],
    [changeType, recipient, balance]
  );
  const {
    caveatEnforcers: { NativeBalanceChangeEnforcer: NativeBalanceChangeEnforcer2 }
  } = environment;
  return {
    enforcer: NativeBalanceChangeEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/redeemerBuilder.ts
import { concat as concat9, isAddress as isAddress7 } from "viem";
var redeemer = "redeemer";
var redeemerBuilder = (environment, redeemers) => {
  if (redeemers.length === 0) {
    throw new Error(
      "Invalid redeemers: must specify at least one redeemer address"
    );
  }
  for (let i = 0; i < redeemers.length; i++) {
    if (!isAddress7(redeemers[i])) {
      throw new Error("Invalid redeemers: must be a valid address");
    }
  }
  const terms = concat9(redeemers);
  const {
    caveatEnforcers: { RedeemerEnforcer: RedeemerEnforcer2 }
  } = environment;
  return {
    enforcer: RedeemerEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/nativeTokenPaymentBuilder.ts
import { encodePacked as encodePacked8, isAddress as isAddress8 } from "viem";
var nativeTokenPayment = "nativeTokenPayment";
var nativeTokenPaymentBuilder = (environment, recipient, amount) => {
  if (amount <= 0n) {
    throw new Error("Invalid amount: must be positive");
  }
  if (!isAddress8(recipient)) {
    throw new Error("Invalid recipient: must be a valid address");
  }
  const terms = encodePacked8(["address", "uint256"], [recipient, amount]);
  const {
    caveatEnforcers: { NativeTokenPaymentEnforcer: NativeTokenPaymentEnforcer2 }
  } = environment;
  return {
    enforcer: NativeTokenPaymentEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/argsEqualityCheckBuilder.ts
import { isHex as isHex6 } from "viem";
var argsEqualityCheck = "argsEqualityCheck";
var argsEqualityCheckBuilder = (environment, args) => {
  if (!isHex6(args)) {
    throw new Error("Invalid args: must be a valid hex string");
  }
  const terms = args;
  const {
    caveatEnforcers: { ArgsEqualityCheckEnforcer: ArgsEqualityCheckEnforcer2 }
  } = environment;
  return {
    enforcer: ArgsEqualityCheckEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/erc1155BalanceChangeBuilder.ts
import { isAddress as isAddress9, encodePacked as encodePacked9 } from "viem";
var erc1155BalanceChange = "erc1155BalanceChange";
var erc1155BalanceChangeBuilder = (environment, tokenAddress, recipient, tokenId, balance, changeType) => {
  if (!isAddress9(tokenAddress, { strict: false })) {
    throw new Error("Invalid tokenAddress: must be a valid address");
  }
  if (!isAddress9(recipient, { strict: false })) {
    throw new Error("Invalid recipient: must be a valid address");
  }
  if (balance <= 0n) {
    throw new Error("Invalid balance: must be a positive number");
  }
  if (tokenId < 0) {
    throw new Error("Invalid tokenId: must be a non-negative number");
  }
  if (changeType !== 0 /* Increase */ && changeType !== 1 /* Decrease */) {
    throw new Error("Invalid changeType: must be either Increase or Decrease");
  }
  const terms = encodePacked9(
    ["uint8", "address", "address", "uint256", "uint256"],
    [changeType, tokenAddress, recipient, tokenId, balance]
  );
  const {
    caveatEnforcers: { ERC1155BalanceChangeEnforcer: ERC1155BalanceChangeEnforcer2 }
  } = environment;
  return {
    enforcer: ERC1155BalanceChangeEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/erc721BalanceChangeBuilder.ts
import { isAddress as isAddress10, encodePacked as encodePacked10 } from "viem";
var erc721BalanceChange = "erc721BalanceChange";
var erc721BalanceChangeBuilder = (environment, tokenAddress, recipient, amount, changeType) => {
  if (!isAddress10(tokenAddress, { strict: false })) {
    throw new Error("Invalid tokenAddress: must be a valid address");
  }
  if (!isAddress10(recipient, { strict: false })) {
    throw new Error("Invalid recipient: must be a valid address");
  }
  if (amount <= 0) {
    throw new Error("Invalid balance: must be a positive number");
  }
  if (changeType !== 0 /* Increase */ && changeType !== 1 /* Decrease */) {
    throw new Error("Invalid changeType: must be either Increase or Decrease");
  }
  const terms = encodePacked10(
    ["uint8", "address", "address", "uint256"],
    [changeType, tokenAddress, recipient, amount]
  );
  const {
    caveatEnforcers: { ERC721BalanceChangeEnforcer: ERC721BalanceChangeEnforcer2 }
  } = environment;
  return {
    enforcer: ERC721BalanceChangeEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/erc721TransferBuilder.ts
import { isAddress as isAddress11, toHex as toHex10, concat as concat10 } from "viem";
var erc721Transfer = "erc721Transfer";
var erc721TransferBuilder = (environment, permittedContract, permittedTokenId) => {
  if (!isAddress11(permittedContract, { strict: false })) {
    throw new Error("Invalid tokenAddress: must be a valid address");
  }
  if (permittedTokenId < 0) {
    throw new Error("Invalid permittedTokenId: must be a non-negative number");
  }
  const terms = concat10([
    permittedContract,
    toHex10(permittedTokenId, { size: 32 })
  ]);
  const {
    caveatEnforcers: { ERC721TransferEnforcer: ERC721TransferEnforcer2 }
  } = environment;
  return {
    enforcer: ERC721TransferEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/specificActionERC20TransferBatchBuilder.ts
import { concat as concat11, isAddress as isAddress12, toHex as toHex11 } from "viem";
var specificActionERC20TransferBatch = "specificActionERC20TransferBatch";
var specificActionERC20TransferBatchBuilder = (environment, tokenAddress, recipient, amount, firstTarget, firstCalldata) => {
  if (!isAddress12(tokenAddress, { strict: false })) {
    throw new Error("Invalid tokenAddress: must be a valid address");
  }
  if (!isAddress12(recipient, { strict: false })) {
    throw new Error("Invalid recipient: must be a valid address");
  }
  if (!isAddress12(firstTarget, { strict: false })) {
    throw new Error("Invalid firstTarget: must be a valid address");
  }
  if (amount <= 0n) {
    throw new Error("Invalid amount: must be a positive number");
  }
  const terms = concat11([
    tokenAddress,
    recipient,
    toHex11(amount, { size: 32 }),
    firstTarget,
    firstCalldata
  ]);
  const {
    caveatEnforcers: { SpecificActionERC20TransferBatchEnforcer: SpecificActionERC20TransferBatchEnforcer2 }
  } = environment;
  return {
    enforcer: SpecificActionERC20TransferBatchEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/erc20PeriodTransferBuilder.ts
import { concat as concat12, isAddress as isAddress13, toHex as toHex12 } from "viem";
var erc20PeriodTransfer = "erc20PeriodTransfer";
var erc20PeriodTransferBuilder = (environment, tokenAddress, periodAmount, periodDuration, startDate) => {
  if (!isAddress13(tokenAddress)) {
    throw new Error("Invalid tokenAddress: must be a valid address");
  }
  if (periodAmount <= 0n) {
    throw new Error("Invalid periodAmount: must be a positive number");
  }
  if (periodDuration <= 0) {
    throw new Error("Invalid periodDuration: must be a positive number");
  }
  if (startDate <= 0) {
    throw new Error("Invalid startDate: must be a positive number");
  }
  const terms = concat12([
    tokenAddress,
    toHex12(periodAmount, { size: 32 }),
    toHex12(periodDuration, { size: 32 }),
    toHex12(startDate, { size: 32 })
  ]);
  return {
    enforcer: environment.caveatEnforcers.ERC20PeriodTransferEnforcer,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/nativeTokenPeriodTransferBuilder.ts
import { concat as concat13, toHex as toHex13 } from "viem";
var nativeTokenPeriodTransfer = "nativeTokenPeriodTransfer";
var nativeTokenPeriodTransferBuilder = (environment, periodAmount, periodDuration, startDate) => {
  if (periodAmount <= 0n) {
    throw new Error("Invalid periodAmount: must be a positive number");
  }
  if (periodDuration <= 0) {
    throw new Error("Invalid periodDuration: must be a positive number");
  }
  if (startDate <= 0) {
    throw new Error("Invalid startDate: must be a positive number");
  }
  const terms = concat13([
    toHex13(periodAmount, { size: 32 }),
    toHex13(periodDuration, { size: 32 }),
    toHex13(startDate, { size: 32 })
  ]);
  const {
    caveatEnforcers: { NativeTokenPeriodTransferEnforcer: NativeTokenPeriodTransferEnforcer2 }
  } = environment;
  return {
    enforcer: NativeTokenPeriodTransferEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/exactCalldataBatchBuilder.ts
import {
  encodeAbiParameters as encodeAbiParameters3,
  isAddress as isAddress14
} from "viem";
var exactCalldataBatch = "exactCalldataBatch";
var exactCalldataBatchBuilder = (environment, executions) => {
  if (executions.length === 0) {
    throw new Error("Invalid executions: array cannot be empty");
  }
  for (const execution of executions) {
    if (!isAddress14(execution.target, { strict: false })) {
      throw new Error("Invalid target: must be a valid address");
    }
    if (execution.value < 0n) {
      throw new Error("Invalid value: must be a non-negative number");
    }
    if (!execution.callData.startsWith("0x")) {
      throw new Error(
        "Invalid callData: must be a hex string starting with 0x"
      );
    }
  }
  const terms = encodeAbiParameters3(
    [
      {
        type: "tuple[]",
        components: [
          { type: "address", name: "target" },
          { type: "uint256", name: "value" },
          { type: "bytes", name: "callData" }
        ]
      }
    ],
    [executions]
  );
  const {
    caveatEnforcers: { ExactCalldataBatchEnforcer: ExactCalldataBatchEnforcer2 }
  } = environment;
  return {
    enforcer: ExactCalldataBatchEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/exactCalldataBuilder.ts
var exactCalldata = "exactCalldata";
var exactCalldataBuilder = (environment, callData) => {
  if (!callData.startsWith("0x")) {
    throw new Error("Invalid callData: must be a hex string starting with 0x");
  }
  const {
    caveatEnforcers: { ExactCalldataEnforcer: ExactCalldataEnforcer2 }
  } = environment;
  return {
    enforcer: ExactCalldataEnforcer2,
    terms: callData,
    args: "0x"
  };
};

// src/caveatBuilder/exactExecutionBuilder.ts
import { isAddress as isAddress15, concat as concat15, toHex as toHex15 } from "viem";
var exactExecution = "exactExecution";
var exactExecutionBuilder = (environment, execution) => {
  if (!isAddress15(execution.target, { strict: false })) {
    throw new Error("Invalid target: must be a valid address");
  }
  if (execution.value < 0n) {
    throw new Error("Invalid value: must be a non-negative number");
  }
  if (!execution.callData.startsWith("0x")) {
    throw new Error("Invalid callData: must be a hex string starting with 0x");
  }
  const terms = concat15([
    execution.target,
    toHex15(execution.value, { size: 32 }),
    execution.callData
  ]);
  const {
    caveatEnforcers: { ExactExecutionEnforcer: ExactExecutionEnforcer2 }
  } = environment;
  return {
    enforcer: ExactExecutionEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/exactExecutionBatchBuilder.ts
import { encodeAbiParameters as encodeAbiParameters4, isAddress as isAddress16 } from "viem";
var exactExecutionBatch = "exactExecutionBatch";
var exactExecutionBatchBuilder = (environment, executions) => {
  if (executions.length === 0) {
    throw new Error("Invalid executions: array cannot be empty");
  }
  for (const execution of executions) {
    if (!isAddress16(execution.target, { strict: false })) {
      throw new Error("Invalid target: must be a valid address");
    }
    if (execution.value < 0n) {
      throw new Error("Invalid value: must be a non-negative number");
    }
    if (!execution.callData.startsWith("0x")) {
      throw new Error(
        "Invalid callData: must be a hex string starting with 0x"
      );
    }
  }
  const terms = encodeAbiParameters4(
    [
      {
        type: "tuple[]",
        components: [
          { type: "address", name: "target" },
          { type: "uint256", name: "value" },
          { type: "bytes", name: "callData" }
        ]
      }
    ],
    [executions]
  );
  const {
    caveatEnforcers: { ExactExecutionBatchEnforcer: ExactExecutionBatchEnforcer2 }
  } = environment;
  return {
    enforcer: ExactExecutionBatchEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/multiTokenPeriodBuilder.ts
import { concat as concat17, isAddress as isAddress17, pad as pad4, toHex as toHex17 } from "viem";
var multiTokenPeriod = "multiTokenPeriod";
var multiTokenPeriodBuilder = (environment, configs) => {
  if (!configs || configs.length === 0) {
    throw new Error("MultiTokenPeriodBuilder: configs array cannot be empty");
  }
  configs.forEach((config) => {
    if (!isAddress17(config.token)) {
      throw new Error(`Invalid token address: ${config.token}`);
    }
    if (config.periodAmount <= 0) {
      throw new Error("Invalid period amount: must be greater than 0");
    }
    if (config.periodDuration <= 0) {
      throw new Error("Invalid period duration: must be greater than 0");
    }
  });
  const termsArray = configs.reduce(
    (acc, { token, periodAmount, periodDuration, startDate }) => [
      ...acc,
      pad4(token, { size: 20 }),
      toHex17(periodAmount, { size: 32 }),
      toHex17(periodDuration, { size: 32 }),
      toHex17(startDate, { size: 32 })
    ],
    []
  );
  const terms = concat17(termsArray);
  const {
    caveatEnforcers: { MultiTokenPeriodEnforcer: MultiTokenPeriodEnforcer2 }
  } = environment;
  return {
    enforcer: MultiTokenPeriodEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/index.ts
var createCaveatBuilder = (environment, config) => {
  const caveatBuilder = new CaveatBuilder(environment, config).extend(allowedMethods, allowedMethodsBuilder).extend(allowedTargets, allowedTargetsBuilder).extend(deployed, deployedBuilder).extend(allowedCalldata, allowedCalldataBuilder).extend(erc20BalanceChange, erc20BalanceChangeBuilder).extend(erc721BalanceChange, erc721BalanceChangeBuilder).extend(erc1155BalanceChange, erc1155BalanceChangeBuilder).extend(valueLte, valueLteBuilder).extend(limitedCalls, limitedCallsBuilder).extend(id, idBuilder).extend(nonce, nonceBuilder).extend(timestamp, timestampBuilder).extend(blockNumber, blockNumberBuilder).extend(erc20TransferAmount, erc20TransferAmountBuilder).extend(erc20Streaming, erc20StreamingBuilder).extend(nativeTokenStreaming, nativeTokenStreamingBuilder).extend(erc721Transfer, erc721TransferBuilder).extend(nativeTokenTransferAmount, nativeTokenTransferAmountBuilder).extend(nativeBalanceChange, nativeBalanceChangeBuilder).extend(redeemer, redeemerBuilder).extend(nativeTokenPayment, nativeTokenPaymentBuilder).extend(argsEqualityCheck, argsEqualityCheckBuilder).extend(
    specificActionERC20TransferBatch,
    specificActionERC20TransferBatchBuilder
  ).extend(erc20PeriodTransfer, erc20PeriodTransferBuilder).extend(nativeTokenPeriodTransfer, nativeTokenPeriodTransferBuilder).extend(exactCalldataBatch, exactCalldataBatchBuilder).extend(exactCalldata, exactCalldataBuilder).extend(exactExecution, exactExecutionBuilder).extend(exactExecutionBatch, exactExecutionBatchBuilder).extend(multiTokenPeriod, multiTokenPeriodBuilder);
  return caveatBuilder;
};

// src/delegation.ts
var toDelegationStruct = (delegation) => {
  const caveats = delegation.caveats.map((caveat) => ({
    enforcer: getAddress(caveat.enforcer),
    terms: caveat.terms,
    args: caveat.args
  }));
  const salt = delegation.salt === "0x" ? 0n : BigInt(delegation.salt);
  return {
    delegate: getAddress(delegation.delegate),
    delegator: getAddress(delegation.delegator),
    authority: delegation.authority === void 0 ? ROOT_AUTHORITY : delegation.authority,
    caveats,
    salt,
    signature: delegation.signature
  };
};
var encodeDelegation = (delegations) => {
  const delegationStructs = delegations.map(toDelegationStruct);
  return encodeAbiParameters5(
    [
      {
        components: DELEGATION_ABI_TYPE_COMPONENTS,
        name: "delegations",
        type: "tuple[]"
      }
    ],
    [delegationStructs]
  );
};
var encodePermissionContexts = (delegations) => {
  const encodedDelegations = delegations.map(
    (delegationChain) => encodeDelegation(delegationChain)
  );
  return encodedDelegations;
};
var ROOT_AUTHORITY = "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff";
var ANY_BENEFICIARY = "0x0000000000000000000000000000000000000a11";
var DELEGATION_TYPEHASH = keccak2562(
  toHex18(
    "Delegation(address delegate,address delegator,bytes32 authority,Caveat[] caveats,uint256 salt)Caveat(address enforcer,bytes terms)"
  )
);
var DELEGATION_ABI_TYPE_COMPONENTS = [
  { type: "address", name: "delegate" },
  { type: "address", name: "delegator" },
  { type: "bytes32", name: "authority" },
  { type: "tuple[]", name: "caveats", components: CAVEAT_ABI_TYPE_COMPONENTS },
  { type: "uint256", name: "salt" },
  { type: "bytes", name: "signature" }
];
var SIGNABLE_DELEGATION_TYPED_DATA = {
  Caveat: [
    { name: "enforcer", type: "address" },
    { name: "terms", type: "bytes" }
  ],
  Delegation: [
    { name: "delegate", type: "address" },
    { name: "delegator", type: "address" },
    { name: "authority", type: "bytes32" },
    { name: "caveats", type: "Caveat[]" },
    { name: "salt", type: "uint256" }
  ]
};
var DELEGATION_ARRAY_ABI_TYPE = {
  type: "tuple[]",
  components: DELEGATION_ABI_TYPE_COMPONENTS
};
var encodeDelegations = (delegations) => encodeAbiParameters5([DELEGATION_ARRAY_ABI_TYPE], [delegations]);
var prepDelegationHashForPasskeySign = (delegationHash) => {
  return hashMessage({
    raw: toBytes(delegationHash)
  });
};
var getDelegationHashOffchain = (input) => {
  const delegationStruct = toDelegationStruct(input);
  const encoded = encodeAbiParameters5(
    parseAbiParameters3("bytes32, address, address, bytes32, bytes32, uint"),
    [
      DELEGATION_TYPEHASH,
      delegationStruct.delegate,
      delegationStruct.delegator,
      delegationStruct.authority,
      getCaveatArrayPacketHash(delegationStruct.caveats),
      delegationStruct.salt
    ]
  );
  return keccak2562(encoded);
};
var resolveAuthority = (parentDelegation) => {
  if (!parentDelegation) {
    return ROOT_AUTHORITY;
  }
  if (typeof parentDelegation === "string") {
    return parentDelegation;
  }
  return getDelegationHashOffchain(parentDelegation);
};
var createDelegation = (options) => {
  return {
    delegate: options.to,
    delegator: options.from,
    authority: resolveAuthority(options.parentDelegation),
    caveats: resolveCaveats(options.caveats),
    salt: "0x",
    signature: "0x"
  };
};
var createOpenDelegation = (options) => {
  return {
    delegate: ANY_BENEFICIARY,
    delegator: options.from,
    authority: resolveAuthority(options.parentDelegation),
    caveats: resolveCaveats(options.caveats),
    salt: "0x",
    signature: "0x"
  };
};
var signDelegation = async ({
  signer,
  delegation,
  delegationManager,
  chainId,
  name = "DelegationManager",
  version = "1"
}) => {
  const delegationStruct = toDelegationStruct({
    ...delegation,
    signature: "0x"
  });
  return signer.signTypedData({
    account: signer.account,
    domain: {
      chainId,
      name,
      version,
      verifyingContract: delegationManager
    },
    types: SIGNABLE_DELEGATION_TYPED_DATA,
    primaryType: "Delegation",
    message: delegationStruct
  });
};

// src/delegatorEnvironment.ts
import { DELEGATOR_CONTRACTS } from "@metamask/delegation-deployments";
import {
  EntryPoint,
  SimpleFactory as SimpleFactory2,
  DelegationManager as DelegationManager2,
  MultiSigDeleGator,
  HybridDeleGator,
  SCL_RIP7212,
  AllowedTargetsEnforcer,
  AllowedMethodsEnforcer,
  DeployedEnforcer,
  TimestampEnforcer,
  NonceEnforcer,
  AllowedCalldataEnforcer,
  BlockNumberEnforcer,
  LimitedCallsEnforcer,
  ERC20BalanceChangeEnforcer,
  ERC20StreamingEnforcer,
  IdEnforcer,
  ERC20TransferAmountEnforcer,
  ValueLteEnforcer,
  NativeTokenTransferAmountEnforcer,
  NativeBalanceChangeEnforcer,
  NativeTokenStreamingEnforcer,
  NativeTokenPaymentEnforcer,
  RedeemerEnforcer,
  ArgsEqualityCheckEnforcer,
  ERC721BalanceChangeEnforcer,
  ERC721TransferEnforcer,
  ERC1155BalanceChangeEnforcer,
  OwnershipTransferEnforcer,
  SpecificActionERC20TransferBatchEnforcer,
  ERC20PeriodTransferEnforcer,
  NativeTokenPeriodTransferEnforcer,
  ExactCalldataBatchEnforcer,
  ExactCalldataEnforcer,
  ExactExecutionEnforcer,
  ExactExecutionBatchEnforcer,
  MultiTokenPeriodEnforcer
} from "@metamask/delegation-abis";

// src/write.ts
import { SimpleFactory, DelegationManager } from "@metamask/delegation-abis";
var deployWithSimpleFactory = async (walletClient, publicClient, simpleFactoryAddress, creationCode, salt) => {
  const { request } = await publicClient.simulateContract({
    account: walletClient.account,
    address: simpleFactoryAddress,
    abi: SimpleFactory.abi,
    functionName: "deploy",
    args: [creationCode, salt]
  });
  return await walletClient.writeContract(request);
};
var redeemDelegations = async (walletClient, publicClient, delegationManagerAddress, redemptions) => {
  if (redemptions.length === 0) {
    throw new Error(`RedeemDelegations invalid zero redemptions`);
  }
  const permissionContexts = [];
  const executionsBatch = [];
  const executionModes = [];
  redemptions.forEach((redemption) => {
    permissionContexts.push(redemption.permissionContext);
    executionsBatch.push(redemption.executions);
    executionModes.push(redemption.mode);
  });
  const encodedPermissionContexts = encodePermissionContexts(permissionContexts);
  const executionCalldatas = encodeExecutionCalldatas(executionsBatch);
  const { request } = await publicClient.simulateContract({
    account: walletClient.account,
    address: delegationManagerAddress,
    abi: DelegationManager.abi,
    functionName: "redeemDelegations",
    args: [encodedPermissionContexts, executionModes, executionCalldatas]
  });
  return await walletClient.writeContract(request);
};
async function deployContract(walletClient, publicClient, chain, { bytecode, abi }, args = []) {
  const hash = await walletClient.deployContract({
    abi,
    bytecode,
    args,
    account: walletClient.account,
    chain
  });
  const receipt = await publicClient.waitForTransactionReceipt({
    hash
  });
  const address = (await receipt).contractAddress;
  return { address, hash, receipt };
}

// src/delegatorEnvironment.ts
var PREFERRED_VERSION = "1.3.0";
var contractOverrides = {
  "1.0.0": {},
  "1.1.0": {},
  "1.2.0": {},
  "1.3.0": {}
};
function overrideDeployedEnvironment(chainId, version, environment) {
  contractOverrides[version][chainId] = environment;
}
function getDeleGatorEnvironment(chainId, version = PREFERRED_VERSION) {
  const override = contractOverrides[version][chainId];
  if (override) {
    return override;
  }
  const c = DELEGATOR_CONTRACTS[version]?.[chainId];
  if (!c) {
    throw new Error(
      `No contracts found for version ${version} chain ${chainId}`
    );
  }
  return getDeleGatorEnvironment_v1(c);
}
function getDeleGatorEnvironment_v1(c) {
  return {
    DelegationManager: c.DelegationManager,
    EntryPoint: c.EntryPoint,
    SimpleFactory: c.SimpleFactory,
    implementations: {
      MultiSigDeleGatorImpl: c.MultiSigDeleGatorImpl,
      HybridDeleGatorImpl: c.HybridDeleGatorImpl
    },
    caveatEnforcers: {
      AllowedCalldataEnforcer: c.AllowedCalldataEnforcer,
      AllowedMethodsEnforcer: c.AllowedMethodsEnforcer,
      AllowedTargetsEnforcer: c.AllowedTargetsEnforcer,
      ArgsEqualityCheckEnforcer: c.ArgsEqualityCheckEnforcer,
      BlockNumberEnforcer: c.BlockNumberEnforcer,
      DeployedEnforcer: c.DeployedEnforcer,
      ERC20BalanceChangeEnforcer: c.ERC20BalanceChangeEnforcer,
      ERC20TransferAmountEnforcer: c.ERC20TransferAmountEnforcer,
      ERC20StreamingEnforcer: c.ERC20StreamingEnforcer,
      ERC721BalanceChangeEnforcer: c.ERC721BalanceChangeEnforcer,
      ERC721TransferEnforcer: c.ERC721TransferEnforcer,
      ERC1155BalanceChangeEnforcer: c.ERC1155BalanceChangeEnforcer,
      IdEnforcer: c.IdEnforcer,
      LimitedCallsEnforcer: c.LimitedCallsEnforcer,
      NonceEnforcer: c.NonceEnforcer,
      TimestampEnforcer: c.TimestampEnforcer,
      ValueLteEnforcer: c.ValueLteEnforcer,
      NativeTokenTransferAmountEnforcer: c.NativeTokenTransferAmountEnforcer,
      NativeBalanceChangeEnforcer: c.NativeBalanceChangeEnforcer,
      NativeTokenStreamingEnforcer: c.NativeTokenStreamingEnforcer,
      NativeTokenPaymentEnforcer: c.NativeTokenPaymentEnforcer,
      OwnershipTransferEnforcer: c.OwnershipTransferEnforcer,
      RedeemerEnforcer: c.RedeemerEnforcer,
      SpecificActionERC20TransferBatchEnforcer: c.SpecificActionERC20TransferBatchEnforcer,
      ERC20PeriodTransferEnforcer: c.ERC20PeriodTransferEnforcer,
      NativeTokenPeriodTransferEnforcer: c.NativeTokenPeriodTransferEnforcer,
      ExactCalldataBatchEnforcer: c.ExactCalldataBatchEnforcer,
      ExactCalldataEnforcer: c.ExactCalldataEnforcer,
      ExactExecutionEnforcer: c.ExactExecutionEnforcer,
      ExactExecutionBatchEnforcer: c.ExactExecutionBatchEnforcer,
      MultiTokenPeriodEnforcer: c.MultiTokenPeriodEnforcer
    }
  };
}
async function deployDeleGatorEnvironment(walletClient, publicClient, chain, deployedContracts = {}) {
  const deployContractCurried = async (name, contract, params = []) => {
    if (deployedContracts[name]) {
      return {
        address: deployedContracts[name],
        name
      };
    }
    const deployedContract = await deployContract(
      walletClient,
      publicClient,
      chain,
      contract,
      params
    );
    deployedContracts[name] = deployedContract.address;
    return { ...deployedContract, name };
  };
  const standaloneContracts = {
    SimpleFactory: SimpleFactory2,
    AllowedCalldataEnforcer,
    AllowedTargetsEnforcer,
    AllowedMethodsEnforcer,
    ArgsEqualityCheckEnforcer,
    DeployedEnforcer,
    TimestampEnforcer,
    BlockNumberEnforcer,
    LimitedCallsEnforcer,
    ERC20BalanceChangeEnforcer,
    ERC20TransferAmountEnforcer,
    ERC20StreamingEnforcer,
    ERC721BalanceChangeEnforcer,
    ERC721TransferEnforcer,
    ERC1155BalanceChangeEnforcer,
    IdEnforcer,
    NonceEnforcer,
    ValueLteEnforcer,
    NativeTokenTransferAmountEnforcer,
    NativeBalanceChangeEnforcer,
    NativeTokenStreamingEnforcer,
    OwnershipTransferEnforcer,
    RedeemerEnforcer,
    SpecificActionERC20TransferBatchEnforcer,
    ERC20PeriodTransferEnforcer,
    NativeTokenPeriodTransferEnforcer,
    ExactCalldataBatchEnforcer,
    ExactCalldataEnforcer,
    ExactExecutionEnforcer,
    ExactExecutionBatchEnforcer,
    MultiTokenPeriodEnforcer
  };
  for (const [name, contract] of Object.entries(standaloneContracts)) {
    await deployContractCurried(name, contract);
  }
  const delegationManager = await deployContractCurried(
    "DelegationManager",
    DelegationManager2,
    [walletClient.account?.address]
  );
  await deployContractCurried(
    "NativeTokenPaymentEnforcer",
    NativeTokenPaymentEnforcer,
    [delegationManager.address, deployedContracts["ArgsEqualityCheckEnforcer"]]
  );
  const entryPoint = await deployContractCurried("EntryPoint", EntryPoint);
  const { address: sclRIP7212 } = await deployContract(
    walletClient,
    publicClient,
    chain,
    SCL_RIP7212,
    []
  );
  const hybridDeleGatorWithLinkedLibrary = {
    ...HybridDeleGator,
    bytecode: HybridDeleGator.bytecode.replace(
      /__\$b8f96b288d4d0429e38b8ed50fd423070f\$__/g,
      sclRIP7212.slice(2)
    )
  };
  await deployContractCurried(
    "HybridDeleGatorImpl",
    hybridDeleGatorWithLinkedLibrary,
    [delegationManager.address, entryPoint.address]
  );
  await deployContractCurried("MultiSigDeleGatorImpl", MultiSigDeleGator, [
    delegationManager.address,
    entryPoint.address
  ]);
  return getDeleGatorEnvironment_v1(deployedContracts);
}

// src/rpcError.ts
var RpcError = class _RpcError extends Error {
  code;
  data;
  static INVALID_PARAMETERS = -32602;
  static INTERNAL_ERROR = -32603;
  static METHOD_NOT_SUPPORTED = -32601;
  // implementation-defined server-error
  static CONNECTION_CLOSED = -32001;
  static from(error) {
    if (error instanceof _RpcError) {
      return error;
    }
    const errorMessage = error instanceof Error ? error.message : error;
    return new _RpcError(errorMessage, _RpcError.INTERNAL_ERROR);
  }
  toJSONRPCError() {
    const { message, code, data } = this;
    return {
      message,
      code,
      data
    };
  }
  constructor(message, code, data) {
    super(message);
    Object.setPrototypeOf(this, _RpcError.prototype);
    this.code = code;
    this.data = data;
  }
};

// src/userOp.ts
import { concat as concat18, encodeAbiParameters as encodeAbiParameters6, keccak256 as keccak2563, pad as pad5, toHex as toHex19 } from "viem";
import { toPackedUserOperation } from "viem/account-abstraction";
var createRawUserOp = (sender, nonce2, callData, signature = "0x", options) => ({
  sender,
  nonce: nonce2,
  callData,
  factory: options?.factory,
  factoryData: options?.factoryData,
  callGasLimit: options?.callGasLimit ?? 0n,
  verificationGasLimit: options?.verificationGasLimit ?? 0n,
  preVerificationGas: options?.preVerificationGas ?? 0n,
  maxFeePerGas: options?.maxFeePerGas ?? 0n,
  maxPriorityFeePerGas: options?.maxPriorityFeePerGas ?? 0n,
  paymaster: options?.paymaster,
  paymasterVerificationGasLimit: options?.paymasterVerificationGasLimit,
  paymasterPostOpGasLimit: options?.paymasterPostOpGasLimit,
  paymasterData: options?.paymasterData,
  signature
});
var getSalt = (salt) => {
  if (!salt) {
    salt = "0x0";
  }
  return salt;
};
var getPaymasterAndData = (userOp) => {
  let paymasterAndData;
  if (userOp.paymaster) {
    paymasterAndData = concat18([
      userOp.paymaster,
      pad5(toHex19(userOp.paymasterVerificationGasLimit || 0n), {
        size: 16
      }),
      pad5(toHex19(userOp.paymasterPostOpGasLimit || 0n), {
        size: 16
      }),
      userOp.paymasterData || "0x"
    ]);
  } else {
    paymasterAndData = "0x";
  }
  return paymasterAndData;
};
var getInitCode = (userOp) => {
  return userOp.factory ? concat18([userOp.factory, userOp.factoryData ?? "0x"]) : "0x";
};
var getAccountGasLimits = (userOp) => {
  return concat18([
    pad5(toHex19(userOp.verificationGasLimit), {
      size: 16
    }),
    pad5(toHex19(userOp.callGasLimit), { size: 16 })
  ]);
};
var getGasFees = (userOp) => {
  return concat18([
    pad5(toHex19(userOp.maxPriorityFeePerGas), {
      size: 16
    }),
    pad5(toHex19(userOp.maxFeePerGas), { size: 16 })
  ]);
};
var packUserOp = (userOp) => {
  const packedOp = {
    sender: userOp.sender,
    nonce: BigInt(userOp.nonce),
    initCode: getInitCode(userOp),
    callData: userOp.callData,
    accountGasLimits: getAccountGasLimits(userOp),
    preVerificationGas: BigInt(userOp.preVerificationGas),
    gasFees: getGasFees(userOp),
    paymasterAndData: getPaymasterAndData(userOp),
    signature: userOp.signature
  };
  return packedOp;
};
var createUserOpHashV07 = (packedOp, entryPoint, chainId) => {
  const hash = keccak2563(
    encodeAbiParameters6(
      [
        {
          name: "sender",
          type: "address"
        },
        {
          name: "nonce",
          type: "uint256"
        },
        {
          name: "initCodeHash",
          type: "bytes32"
        },
        {
          name: "callDataHash",
          type: "bytes32"
        },
        {
          name: "accountGasLimits",
          type: "bytes32"
        },
        {
          name: "preVerificationGas",
          type: "uint256"
        },
        {
          name: "gasFees",
          type: "bytes32"
        },
        {
          name: "paymasterAndDataHash",
          type: "bytes32"
        }
      ],
      [
        packedOp.sender,
        packedOp.nonce,
        keccak2563(packedOp.initCode),
        keccak2563(packedOp.callData),
        packedOp.accountGasLimits,
        packedOp.preVerificationGas,
        packedOp.gasFees,
        keccak2563(packedOp.paymasterAndData)
      ]
    )
  );
  return keccak2563(
    encodeAbiParameters6(
      [
        {
          name: "userOpHash",
          type: "bytes32"
        },
        {
          name: "entryPointAddress",
          type: "address"
        },
        {
          name: "chainId",
          type: "uint256"
        }
      ],
      [hash, entryPoint, chainId]
    )
  );
};
var SIGNABLE_USER_OP_TYPED_DATA = {
  PackedUserOperation: [
    { name: "sender", type: "address" },
    { name: "nonce", type: "uint256" },
    { name: "initCode", type: "bytes" },
    { name: "callData", type: "bytes" },
    { name: "accountGasLimits", type: "bytes32" },
    { name: "preVerificationGas", type: "uint256" },
    { name: "gasFees", type: "bytes32" },
    { name: "paymasterAndData", type: "bytes" },
    { name: "entryPoint", type: "address" }
  ]
};
var signUserOperation = async ({
  signer,
  userOperation,
  entryPoint,
  chainId,
  name,
  address,
  version = "1"
}) => {
  const packedUserOp = toPackedUserOperation({
    ...userOperation,
    signature: "0x"
  });
  return signer.signTypedData({
    account: signer.account,
    domain: {
      chainId,
      name,
      version,
      verifyingContract: address
    },
    types: SIGNABLE_USER_OP_TYPED_DATA,
    primaryType: "PackedUserOperation",
    message: { ...packedUserOp, entryPoint: entryPoint.address }
  });
};

// src/webAuthn.ts
import { parseSignature } from "webauthn-p256";
import {
  parseAbiParameters as parseAbiParameters4,
  encodeAbiParameters as encodeAbiParameters7,
  encodePacked as encodePacked11,
  keccak256 as keccak2564,
  concat as concat19
} from "viem";
var FIELD_MODULUS = 115792089210356248762697446949407573529996955224135760342422259061068512044369n;
var MALLEABILITY_THRESHOLD = FIELD_MODULUS / 2n;
var SIGNATURE_ABI_PARAMS = parseAbiParameters4(
  "bytes32, uint256, uint256, bytes, bool, string, string, uint256"
);
var splitOnChallenge = (clientDataJson) => {
  try {
    const { challenge } = JSON.parse(clientDataJson);
    if (challenge === void 0) {
      throw new Error('No "challenge" found in the input string');
    }
    return clientDataJson.split(challenge);
  } catch (error) {
    throw new Error('No "challenge" found in the input string', {
      cause: error
    });
  }
};
var getResponseTypeLocation = (clientDataJson) => {
  try {
    const typeIndex = clientDataJson.indexOf('"type":');
    if (typeIndex === -1)
      throw new Error('No "type" found in the input string');
    return BigInt(typeIndex);
  } catch (error) {
    throw new Error('No "type" found in the input string', {
      cause: error
    });
  }
};
function encodeDeleGatorSignature(keyId, signature, clientDataJSON, authenticatorData) {
  const keyIdHash = keccak2564(encodePacked11(["string"], [keyId]));
  let { r, s } = parseSignature(signature);
  while (s > MALLEABILITY_THRESHOLD) {
    s = FIELD_MODULUS - s;
  }
  const [clientDataComponent1, clientDataComponent2] = splitOnChallenge(clientDataJSON);
  const { userVerified } = parseAuthenticatorFlags(authenticatorData);
  const responseTypeLocation = getResponseTypeLocation(clientDataJSON);
  const encodedSignature = encodeAbiParameters7(SIGNATURE_ABI_PARAMS, [
    keyIdHash,
    r,
    s,
    authenticatorData,
    userVerified,
    clientDataComponent1,
    clientDataComponent2,
    responseTypeLocation
  ]);
  return encodedSignature;
}
var AUTHENTICATOR_DATA_FLAGS_OFFSET = 32;
function parseAuthenticatorFlags(authenticatorData) {
  const authenticatorDataBuffer = Buffer.from(
    authenticatorData.slice(2),
    "hex"
  );
  const flags = authenticatorDataBuffer.readUInt8(
    AUTHENTICATOR_DATA_FLAGS_OFFSET
  );
  const bitMask = 1 << 2 /* USER_VERIFIED */;
  return {
    userVerified: (flags & bitMask) !== 0
  };
}
var createDummyWebAuthnSignature = (keyId) => {
  const rpIdHash = keccak2564(encodePacked11(["string"], ["AuthenticatorData"]));
  const flags = "0x05";
  const signCount = "0x00000000";
  const authenticatorData = concat19([rpIdHash, flags, signCount]);
  const keyIdHash = keccak2564(encodePacked11(["string"], [keyId]));
  const rs = 57896044605178124381348723474703786764998477612067880171211129530534256022184n;
  const userVerification = true;
  const clientDataPrefix = '{"type":"webauthn.get","challenge":"';
  const clientDataSuffix = '","origin":"passkey-domain","crossOrigin":false}';
  const responseTypeLocation = 1n;
  const encodedSignature = encodeAbiParameters7(SIGNATURE_ABI_PARAMS, [
    keyIdHash,
    rs,
    rs,
    authenticatorData,
    userVerification,
    clientDataPrefix,
    clientDataSuffix,
    responseTypeLocation
  ]);
  return encodedSignature;
};

// src/signatures.ts
import { concat as concat20 } from "viem";
var signatureTypes = ["ECDSA"];
var aggregateSignature = ({
  signatures
}) => {
  if (signatures.length === 0) {
    return "0x";
  }
  for (const { type } of signatures) {
    if (!signatureTypes.includes(type)) {
      throw new Error(`Invalid signature type: ${type}`);
    }
  }
  const sortedSignatures = [...signatures].sort(
    (a, b) => a.signer.localeCompare(b.signer)
  );
  return concat20(sortedSignatures.map(({ signature }) => signature));
};
export {
  ANY_BENEFICIARY,
  BATCH_DEFAULT_MODE,
  BATCH_TRY_MODE,
  BalanceChangeType,
  CAVEAT_ABI_TYPE_COMPONENTS,
  CAVEAT_TYPEHASH,
  CaveatBuilder,
  DELEGATION_ABI_TYPE_COMPONENTS,
  DELEGATION_ARRAY_ABI_TYPE,
  DELEGATION_TYPEHASH,
  EXECUTION_ABI_TYPE_COMPONENTS,
  FIELD_MODULUS,
  Implementation,
  MALLEABILITY_THRESHOLD,
  PREFERRED_VERSION,
  ROOT_AUTHORITY,
  RpcError,
  SIGNABLE_DELEGATION_TYPED_DATA,
  SIGNABLE_USER_OP_TYPED_DATA,
  SIGNATURE_ABI_PARAMS,
  SINGLE_DEFAULT_MODE,
  SINGLE_TRY_MODE,
  aggregateSignature,
  createCaveat,
  createCaveatBuilder,
  createDelegation,
  createDummyWebAuthnSignature,
  createExecution,
  createOpenDelegation,
  createRawUserOp,
  createUserOpHashV07,
  deepHexlify,
  deployContract,
  deployDeleGatorEnvironment,
  deployWithSimpleFactory,
  encodeBatchExecution,
  encodeDeleGatorSignature,
  encodeDelegation,
  encodeDelegations,
  encodeExecutionCalldata,
  encodeExecutionCalldatas,
  encodePermissionContexts,
  encodeSingleExecution,
  erc1155BalanceChange,
  erc721BalanceChange,
  getAccountGasLimits,
  getCaveatArrayPacketHash,
  getCaveatPacketHash,
  getDeleGatorEnvironment,
  getDeleGatorEnvironment_v1,
  getDelegationHashOffchain,
  getExplorerAddressLink,
  getExplorerTransactionLink,
  getGasFees,
  getInfuraRpcUrl,
  getInitCode,
  getPaymasterAndData,
  getResponseTypeLocation,
  getSalt,
  isEqualHex,
  nativeBalanceChange,
  overrideDeployedEnvironment,
  packUserOp,
  parseAuthenticatorFlags,
  prepDelegationHashForPasskeySign,
  redeemDelegations,
  resolveAuthority,
  resolveCaveats,
  shortenHash,
  signDelegation,
  signUserOperation,
  splitOnChallenge,
  toDelegationStruct
};
//# sourceMappingURL=index.mjs.map