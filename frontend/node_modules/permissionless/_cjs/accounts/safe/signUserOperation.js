"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.signUserOperation = signUserOperation;
const viem_1 = require("viem");
const index_js_1 = require("../../utils/index.js");
const toSafeSmartAccount_js_1 = require("./toSafeSmartAccount.js");
async function signUserOperation(parameters) {
    const { chainId, entryPoint, validAfter = 0, validUntil = 0, safe4337ModuleAddress: _safe4337ModuleAddress, version, owners, signatures: existingSignatures, account, ...userOperation } = parameters;
    const { safe4337ModuleAddress } = (0, toSafeSmartAccount_js_1.getDefaultAddresses)(version, entryPoint.version, {
        safe4337ModuleAddress: _safe4337ModuleAddress
    });
    const message = {
        safe: userOperation.sender,
        callData: userOperation.callData,
        nonce: userOperation.nonce,
        initCode: userOperation.initCode ?? "0x",
        maxFeePerGas: userOperation.maxFeePerGas,
        maxPriorityFeePerGas: userOperation.maxPriorityFeePerGas,
        preVerificationGas: userOperation.preVerificationGas,
        verificationGasLimit: userOperation.verificationGasLimit,
        callGasLimit: userOperation.callGasLimit,
        paymasterAndData: userOperation.paymasterAndData ?? "0x",
        validAfter: validAfter,
        validUntil: validUntil,
        entryPoint: entryPoint.address
    };
    if ("initCode" in userOperation) {
        message.paymasterAndData = userOperation.paymasterAndData ?? "0x";
    }
    if ("factory" in userOperation) {
        if (userOperation.factory && userOperation.factoryData) {
            message.initCode = (0, viem_1.concatHex)([
                userOperation.factory,
                userOperation.factoryData
            ]);
        }
        if (!userOperation.sender) {
            throw new Error("Sender is required");
        }
        message.paymasterAndData = (0, toSafeSmartAccount_js_1.getPaymasterAndData)({
            ...userOperation,
            sender: userOperation.sender
        });
    }
    const localOwners = [
        await (0, index_js_1.toOwner)({
            owner: account
        })
    ];
    let unPackedSignatures = [];
    if (existingSignatures) {
        const decoded = (0, viem_1.decodeAbiParameters)([
            {
                components: [
                    { type: "address", name: "signer" },
                    { type: "bytes", name: "data" }
                ],
                name: "signatures",
                type: "tuple[]"
            }
        ], existingSignatures);
        unPackedSignatures = decoded[0];
    }
    const signatures = [
        ...unPackedSignatures,
        ...(await Promise.all(localOwners.map(async (localOwner) => ({
            signer: localOwner.address,
            data: await localOwner.signTypedData({
                domain: {
                    chainId,
                    verifyingContract: safe4337ModuleAddress
                },
                types: entryPoint.version === "0.6"
                    ? toSafeSmartAccount_js_1.EIP712_SAFE_OPERATION_TYPE_V06
                    : toSafeSmartAccount_js_1.EIP712_SAFE_OPERATION_TYPE_V07,
                primaryType: "SafeOp",
                message: message
            })
        }))))
    ];
    if (signatures.length !== owners.length) {
        return (0, viem_1.encodeAbiParameters)([
            {
                components: [
                    { type: "address", name: "signer" },
                    { type: "bytes", name: "data" }
                ],
                name: "signatures",
                type: "tuple[]"
            }
        ], [signatures]);
    }
    signatures.sort((left, right) => left.signer.toLowerCase().localeCompare(right.signer.toLowerCase()));
    const signatureBytes = (0, viem_1.concat)(signatures.map((sig) => sig.data));
    return (0, viem_1.encodePacked)(["uint48", "uint48", "bytes"], [validAfter, validUntil, signatureBytes]);
}
//# sourceMappingURL=signUserOperation.js.map