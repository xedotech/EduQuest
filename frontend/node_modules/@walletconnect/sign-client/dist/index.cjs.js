"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var h=require("@walletconnect/core"),J=require("@walletconnect/logger"),Se=require("@walletconnect/types"),i=require("@walletconnect/utils"),Te=require("events"),N=require("@walletconnect/time"),R=require("@walletconnect/jsonrpc-utils");function Me(S){return S&&typeof S=="object"&&"default"in S?S:{default:S}}var Ue=Me(Te);const ae="wc",ce=2,le="client",Q=`${ae}@${ce}:${le}:`,X={name:le,logger:"error",controller:!1,relayUrl:"wss://relay.walletconnect.org"},$e={session_proposal:"session_proposal",session_update:"session_update",session_extend:"session_extend",session_ping:"session_ping",session_delete:"session_delete",session_expire:"session_expire",session_request:"session_request",session_request_sent:"session_request_sent",session_event:"session_event",proposal_expire:"proposal_expire",session_authenticate:"session_authenticate",session_request_expire:"session_request_expire",session_connect:"session_connect"},Ke={database:":memory:"},pe="WALLETCONNECT_DEEPLINK_CHOICE",Fe={created:"history_created",updated:"history_updated",deleted:"history_deleted",sync:"history_sync"},Ge="history",Ye="0.3",Re="proposal",je=N.THIRTY_DAYS,he="Proposal expired",Ie="session",M=N.SEVEN_DAYS,Ne="engine",q={wc_sessionPropose:{req:{ttl:N.FIVE_MINUTES,prompt:!0,tag:1100},res:{ttl:N.FIVE_MINUTES,prompt:!1,tag:1101},reject:{ttl:N.FIVE_MINUTES,prompt:!1,tag:1120},autoReject:{ttl:N.FIVE_MINUTES,prompt:!1,tag:1121}},wc_sessionSettle:{req:{ttl:N.FIVE_MINUTES,prompt:!1,tag:1102},res:{ttl:N.FIVE_MINUTES,prompt:!1,tag:1103}},wc_sessionUpdate:{req:{ttl:N.ONE_DAY,prompt:!1,tag:1104},res:{ttl:N.ONE_DAY,prompt:!1,tag:1105}},wc_sessionExtend:{req:{ttl:N.ONE_DAY,prompt:!1,tag:1106},res:{ttl:N.ONE_DAY,prompt:!1,tag:1107}},wc_sessionRequest:{req:{ttl:N.FIVE_MINUTES,prompt:!0,tag:1108},res:{ttl:N.FIVE_MINUTES,prompt:!1,tag:1109}},wc_sessionEvent:{req:{ttl:N.FIVE_MINUTES,prompt:!0,tag:1110},res:{ttl:N.FIVE_MINUTES,prompt:!1,tag:1111}},wc_sessionDelete:{req:{ttl:N.ONE_DAY,prompt:!1,tag:1112},res:{ttl:N.ONE_DAY,prompt:!1,tag:1113}},wc_sessionPing:{req:{ttl:N.ONE_DAY,prompt:!1,tag:1114},res:{ttl:N.ONE_DAY,prompt:!1,tag:1115}},wc_sessionAuthenticate:{req:{ttl:N.ONE_HOUR,prompt:!0,tag:1116},res:{ttl:N.ONE_HOUR,prompt:!1,tag:1117},reject:{ttl:N.FIVE_MINUTES,prompt:!1,tag:1118},autoReject:{ttl:N.FIVE_MINUTES,prompt:!1,tag:1119}}},z={min:N.FIVE_MINUTES,max:N.SEVEN_DAYS},b={idle:"IDLE",active:"ACTIVE"},fe={eth_sendTransaction:{key:""},eth_sendRawTransaction:{key:""},wallet_sendCalls:{key:""},solana_signTransaction:{key:"signature"},solana_signAllTransactions:{key:"transactions"},solana_signAndSendTransaction:{key:"signature"},sui_signAndExecuteTransaction:{key:"digest"},sui_signTransaction:{key:""},hedera_signAndExecuteTransaction:{key:"transactionId"},hedera_executeTransaction:{key:"transactionId"},near_signTransaction:{key:""},near_signTransactions:{key:""},tron_signTransaction:{key:"txID"},xrpl_signTransaction:{key:""},xrpl_signTransactionFor:{key:""},algo_signTxn:{key:""},sendTransfer:{key:"txid"},stacks_stxTransfer:{key:"txId"},polkadot_signTransaction:{key:""},cosmos_signDirect:{key:""}},ve="request",Pe=["wc_sessionPropose","wc_sessionRequest","wc_authRequest","wc_sessionAuthenticate"],Oe="wc",He=1.5,qe="auth",Ae="authKeys",Ce="pairingTopics",Ve="requests",F=`${Oe}@${1.5}:${qe}:`,G=`${F}:PUB_KEY`;var Je=Object.defineProperty,Qe=Object.defineProperties,Xe=Object.getOwnPropertyDescriptors,Le=Object.getOwnPropertySymbols,ze=Object.prototype.hasOwnProperty,Be=Object.prototype.propertyIsEnumerable,de=(S,a,t)=>a in S?Je(S,a,{enumerable:!0,configurable:!0,writable:!0,value:t}):S[a]=t,v=(S,a)=>{for(var t in a||(a={}))ze.call(a,t)&&de(S,t,a[t]);if(Le)for(var t of Le(a))Be.call(a,t)&&de(S,t,a[t]);return S},C=(S,a)=>Qe(S,Xe(a)),l=(S,a,t)=>de(S,typeof a!="symbol"?a+"":a,t);class We extends Se.IEngine{constructor(a){super(a),l(this,"name",Ne),l(this,"events",new Ue.default),l(this,"initialized",!1),l(this,"requestQueue",{state:b.idle,queue:[]}),l(this,"sessionRequestQueue",{state:b.idle,queue:[]}),l(this,"emittedSessionRequests",new i.LimitedSet({limit:500})),l(this,"requestQueueDelay",N.ONE_SECOND),l(this,"expectedPairingMethodMap",new Map),l(this,"recentlyDeletedMap",new Map),l(this,"recentlyDeletedLimit",200),l(this,"relayMessageCache",[]),l(this,"pendingSessions",new Map),l(this,"init",async()=>{this.initialized||(await this.cleanup(),this.registerRelayerEvents(),this.registerExpirerEvents(),this.registerPairingEvents(),await this.registerLinkModeListeners(),this.client.core.pairing.register({methods:Object.keys(q)}),this.initialized=!0,setTimeout(async()=>{await this.processPendingMessageEvents(),this.sessionRequestQueue.queue=this.getPendingSessionRequests(),this.processSessionRequestQueue()},N.toMiliseconds(this.requestQueueDelay)))}),l(this,"connect",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();const e=C(v({},t),{requiredNamespaces:t.requiredNamespaces||{},optionalNamespaces:t.optionalNamespaces||{}});await this.isValidConnect(e),e.optionalNamespaces=i.mergeRequiredAndOptionalNamespaces(e.requiredNamespaces,e.optionalNamespaces),e.requiredNamespaces={};const{pairingTopic:s,requiredNamespaces:r,optionalNamespaces:n,sessionProperties:o,scopedProperties:c,relays:p}=e;let d=s,u,E=!1;try{if(d){const P=this.client.core.pairing.pairings.get(d);this.client.logger.warn("connect() with existing pairing topic is deprecated and will be removed in the next major release."),E=P.active}}catch(P){throw this.client.logger.error(`connect() -> pairing.get(${d}) failed`),P}if(!d||!E){const{topic:P,uri:D}=await this.client.core.pairing.create();d=P,u=D}if(!d){const{message:P}=i.getInternalError("NO_MATCHING_KEY",`connect() pairing topic: ${d}`);throw new Error(P)}const g=await this.client.core.crypto.generateKeyPair(),m=q.wc_sessionPropose.req.ttl||N.FIVE_MINUTES,_=i.calcExpiry(m),y=C(v(v({requiredNamespaces:r,optionalNamespaces:n,relays:p??[{protocol:h.RELAYER_DEFAULT_PROTOCOL}],proposer:{publicKey:g,metadata:this.client.metadata},expiryTimestamp:_,pairingTopic:d},o&&{sessionProperties:o}),c&&{scopedProperties:c}),{id:R.payloadId()}),T=i.engineEvent("session_connect",y.id),{reject:w,resolve:V,done:L}=i.createDelayedPromise(m,he),f=({id:P})=>{P===y.id&&(this.client.events.off("proposal_expire",f),this.pendingSessions.delete(y.id),this.events.emit(T,{error:{message:he,code:0}}))};return this.client.events.on("proposal_expire",f),this.events.once(T,({error:P,session:D})=>{this.client.events.off("proposal_expire",f),P?w(P):D&&V(D)}),await this.sendRequest({topic:d,method:"wc_sessionPropose",params:y,throwOnFailedPublish:!0,clientRpcId:y.id}),await this.setProposal(y.id,y),{uri:u,approval:L}}),l(this,"pair",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{return await this.client.core.pairing.pair(t)}catch(e){throw this.client.logger.error("pair() failed"),e}}),l(this,"approve",async t=>{var e,s,r;const n=this.client.core.eventClient.createEvent({properties:{topic:(e=t?.id)==null?void 0:e.toString(),trace:[h.EVENT_CLIENT_SESSION_TRACES.session_approve_started]}});try{this.isInitialized(),await this.confirmOnlineStateOrThrow()}catch(O){throw n.setError(h.EVENT_CLIENT_SESSION_ERRORS.no_internet_connection),O}try{await this.isValidProposalId(t?.id)}catch(O){throw this.client.logger.error(`approve() -> proposal.get(${t?.id}) failed`),n.setError(h.EVENT_CLIENT_SESSION_ERRORS.proposal_not_found),O}try{await this.isValidApprove(t)}catch(O){throw this.client.logger.error("approve() -> isValidApprove() failed"),n.setError(h.EVENT_CLIENT_SESSION_ERRORS.session_approve_namespace_validation_failure),O}const{id:o,relayProtocol:c,namespaces:p,sessionProperties:d,scopedProperties:u,sessionConfig:E}=t,g=this.client.proposal.get(o);this.client.core.eventClient.deleteEvent({eventId:n.eventId});const{pairingTopic:m,proposer:_,requiredNamespaces:y,optionalNamespaces:T}=g;let w=(s=this.client.core.eventClient)==null?void 0:s.getEvent({topic:m});w||(w=(r=this.client.core.eventClient)==null?void 0:r.createEvent({type:h.EVENT_CLIENT_SESSION_TRACES.session_approve_started,properties:{topic:m,trace:[h.EVENT_CLIENT_SESSION_TRACES.session_approve_started,h.EVENT_CLIENT_SESSION_TRACES.session_namespaces_validation_success]}}));const V=await this.client.core.crypto.generateKeyPair(),L=_.publicKey,f=await this.client.core.crypto.generateSharedKey(V,L),P=v(v(v({relay:{protocol:c??"irn"},namespaces:p,controller:{publicKey:V,metadata:this.client.metadata},expiry:i.calcExpiry(M)},d&&{sessionProperties:d}),u&&{scopedProperties:u}),E&&{sessionConfig:E}),D=h.TRANSPORT_TYPES.relay;w.addTrace(h.EVENT_CLIENT_SESSION_TRACES.subscribing_session_topic);try{await this.client.core.relayer.subscribe(f,{transportType:D})}catch(O){throw w.setError(h.EVENT_CLIENT_SESSION_ERRORS.subscribe_session_topic_failure),O}w.addTrace(h.EVENT_CLIENT_SESSION_TRACES.subscribe_session_topic_success);const W=C(v({},P),{topic:f,requiredNamespaces:y,optionalNamespaces:T,pairingTopic:m,acknowledged:!1,self:P.controller,peer:{publicKey:_.publicKey,metadata:_.metadata},controller:V,transportType:h.TRANSPORT_TYPES.relay});await this.client.session.set(f,W),w.addTrace(h.EVENT_CLIENT_SESSION_TRACES.store_session);try{w.addTrace(h.EVENT_CLIENT_SESSION_TRACES.publishing_session_settle),await this.sendRequest({topic:f,method:"wc_sessionSettle",params:P,throwOnFailedPublish:!0}).catch(O=>{throw w?.setError(h.EVENT_CLIENT_SESSION_ERRORS.session_settle_publish_failure),O}),w.addTrace(h.EVENT_CLIENT_SESSION_TRACES.session_settle_publish_success),w.addTrace(h.EVENT_CLIENT_SESSION_TRACES.publishing_session_approve),await this.sendResult({id:o,topic:m,result:{relay:{protocol:c??"irn"},responderPublicKey:V},throwOnFailedPublish:!0}).catch(O=>{throw w?.setError(h.EVENT_CLIENT_SESSION_ERRORS.session_approve_publish_failure),O}),w.addTrace(h.EVENT_CLIENT_SESSION_TRACES.session_approve_publish_success)}catch(O){throw this.client.logger.error(O),this.client.session.delete(f,i.getSdkError("USER_DISCONNECTED")),await this.client.core.relayer.unsubscribe(f),O}return this.client.core.eventClient.deleteEvent({eventId:w.eventId}),await this.client.core.pairing.updateMetadata({topic:m,metadata:_.metadata}),await this.deleteProposal(o),await this.client.core.pairing.activate({topic:m}),await this.setExpiry(f,i.calcExpiry(M)),{topic:f,acknowledged:()=>Promise.resolve(this.client.session.get(f))}}),l(this,"reject",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidReject(t)}catch(n){throw this.client.logger.error("reject() -> isValidReject() failed"),n}const{id:e,reason:s}=t;let r;try{r=this.client.proposal.get(e).pairingTopic}catch(n){throw this.client.logger.error(`reject() -> proposal.get(${e}) failed`),n}r&&await this.sendError({id:e,topic:r,error:s,rpcOpts:q.wc_sessionPropose.reject}),await this.deleteProposal(e)}),l(this,"update",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidUpdate(t)}catch(u){throw this.client.logger.error("update() -> isValidUpdate() failed"),u}const{topic:e,namespaces:s}=t,{done:r,resolve:n,reject:o}=i.createDelayedPromise(),c=R.payloadId(),p=R.getBigIntRpcId().toString(),d=this.client.session.get(e).namespaces;return this.events.once(i.engineEvent("session_update",c),({error:u})=>{u?o(u):n()}),await this.client.session.update(e,{namespaces:s}),await this.sendRequest({topic:e,method:"wc_sessionUpdate",params:{namespaces:s},throwOnFailedPublish:!0,clientRpcId:c,relayRpcId:p}).catch(u=>{this.client.logger.error(u),this.client.session.update(e,{namespaces:d}),o(u)}),{acknowledged:r}}),l(this,"extend",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidExtend(t)}catch(c){throw this.client.logger.error("extend() -> isValidExtend() failed"),c}const{topic:e}=t,s=R.payloadId(),{done:r,resolve:n,reject:o}=i.createDelayedPromise();return this.events.once(i.engineEvent("session_extend",s),({error:c})=>{c?o(c):n()}),await this.setExpiry(e,i.calcExpiry(M)),this.sendRequest({topic:e,method:"wc_sessionExtend",params:{},clientRpcId:s,throwOnFailedPublish:!0}).catch(c=>{o(c)}),{acknowledged:r}}),l(this,"request",async t=>{this.isInitialized();try{await this.isValidRequest(t)}catch(y){throw this.client.logger.error("request() -> isValidRequest() failed"),y}const{chainId:e,request:s,topic:r,expiry:n=q.wc_sessionRequest.req.ttl}=t,o=this.client.session.get(r);o?.transportType===h.TRANSPORT_TYPES.relay&&await this.confirmOnlineStateOrThrow();const c=R.payloadId(),p=R.getBigIntRpcId().toString(),{done:d,resolve:u,reject:E}=i.createDelayedPromise(n,"Request expired. Please try again.");this.events.once(i.engineEvent("session_request",c),({error:y,result:T})=>{y?E(y):u(T)});const g="wc_sessionRequest",m=this.getAppLinkIfEnabled(o.peer.metadata,o.transportType);if(m)return await this.sendRequest({clientRpcId:c,relayRpcId:p,topic:r,method:g,params:{request:C(v({},s),{expiryTimestamp:i.calcExpiry(n)}),chainId:e},expiry:n,throwOnFailedPublish:!0,appLink:m}).catch(y=>E(y)),this.client.events.emit("session_request_sent",{topic:r,request:s,chainId:e,id:c}),await d();const _={request:C(v({},s),{expiryTimestamp:i.calcExpiry(n)}),chainId:e};return await Promise.all([new Promise(async y=>{await this.sendRequest({clientRpcId:c,relayRpcId:p,topic:r,method:g,params:_,expiry:n,throwOnFailedPublish:!0,tvf:this.getTVFParams(c,_)}).catch(T=>E(T)),this.client.events.emit("session_request_sent",{topic:r,request:s,chainId:e,id:c}),y()}),new Promise(async y=>{var T;if(!((T=o.sessionConfig)!=null&&T.disableDeepLink)){const w=await i.getDeepLink(this.client.core.storage,pe);await i.handleDeeplinkRedirect({id:c,topic:r,wcDeepLink:w})}y()}),d()]).then(y=>y[2])}),l(this,"respond",async t=>{this.isInitialized(),await this.isValidRespond(t);const{topic:e,response:s}=t,{id:r}=s,n=this.client.session.get(e);n.transportType===h.TRANSPORT_TYPES.relay&&await this.confirmOnlineStateOrThrow();const o=this.getAppLinkIfEnabled(n.peer.metadata,n.transportType);R.isJsonRpcResult(s)?await this.sendResult({id:r,topic:e,result:s.result,throwOnFailedPublish:!0,appLink:o}):R.isJsonRpcError(s)&&await this.sendError({id:r,topic:e,error:s.error,appLink:o}),this.cleanupAfterResponse(t)}),l(this,"ping",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidPing(t)}catch(s){throw this.client.logger.error("ping() -> isValidPing() failed"),s}const{topic:e}=t;if(this.client.session.keys.includes(e)){const s=R.payloadId(),r=R.getBigIntRpcId().toString(),{done:n,resolve:o,reject:c}=i.createDelayedPromise();this.events.once(i.engineEvent("session_ping",s),({error:p})=>{p?c(p):o()}),await Promise.all([this.sendRequest({topic:e,method:"wc_sessionPing",params:{},throwOnFailedPublish:!0,clientRpcId:s,relayRpcId:r}),n()])}else this.client.core.pairing.pairings.keys.includes(e)&&(this.client.logger.warn("ping() on pairing topic is deprecated and will be removed in the next major release."),await this.client.core.pairing.ping({topic:e}))}),l(this,"emit",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow(),await this.isValidEmit(t);const{topic:e,event:s,chainId:r}=t,n=R.getBigIntRpcId().toString(),o=R.payloadId();await this.sendRequest({topic:e,method:"wc_sessionEvent",params:{event:s,chainId:r},throwOnFailedPublish:!0,relayRpcId:n,clientRpcId:o})}),l(this,"disconnect",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow(),await this.isValidDisconnect(t);const{topic:e}=t;if(this.client.session.keys.includes(e))await this.sendRequest({topic:e,method:"wc_sessionDelete",params:i.getSdkError("USER_DISCONNECTED"),throwOnFailedPublish:!0}),await this.deleteSession({topic:e,emitEvent:!1});else if(this.client.core.pairing.pairings.keys.includes(e))await this.client.core.pairing.disconnect({topic:e});else{const{message:s}=i.getInternalError("MISMATCHED_TOPIC",`Session or pairing topic not found: ${e}`);throw new Error(s)}}),l(this,"find",t=>(this.isInitialized(),this.client.session.getAll().filter(e=>i.isSessionCompatible(e,t)))),l(this,"getPendingSessionRequests",()=>this.client.pendingRequest.getAll()),l(this,"authenticate",async(t,e)=>{var s;this.isInitialized(),this.isValidAuthenticate(t);const r=e&&this.client.core.linkModeSupportedApps.includes(e)&&((s=this.client.metadata.redirect)==null?void 0:s.linkMode),n=r?h.TRANSPORT_TYPES.link_mode:h.TRANSPORT_TYPES.relay;n===h.TRANSPORT_TYPES.relay&&await this.confirmOnlineStateOrThrow();const{chains:o,statement:c="",uri:p,domain:d,nonce:u,type:E,exp:g,nbf:m,methods:_=[],expiry:y}=t,T=[...t.resources||[]],{topic:w,uri:V}=await this.client.core.pairing.create({methods:["wc_sessionAuthenticate"],transportType:n});this.client.logger.info({message:"Generated new pairing",pairing:{topic:w,uri:V}});const L=await this.client.core.crypto.generateKeyPair(),f=i.hashKey(L);if(await Promise.all([this.client.auth.authKeys.set(G,{responseTopic:f,publicKey:L}),this.client.auth.pairingTopics.set(f,{topic:f,pairingTopic:w})]),await this.client.core.relayer.subscribe(f,{transportType:n}),this.client.logger.info(`sending request to new pairing topic: ${w}`),_.length>0){const{namespace:A}=i.parseChainId(o[0]);let x=i.createEncodedRecap(A,"request",_);i.getRecapFromResources(T)&&(x=i.mergeEncodedRecaps(x,T.pop())),T.push(x)}const P=y&&y>q.wc_sessionAuthenticate.req.ttl?y:q.wc_sessionAuthenticate.req.ttl,D={authPayload:{type:E??"caip122",chains:o,statement:c,aud:p,domain:d,version:"1",nonce:u,iat:new Date().toISOString(),exp:g,nbf:m,resources:T},requester:{publicKey:L,metadata:this.client.metadata},expiryTimestamp:i.calcExpiry(P)},W={eip155:{chains:o,methods:[...new Set(["personal_sign",..._])],events:["chainChanged","accountsChanged"]}},O={requiredNamespaces:{},optionalNamespaces:W,relays:[{protocol:"irn"}],pairingTopic:w,proposer:{publicKey:L,metadata:this.client.metadata},expiryTimestamp:i.calcExpiry(q.wc_sessionPropose.req.ttl),id:R.payloadId()},{done:be,resolve:ge,reject:Z}=i.createDelayedPromise(P,"Request expired"),U=R.payloadId(),Y=i.engineEvent("session_connect",O.id),ee=i.engineEvent("session_request",U),j=async({error:A,session:x})=>{this.events.off(ee,te),A?Z(A):x&&ge({session:x})},te=async A=>{var x,Ee,ye;if(await this.deletePendingAuthRequest(U,{message:"fulfilled",code:0}),A.error){const K=i.getSdkError("WC_METHOD_UNSUPPORTED","wc_sessionAuthenticate");return A.error.code===K.code?void 0:(this.events.off(Y,j),Z(A.error.message))}await this.deleteProposal(O.id),this.events.off(Y,j);const{cacaos:_e,responder:k}=A.result,ie=[],me=[];for(const K of _e){await i.validateSignedCacao({cacao:K,projectId:this.client.core.projectId})||(this.client.logger.error(K,"Signature verification failed"),Z(i.getSdkError("SESSION_SETTLEMENT_FAILED","Signature verification failed")));const{p:re}=K,ne=i.getRecapFromResources(re.resources),we=[i.getNamespacedDidChainId(re.iss)],De=i.getDidAddress(re.iss);if(ne){const oe=i.getMethodsFromRecap(ne),ke=i.getChainsFromRecap(ne);ie.push(...oe),we.push(...ke)}for(const oe of we)me.push(`${oe}:${De}`)}const $=await this.client.core.crypto.generateSharedKey(L,k.publicKey);let H;ie.length>0&&(H={topic:$,acknowledged:!0,self:{publicKey:L,metadata:this.client.metadata},peer:k,controller:k.publicKey,expiry:i.calcExpiry(M),requiredNamespaces:{},optionalNamespaces:{},relay:{protocol:"irn"},pairingTopic:w,namespaces:i.buildNamespacesFromAuth([...new Set(ie)],[...new Set(me)]),transportType:n},await this.client.core.relayer.subscribe($,{transportType:n}),await this.client.session.set($,H),w&&await this.client.core.pairing.updateMetadata({topic:w,metadata:k.metadata}),H=this.client.session.get($)),(x=this.client.metadata.redirect)!=null&&x.linkMode&&(Ee=k.metadata.redirect)!=null&&Ee.linkMode&&(ye=k.metadata.redirect)!=null&&ye.universal&&e&&(this.client.core.addLinkModeSupportedApp(k.metadata.redirect.universal),this.client.session.update($,{transportType:h.TRANSPORT_TYPES.link_mode})),ge({auths:_e,session:H})};this.events.once(Y,j),this.events.once(ee,te);let se;try{if(r){const A=R.formatJsonRpcRequest("wc_sessionAuthenticate",D,U);this.client.core.history.set(w,A);const x=await this.client.core.crypto.encode("",A,{type:i.TYPE_2,encoding:i.BASE64URL});se=i.getLinkModeURL(e,w,x)}else await Promise.all([this.sendRequest({topic:w,method:"wc_sessionAuthenticate",params:D,expiry:t.expiry,throwOnFailedPublish:!0,clientRpcId:U}),this.sendRequest({topic:w,method:"wc_sessionPropose",params:O,expiry:q.wc_sessionPropose.req.ttl,throwOnFailedPublish:!0,clientRpcId:O.id})])}catch(A){throw this.events.off(Y,j),this.events.off(ee,te),A}return await this.setProposal(O.id,O),await this.setAuthRequest(U,{request:C(v({},D),{verifyContext:{}}),pairingTopic:w,transportType:n}),{uri:se??V,response:be}}),l(this,"approveSessionAuthenticate",async t=>{const{id:e,auths:s}=t,r=this.client.core.eventClient.createEvent({properties:{topic:e.toString(),trace:[h.EVENT_CLIENT_AUTHENTICATE_TRACES.authenticated_session_approve_started]}});try{this.isInitialized()}catch(y){throw r.setError(h.EVENT_CLIENT_AUTHENTICATE_ERRORS.no_internet_connection),y}const n=this.getPendingAuthRequest(e);if(!n)throw r.setError(h.EVENT_CLIENT_AUTHENTICATE_ERRORS.authenticated_session_pending_request_not_found),new Error(`Could not find pending auth request with id ${e}`);const o=n.transportType||h.TRANSPORT_TYPES.relay;o===h.TRANSPORT_TYPES.relay&&await this.confirmOnlineStateOrThrow();const c=n.requester.publicKey,p=await this.client.core.crypto.generateKeyPair(),d=i.hashKey(c),u={type:i.TYPE_1,receiverPublicKey:c,senderPublicKey:p},E=[],g=[];for(const y of s){if(!await i.validateSignedCacao({cacao:y,projectId:this.client.core.projectId})){r.setError(h.EVENT_CLIENT_AUTHENTICATE_ERRORS.invalid_cacao);const f=i.getSdkError("SESSION_SETTLEMENT_FAILED","Signature verification failed");throw await this.sendError({id:e,topic:d,error:f,encodeOpts:u}),new Error(f.message)}r.addTrace(h.EVENT_CLIENT_AUTHENTICATE_TRACES.cacaos_verified);const{p:T}=y,w=i.getRecapFromResources(T.resources),V=[i.getNamespacedDidChainId(T.iss)],L=i.getDidAddress(T.iss);if(w){const f=i.getMethodsFromRecap(w),P=i.getChainsFromRecap(w);E.push(...f),V.push(...P)}for(const f of V)g.push(`${f}:${L}`)}const m=await this.client.core.crypto.generateSharedKey(p,c);r.addTrace(h.EVENT_CLIENT_AUTHENTICATE_TRACES.create_authenticated_session_topic);let _;if(E?.length>0){_={topic:m,acknowledged:!0,self:{publicKey:p,metadata:this.client.metadata},peer:{publicKey:c,metadata:n.requester.metadata},controller:c,expiry:i.calcExpiry(M),authentication:s,requiredNamespaces:{},optionalNamespaces:{},relay:{protocol:"irn"},pairingTopic:n.pairingTopic,namespaces:i.buildNamespacesFromAuth([...new Set(E)],[...new Set(g)]),transportType:o},r.addTrace(h.EVENT_CLIENT_AUTHENTICATE_TRACES.subscribing_authenticated_session_topic);try{await this.client.core.relayer.subscribe(m,{transportType:o})}catch(y){throw r.setError(h.EVENT_CLIENT_AUTHENTICATE_ERRORS.subscribe_authenticated_session_topic_failure),y}r.addTrace(h.EVENT_CLIENT_AUTHENTICATE_TRACES.subscribe_authenticated_session_topic_success),await this.client.session.set(m,_),r.addTrace(h.EVENT_CLIENT_AUTHENTICATE_TRACES.store_authenticated_session),await this.client.core.pairing.updateMetadata({topic:n.pairingTopic,metadata:n.requester.metadata})}r.addTrace(h.EVENT_CLIENT_AUTHENTICATE_TRACES.publishing_authenticated_session_approve);try{await this.sendResult({topic:d,id:e,result:{cacaos:s,responder:{publicKey:p,metadata:this.client.metadata}},encodeOpts:u,throwOnFailedPublish:!0,appLink:this.getAppLinkIfEnabled(n.requester.metadata,o)})}catch(y){throw r.setError(h.EVENT_CLIENT_AUTHENTICATE_ERRORS.authenticated_session_approve_publish_failure),y}return await this.client.auth.requests.delete(e,{message:"fulfilled",code:0}),await this.client.core.pairing.activate({topic:n.pairingTopic}),this.client.core.eventClient.deleteEvent({eventId:r.eventId}),{session:_}}),l(this,"rejectSessionAuthenticate",async t=>{this.isInitialized();const{id:e,reason:s}=t,r=this.getPendingAuthRequest(e);if(!r)throw new Error(`Could not find pending auth request with id ${e}`);r.transportType===h.TRANSPORT_TYPES.relay&&await this.confirmOnlineStateOrThrow();const n=r.requester.publicKey,o=await this.client.core.crypto.generateKeyPair(),c=i.hashKey(n),p={type:i.TYPE_1,receiverPublicKey:n,senderPublicKey:o};await this.sendError({id:e,topic:c,error:s,encodeOpts:p,rpcOpts:q.wc_sessionAuthenticate.reject,appLink:this.getAppLinkIfEnabled(r.requester.metadata,r.transportType)}),await this.client.auth.requests.delete(e,{message:"rejected",code:0}),await this.deleteProposal(e)}),l(this,"formatAuthMessage",t=>{this.isInitialized();const{request:e,iss:s}=t;return i.formatMessage(e,s)}),l(this,"processRelayMessageCache",()=>{setTimeout(async()=>{if(this.relayMessageCache.length!==0)for(;this.relayMessageCache.length>0;)try{const t=this.relayMessageCache.shift();t&&await this.onRelayMessage(t)}catch(t){this.client.logger.error(t)}},50)}),l(this,"cleanupDuplicatePairings",async t=>{if(t.pairingTopic)try{const e=this.client.core.pairing.pairings.get(t.pairingTopic),s=this.client.core.pairing.pairings.getAll().filter(r=>{var n,o;return((n=r.peerMetadata)==null?void 0:n.url)&&((o=r.peerMetadata)==null?void 0:o.url)===t.peer.metadata.url&&r.topic&&r.topic!==e.topic});if(s.length===0)return;this.client.logger.info(`Cleaning up ${s.length} duplicate pairing(s)`),await Promise.all(s.map(r=>this.client.core.pairing.disconnect({topic:r.topic}))),this.client.logger.info("Duplicate pairings clean up finished")}catch(e){this.client.logger.error(e)}}),l(this,"deleteSession",async t=>{var e;const{topic:s,expirerHasDeleted:r=!1,emitEvent:n=!0,id:o=0}=t,{self:c}=this.client.session.get(s);await this.client.core.relayer.unsubscribe(s),await this.client.session.delete(s,i.getSdkError("USER_DISCONNECTED")),this.addToRecentlyDeleted(s,"session"),this.client.core.crypto.keychain.has(c.publicKey)&&await this.client.core.crypto.deleteKeyPair(c.publicKey),this.client.core.crypto.keychain.has(s)&&await this.client.core.crypto.deleteSymKey(s),r||this.client.core.expirer.del(s),this.client.core.storage.removeItem(pe).catch(p=>this.client.logger.warn(p)),this.getPendingSessionRequests().forEach(p=>{p.topic===s&&this.deletePendingSessionRequest(p.id,i.getSdkError("USER_DISCONNECTED"))}),s===((e=this.sessionRequestQueue.queue[0])==null?void 0:e.topic)&&(this.sessionRequestQueue.state=b.idle),n&&this.client.events.emit("session_delete",{id:o,topic:s})}),l(this,"deleteProposal",async(t,e)=>{if(e)try{const s=this.client.proposal.get(t),r=this.client.core.eventClient.getEvent({topic:s.pairingTopic});r?.setError(h.EVENT_CLIENT_SESSION_ERRORS.proposal_expired)}catch{}await Promise.all([this.client.proposal.delete(t,i.getSdkError("USER_DISCONNECTED")),e?Promise.resolve():this.client.core.expirer.del(t)]),this.addToRecentlyDeleted(t,"proposal")}),l(this,"deletePendingSessionRequest",async(t,e,s=!1)=>{await Promise.all([this.client.pendingRequest.delete(t,e),s?Promise.resolve():this.client.core.expirer.del(t)]),this.addToRecentlyDeleted(t,"request"),this.sessionRequestQueue.queue=this.sessionRequestQueue.queue.filter(r=>r.id!==t),s&&(this.sessionRequestQueue.state=b.idle,this.client.events.emit("session_request_expire",{id:t}))}),l(this,"deletePendingAuthRequest",async(t,e,s=!1)=>{await Promise.all([this.client.auth.requests.delete(t,e),s?Promise.resolve():this.client.core.expirer.del(t)])}),l(this,"setExpiry",async(t,e)=>{this.client.session.keys.includes(t)&&(this.client.core.expirer.set(t,e),await this.client.session.update(t,{expiry:e}))}),l(this,"setProposal",async(t,e)=>{this.client.core.expirer.set(t,i.calcExpiry(q.wc_sessionPropose.req.ttl)),await this.client.proposal.set(t,e)}),l(this,"setAuthRequest",async(t,e)=>{const{request:s,pairingTopic:r,transportType:n=h.TRANSPORT_TYPES.relay}=e;this.client.core.expirer.set(t,s.expiryTimestamp),await this.client.auth.requests.set(t,{authPayload:s.authPayload,requester:s.requester,expiryTimestamp:s.expiryTimestamp,id:t,pairingTopic:r,verifyContext:s.verifyContext,transportType:n})}),l(this,"setPendingSessionRequest",async t=>{const{id:e,topic:s,params:r,verifyContext:n}=t,o=r.request.expiryTimestamp||i.calcExpiry(q.wc_sessionRequest.req.ttl);this.client.core.expirer.set(e,o),await this.client.pendingRequest.set(e,{id:e,topic:s,params:r,verifyContext:n})}),l(this,"sendRequest",async t=>{const{topic:e,method:s,params:r,expiry:n,relayRpcId:o,clientRpcId:c,throwOnFailedPublish:p,appLink:d,tvf:u}=t,E=R.formatJsonRpcRequest(s,r,c);let g;const m=!!d;try{const T=m?i.BASE64URL:i.BASE64;g=await this.client.core.crypto.encode(e,E,{encoding:T})}catch(T){throw await this.cleanup(),this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${e} failed`),T}let _;if(Pe.includes(s)){const T=i.hashMessage(JSON.stringify(E)),w=i.hashMessage(g);_=await this.client.core.verify.register({id:w,decryptedId:T})}const y=q[s].req;if(y.attestation=_,n&&(y.ttl=n),o&&(y.id=o),this.client.core.history.set(e,E),m){const T=i.getLinkModeURL(d,e,g);await global.Linking.openURL(T,this.client.name)}else{const T=q[s].req;n&&(T.ttl=n),o&&(T.id=o),T.tvf=C(v({},u),{correlationId:E.id}),p?(T.internal=C(v({},T.internal),{throwOnFailedPublish:!0}),await this.client.core.relayer.publish(e,g,T)):this.client.core.relayer.publish(e,g,T).catch(w=>this.client.logger.error(w))}return E.id}),l(this,"sendResult",async t=>{const{id:e,topic:s,result:r,throwOnFailedPublish:n,encodeOpts:o,appLink:c}=t,p=R.formatJsonRpcResult(e,r);let d;const u=c&&typeof(global==null?void 0:global.Linking)<"u";try{const m=u?i.BASE64URL:i.BASE64;d=await this.client.core.crypto.encode(s,p,C(v({},o||{}),{encoding:m}))}catch(m){throw await this.cleanup(),this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${s} failed`),m}let E,g;try{E=await this.client.core.history.get(s,e);const m=E.request;try{g=this.getTVFParams(e,m.params,r)}catch(_){this.client.logger.warn(`sendResult() -> getTVFParams() failed: ${_?.message}`)}}catch(m){throw this.client.logger.error(`sendResult() -> history.get(${s}, ${e}) failed`),m}if(u){const m=i.getLinkModeURL(c,s,d);await global.Linking.openURL(m,this.client.name)}else{const m=E.request.method,_=q[m].res;_.tvf=C(v({},g),{correlationId:e}),n?(_.internal=C(v({},_.internal),{throwOnFailedPublish:!0}),await this.client.core.relayer.publish(s,d,_)):this.client.core.relayer.publish(s,d,_).catch(y=>this.client.logger.error(y))}await this.client.core.history.resolve(p)}),l(this,"sendError",async t=>{const{id:e,topic:s,error:r,encodeOpts:n,rpcOpts:o,appLink:c}=t,p=R.formatJsonRpcError(e,r);let d;const u=c&&typeof(global==null?void 0:global.Linking)<"u";try{const g=u?i.BASE64URL:i.BASE64;d=await this.client.core.crypto.encode(s,p,C(v({},n||{}),{encoding:g}))}catch(g){throw await this.cleanup(),this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${s} failed`),g}let E;try{E=await this.client.core.history.get(s,e)}catch(g){throw this.client.logger.error(`sendError() -> history.get(${s}, ${e}) failed`),g}if(u){const g=i.getLinkModeURL(c,s,d);await global.Linking.openURL(g,this.client.name)}else{const g=E.request.method,m=o||q[g].res;this.client.core.relayer.publish(s,d,m)}await this.client.core.history.resolve(p)}),l(this,"cleanup",async()=>{const t=[],e=[];this.client.session.getAll().forEach(s=>{let r=!1;i.isExpired(s.expiry)&&(r=!0),this.client.core.crypto.keychain.has(s.topic)||(r=!0),r&&t.push(s.topic)}),this.client.proposal.getAll().forEach(s=>{i.isExpired(s.expiryTimestamp)&&e.push(s.id)}),await Promise.all([...t.map(s=>this.deleteSession({topic:s})),...e.map(s=>this.deleteProposal(s))])}),l(this,"onProviderMessageEvent",async t=>{!this.initialized||this.relayMessageCache.length>0?this.relayMessageCache.push(t):await this.onRelayMessage(t)}),l(this,"onRelayEventRequest",async t=>{this.requestQueue.queue.push(t),await this.processRequestsQueue()}),l(this,"processRequestsQueue",async()=>{if(this.requestQueue.state===b.active){this.client.logger.info("Request queue already active, skipping...");return}for(this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`);this.requestQueue.queue.length>0;){this.requestQueue.state=b.active;const t=this.requestQueue.queue.shift();if(t)try{await this.processRequest(t)}catch(e){this.client.logger.warn(e)}}this.requestQueue.state=b.idle}),l(this,"processRequest",async t=>{const{topic:e,payload:s,attestation:r,transportType:n,encryptedId:o}=t,c=s.method;if(!this.shouldIgnorePairingRequest({topic:e,requestMethod:c}))switch(c){case"wc_sessionPropose":return await this.onSessionProposeRequest({topic:e,payload:s,attestation:r,encryptedId:o});case"wc_sessionSettle":return await this.onSessionSettleRequest(e,s);case"wc_sessionUpdate":return await this.onSessionUpdateRequest(e,s);case"wc_sessionExtend":return await this.onSessionExtendRequest(e,s);case"wc_sessionPing":return await this.onSessionPingRequest(e,s);case"wc_sessionDelete":return await this.onSessionDeleteRequest(e,s);case"wc_sessionRequest":return await this.onSessionRequest({topic:e,payload:s,attestation:r,encryptedId:o,transportType:n});case"wc_sessionEvent":return await this.onSessionEventRequest(e,s);case"wc_sessionAuthenticate":return await this.onSessionAuthenticateRequest({topic:e,payload:s,attestation:r,encryptedId:o,transportType:n});default:return this.client.logger.info(`Unsupported request method ${c}`)}}),l(this,"onRelayEventResponse",async t=>{const{topic:e,payload:s,transportType:r}=t,n=(await this.client.core.history.get(e,s.id)).request.method;switch(n){case"wc_sessionPropose":return this.onSessionProposeResponse(e,s,r);case"wc_sessionSettle":return this.onSessionSettleResponse(e,s);case"wc_sessionUpdate":return this.onSessionUpdateResponse(e,s);case"wc_sessionExtend":return this.onSessionExtendResponse(e,s);case"wc_sessionPing":return this.onSessionPingResponse(e,s);case"wc_sessionRequest":return this.onSessionRequestResponse(e,s);case"wc_sessionAuthenticate":return this.onSessionAuthenticateResponse(e,s);default:return this.client.logger.info(`Unsupported response method ${n}`)}}),l(this,"onRelayEventUnknownPayload",t=>{const{topic:e}=t,{message:s}=i.getInternalError("MISSING_OR_INVALID",`Decoded payload on topic ${e} is not identifiable as a JSON-RPC request or a response.`);throw new Error(s)}),l(this,"shouldIgnorePairingRequest",t=>{const{topic:e,requestMethod:s}=t,r=this.expectedPairingMethodMap.get(e);return!r||r.includes(s)?!1:!!(r.includes("wc_sessionAuthenticate")&&this.client.events.listenerCount("session_authenticate")>0)}),l(this,"onSessionProposeRequest",async t=>{const{topic:e,payload:s,attestation:r,encryptedId:n}=t,{params:o,id:c}=s;try{const p=this.client.core.eventClient.getEvent({topic:e});this.client.events.listenerCount("session_proposal")===0&&(console.warn("No listener for session_proposal event"),p?.setError(h.EVENT_CLIENT_PAIRING_ERRORS.proposal_listener_not_found)),this.isValidConnect(v({},s.params));const d=o.expiryTimestamp||i.calcExpiry(q.wc_sessionPropose.req.ttl),u=v({id:c,pairingTopic:e,expiryTimestamp:d,attestation:r,encryptedId:n},o);await this.setProposal(c,u);const E=await this.getVerifyContext({attestationId:r,hash:i.hashMessage(JSON.stringify(s)),encryptedId:n,metadata:u.proposer.metadata});p?.addTrace(h.EVENT_CLIENT_PAIRING_TRACES.emit_session_proposal),this.client.events.emit("session_proposal",{id:c,params:u,verifyContext:E})}catch(p){await this.sendError({id:c,topic:e,error:p,rpcOpts:q.wc_sessionPropose.autoReject}),this.client.logger.error(p)}}),l(this,"onSessionProposeResponse",async(t,e,s)=>{const{id:r}=e;if(R.isJsonRpcResult(e)){const{result:n}=e;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",result:n});const o=this.client.proposal.get(r);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",proposal:o});const c=o.proposer.publicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",selfPublicKey:c});const p=n.responderPublicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",peerPublicKey:p});const d=await this.client.core.crypto.generateSharedKey(c,p);this.pendingSessions.set(r,{sessionTopic:d,pairingTopic:t,proposalId:r,publicKey:c});const u=await this.client.core.relayer.subscribe(d,{transportType:s});this.client.logger.trace({type:"method",method:"onSessionProposeResponse",subscriptionId:u}),await this.client.core.pairing.activate({topic:t})}else if(R.isJsonRpcError(e)){await this.deleteProposal(r);const n=i.engineEvent("session_connect",r);if(this.events.listenerCount(n)===0)throw new Error(`emitting ${n} without any listeners, 954`);this.events.emit(n,{error:e.error})}}),l(this,"onSessionSettleRequest",async(t,e)=>{const{id:s,params:r}=e;try{this.isValidSessionSettleRequest(r);const{relay:n,controller:o,expiry:c,namespaces:p,sessionProperties:d,scopedProperties:u,sessionConfig:E}=e.params,g=[...this.pendingSessions.values()].find(y=>y.sessionTopic===t);if(!g)return this.client.logger.error(`Pending session not found for topic ${t}`);const m=this.client.proposal.get(g.proposalId),_=C(v(v(v({topic:t,relay:n,expiry:c,namespaces:p,acknowledged:!0,pairingTopic:g.pairingTopic,requiredNamespaces:m.requiredNamespaces,optionalNamespaces:m.optionalNamespaces,controller:o.publicKey,self:{publicKey:g.publicKey,metadata:this.client.metadata},peer:{publicKey:o.publicKey,metadata:o.metadata}},d&&{sessionProperties:d}),u&&{scopedProperties:u}),E&&{sessionConfig:E}),{transportType:h.TRANSPORT_TYPES.relay});await this.client.session.set(_.topic,_),await this.setExpiry(_.topic,_.expiry),await this.client.core.pairing.updateMetadata({topic:g.pairingTopic,metadata:_.peer.metadata}),this.client.events.emit("session_connect",{session:_}),this.events.emit(i.engineEvent("session_connect",g.proposalId),{session:_}),this.pendingSessions.delete(g.proposalId),this.deleteProposal(g.proposalId,!1),this.cleanupDuplicatePairings(_),await this.sendResult({id:e.id,topic:t,result:!0})}catch(n){await this.sendError({id:s,topic:t,error:n}),this.client.logger.error(n)}}),l(this,"onSessionSettleResponse",async(t,e)=>{const{id:s}=e;R.isJsonRpcResult(e)?(await this.client.session.update(t,{acknowledged:!0}),this.events.emit(i.engineEvent("session_approve",s),{})):R.isJsonRpcError(e)&&(await this.client.session.delete(t,i.getSdkError("USER_DISCONNECTED")),this.events.emit(i.engineEvent("session_approve",s),{error:e.error}))}),l(this,"onSessionUpdateRequest",async(t,e)=>{const{params:s,id:r}=e;try{const n=`${t}_session_update`,o=i.MemoryStore.get(n);if(o&&this.isRequestOutOfSync(o,r)){this.client.logger.warn(`Discarding out of sync request - ${r}`),this.sendError({id:r,topic:t,error:i.getSdkError("INVALID_UPDATE_REQUEST")});return}this.isValidUpdate(v({topic:t},s));try{i.MemoryStore.set(n,r),await this.client.session.update(t,{namespaces:s.namespaces}),await this.sendResult({id:r,topic:t,result:!0})}catch(c){throw i.MemoryStore.delete(n),c}this.client.events.emit("session_update",{id:r,topic:t,params:s})}catch(n){await this.sendError({id:r,topic:t,error:n}),this.client.logger.error(n)}}),l(this,"isRequestOutOfSync",(t,e)=>e.toString().slice(0,-3)<t.toString().slice(0,-3)),l(this,"onSessionUpdateResponse",(t,e)=>{const{id:s}=e,r=i.engineEvent("session_update",s);if(this.events.listenerCount(r)===0)throw new Error(`emitting ${r} without any listeners`);R.isJsonRpcResult(e)?this.events.emit(i.engineEvent("session_update",s),{}):R.isJsonRpcError(e)&&this.events.emit(i.engineEvent("session_update",s),{error:e.error})}),l(this,"onSessionExtendRequest",async(t,e)=>{const{id:s}=e;try{this.isValidExtend({topic:t}),await this.setExpiry(t,i.calcExpiry(M)),await this.sendResult({id:s,topic:t,result:!0}),this.client.events.emit("session_extend",{id:s,topic:t})}catch(r){await this.sendError({id:s,topic:t,error:r}),this.client.logger.error(r)}}),l(this,"onSessionExtendResponse",(t,e)=>{const{id:s}=e,r=i.engineEvent("session_extend",s);if(this.events.listenerCount(r)===0)throw new Error(`emitting ${r} without any listeners`);R.isJsonRpcResult(e)?this.events.emit(i.engineEvent("session_extend",s),{}):R.isJsonRpcError(e)&&this.events.emit(i.engineEvent("session_extend",s),{error:e.error})}),l(this,"onSessionPingRequest",async(t,e)=>{const{id:s}=e;try{this.isValidPing({topic:t}),await this.sendResult({id:s,topic:t,result:!0,throwOnFailedPublish:!0}),this.client.events.emit("session_ping",{id:s,topic:t})}catch(r){await this.sendError({id:s,topic:t,error:r}),this.client.logger.error(r)}}),l(this,"onSessionPingResponse",(t,e)=>{const{id:s}=e,r=i.engineEvent("session_ping",s);setTimeout(()=>{if(this.events.listenerCount(r)===0)throw new Error(`emitting ${r} without any listeners 2176`);R.isJsonRpcResult(e)?this.events.emit(i.engineEvent("session_ping",s),{}):R.isJsonRpcError(e)&&this.events.emit(i.engineEvent("session_ping",s),{error:e.error})},500)}),l(this,"onSessionDeleteRequest",async(t,e)=>{const{id:s}=e;try{this.isValidDisconnect({topic:t,reason:e.params}),Promise.all([new Promise(r=>{this.client.core.relayer.once(h.RELAYER_EVENTS.publish,async()=>{r(await this.deleteSession({topic:t,id:s}))})}),this.sendResult({id:s,topic:t,result:!0}),this.cleanupPendingSentRequestsForTopic({topic:t,error:i.getSdkError("USER_DISCONNECTED")})]).catch(r=>this.client.logger.error(r))}catch(r){this.client.logger.error(r)}}),l(this,"onSessionRequest",async t=>{var e,s,r;const{topic:n,payload:o,attestation:c,encryptedId:p,transportType:d}=t,{id:u,params:E}=o;try{await this.isValidRequest(v({topic:n},E));const g=this.client.session.get(n),m=await this.getVerifyContext({attestationId:c,hash:i.hashMessage(JSON.stringify(R.formatJsonRpcRequest("wc_sessionRequest",E,u))),encryptedId:p,metadata:g.peer.metadata,transportType:d}),_={id:u,topic:n,params:E,verifyContext:m};await this.setPendingSessionRequest(_),d===h.TRANSPORT_TYPES.link_mode&&(e=g.peer.metadata.redirect)!=null&&e.universal&&this.client.core.addLinkModeSupportedApp((s=g.peer.metadata.redirect)==null?void 0:s.universal),(r=this.client.signConfig)!=null&&r.disableRequestQueue?this.emitSessionRequest(_):(this.addSessionRequestToSessionRequestQueue(_),this.processSessionRequestQueue())}catch(g){await this.sendError({id:u,topic:n,error:g}),this.client.logger.error(g)}}),l(this,"onSessionRequestResponse",(t,e)=>{const{id:s}=e,r=i.engineEvent("session_request",s);if(this.events.listenerCount(r)===0)throw new Error(`emitting ${r} without any listeners`);R.isJsonRpcResult(e)?this.events.emit(i.engineEvent("session_request",s),{result:e.result}):R.isJsonRpcError(e)&&this.events.emit(i.engineEvent("session_request",s),{error:e.error})}),l(this,"onSessionEventRequest",async(t,e)=>{const{id:s,params:r}=e;try{const n=`${t}_session_event_${r.event.name}`,o=i.MemoryStore.get(n);if(o&&this.isRequestOutOfSync(o,s)){this.client.logger.info(`Discarding out of sync request - ${s}`);return}this.isValidEmit(v({topic:t},r)),this.client.events.emit("session_event",{id:s,topic:t,params:r}),i.MemoryStore.set(n,s)}catch(n){await this.sendError({id:s,topic:t,error:n}),this.client.logger.error(n)}}),l(this,"onSessionAuthenticateResponse",(t,e)=>{const{id:s}=e;this.client.logger.trace({type:"method",method:"onSessionAuthenticateResponse",topic:t,payload:e}),R.isJsonRpcResult(e)?this.events.emit(i.engineEvent("session_request",s),{result:e.result}):R.isJsonRpcError(e)&&this.events.emit(i.engineEvent("session_request",s),{error:e.error})}),l(this,"onSessionAuthenticateRequest",async t=>{var e;const{topic:s,payload:r,attestation:n,encryptedId:o,transportType:c}=t;try{const{requester:p,authPayload:d,expiryTimestamp:u}=r.params,E=await this.getVerifyContext({attestationId:n,hash:i.hashMessage(JSON.stringify(r)),encryptedId:o,metadata:p.metadata,transportType:c}),g={requester:p,pairingTopic:s,id:r.id,authPayload:d,verifyContext:E,expiryTimestamp:u};await this.setAuthRequest(r.id,{request:g,pairingTopic:s,transportType:c}),c===h.TRANSPORT_TYPES.link_mode&&(e=p.metadata.redirect)!=null&&e.universal&&this.client.core.addLinkModeSupportedApp(p.metadata.redirect.universal),this.client.events.emit("session_authenticate",{topic:s,params:r.params,id:r.id,verifyContext:E})}catch(p){this.client.logger.error(p);const d=r.params.requester.publicKey,u=await this.client.core.crypto.generateKeyPair(),E=this.getAppLinkIfEnabled(r.params.requester.metadata,c),g={type:i.TYPE_1,receiverPublicKey:d,senderPublicKey:u};await this.sendError({id:r.id,topic:s,error:p,encodeOpts:g,rpcOpts:q.wc_sessionAuthenticate.autoReject,appLink:E})}}),l(this,"addSessionRequestToSessionRequestQueue",t=>{this.sessionRequestQueue.queue.push(t)}),l(this,"cleanupAfterResponse",t=>{this.deletePendingSessionRequest(t.response.id,{message:"fulfilled",code:0}),setTimeout(()=>{this.sessionRequestQueue.state=b.idle,this.processSessionRequestQueue()},N.toMiliseconds(this.requestQueueDelay))}),l(this,"cleanupPendingSentRequestsForTopic",({topic:t,error:e})=>{const s=this.client.core.history.pending;s.length>0&&s.filter(r=>r.topic===t&&r.request.method==="wc_sessionRequest").forEach(r=>{const n=r.request.id,o=i.engineEvent("session_request",n);if(this.events.listenerCount(o)===0)throw new Error(`emitting ${o} without any listeners`);this.events.emit(i.engineEvent("session_request",r.request.id),{error:e})})}),l(this,"processSessionRequestQueue",()=>{if(this.sessionRequestQueue.state===b.active){this.client.logger.info("session request queue is already active.");return}const t=this.sessionRequestQueue.queue[0];if(!t){this.client.logger.info("session request queue is empty.");return}try{this.emitSessionRequest(t)}catch(e){this.client.logger.error(e)}}),l(this,"emitSessionRequest",t=>{if(this.emittedSessionRequests.has(t.id)){this.client.logger.warn({id:t.id},`Skipping emitting \`session_request\` event for duplicate request. id: ${t.id}`);return}this.sessionRequestQueue.state=b.active,this.emittedSessionRequests.add(t.id),this.client.events.emit("session_request",t)}),l(this,"onPairingCreated",t=>{if(t.methods&&this.expectedPairingMethodMap.set(t.topic,t.methods),t.active)return;const e=this.client.proposal.getAll().find(s=>s.pairingTopic===t.topic);e&&this.onSessionProposeRequest({topic:t.topic,payload:R.formatJsonRpcRequest("wc_sessionPropose",C(v({},e),{requiredNamespaces:e.requiredNamespaces,optionalNamespaces:e.optionalNamespaces,relays:e.relays,proposer:e.proposer,sessionProperties:e.sessionProperties,scopedProperties:e.scopedProperties}),e.id),attestation:e.attestation,encryptedId:e.encryptedId})}),l(this,"isValidConnect",async t=>{if(!i.isValidParams(t)){const{message:p}=i.getInternalError("MISSING_OR_INVALID",`connect() params: ${JSON.stringify(t)}`);throw new Error(p)}const{pairingTopic:e,requiredNamespaces:s,optionalNamespaces:r,sessionProperties:n,scopedProperties:o,relays:c}=t;if(i.isUndefined(e)||await this.isValidPairingTopic(e),!i.isValidRelays(c,!0)){const{message:p}=i.getInternalError("MISSING_OR_INVALID",`connect() relays: ${c}`);throw new Error(p)}if(!i.isUndefined(s)&&i.isValidObject(s)!==0){const p="requiredNamespaces are deprecated and are automatically assigned to optionalNamespaces";["fatal","error","silent"].includes(this.client.logger.level)?console.warn(p):this.client.logger.warn(p),this.validateNamespaces(s,"requiredNamespaces")}if(!i.isUndefined(r)&&i.isValidObject(r)!==0&&this.validateNamespaces(r,"optionalNamespaces"),i.isUndefined(n)||this.validateSessionProps(n,"sessionProperties"),!i.isUndefined(o)){this.validateSessionProps(o,"scopedProperties");const p=Object.keys(s||{}).concat(Object.keys(r||{}));if(!Object.keys(o).every(d=>p.includes(d.split(":")[0])))throw new Error(`Scoped properties must be a subset of required/optional namespaces, received: ${JSON.stringify(o)}, required/optional namespaces: ${JSON.stringify(p)}`)}}),l(this,"validateNamespaces",(t,e)=>{const s=i.isValidRequiredNamespaces(t,"connect()",e);if(s)throw new Error(s.message)}),l(this,"isValidApprove",async t=>{if(!i.isValidParams(t))throw new Error(i.getInternalError("MISSING_OR_INVALID",`approve() params: ${t}`).message);const{id:e,namespaces:s,relayProtocol:r,sessionProperties:n,scopedProperties:o}=t;this.checkRecentlyDeleted(e),await this.isValidProposalId(e);const c=this.client.proposal.get(e),p=i.isValidNamespaces(s,"approve()");if(p)throw new Error(p.message);const d=i.isConformingNamespaces(c.requiredNamespaces,s,"approve()");if(d)throw new Error(d.message);if(!i.isValidString(r,!0)){const{message:u}=i.getInternalError("MISSING_OR_INVALID",`approve() relayProtocol: ${r}`);throw new Error(u)}if(i.isUndefined(n)||this.validateSessionProps(n,"sessionProperties"),!i.isUndefined(o)){this.validateSessionProps(o,"scopedProperties");const u=new Set(Object.keys(s));if(!Object.keys(o).every(E=>u.has(E.split(":")[0])))throw new Error(`Scoped properties must be a subset of approved namespaces, received: ${JSON.stringify(o)}, approved namespaces: ${Array.from(u).join(", ")}`)}}),l(this,"isValidReject",async t=>{if(!i.isValidParams(t)){const{message:r}=i.getInternalError("MISSING_OR_INVALID",`reject() params: ${t}`);throw new Error(r)}const{id:e,reason:s}=t;if(this.checkRecentlyDeleted(e),await this.isValidProposalId(e),!i.isValidErrorReason(s)){const{message:r}=i.getInternalError("MISSING_OR_INVALID",`reject() reason: ${JSON.stringify(s)}`);throw new Error(r)}}),l(this,"isValidSessionSettleRequest",t=>{if(!i.isValidParams(t)){const{message:p}=i.getInternalError("MISSING_OR_INVALID",`onSessionSettleRequest() params: ${t}`);throw new Error(p)}const{relay:e,controller:s,namespaces:r,expiry:n}=t;if(!i.isValidRelay(e)){const{message:p}=i.getInternalError("MISSING_OR_INVALID","onSessionSettleRequest() relay protocol should be a string");throw new Error(p)}const o=i.isValidController(s,"onSessionSettleRequest()");if(o)throw new Error(o.message);const c=i.isValidNamespaces(r,"onSessionSettleRequest()");if(c)throw new Error(c.message);if(i.isExpired(n)){const{message:p}=i.getInternalError("EXPIRED","onSessionSettleRequest()");throw new Error(p)}}),l(this,"isValidUpdate",async t=>{if(!i.isValidParams(t)){const{message:c}=i.getInternalError("MISSING_OR_INVALID",`update() params: ${t}`);throw new Error(c)}const{topic:e,namespaces:s}=t;this.checkRecentlyDeleted(e),await this.isValidSessionTopic(e);const r=this.client.session.get(e),n=i.isValidNamespaces(s,"update()");if(n)throw new Error(n.message);const o=i.isConformingNamespaces(r.requiredNamespaces,s,"update()");if(o)throw new Error(o.message)}),l(this,"isValidExtend",async t=>{if(!i.isValidParams(t)){const{message:s}=i.getInternalError("MISSING_OR_INVALID",`extend() params: ${t}`);throw new Error(s)}const{topic:e}=t;this.checkRecentlyDeleted(e),await this.isValidSessionTopic(e)}),l(this,"isValidRequest",async t=>{if(!i.isValidParams(t)){const{message:c}=i.getInternalError("MISSING_OR_INVALID",`request() params: ${t}`);throw new Error(c)}const{topic:e,request:s,chainId:r,expiry:n}=t;this.checkRecentlyDeleted(e),await this.isValidSessionTopic(e);const{namespaces:o}=this.client.session.get(e);if(!i.isValidNamespacesChainId(o,r)){const{message:c}=i.getInternalError("MISSING_OR_INVALID",`request() chainId: ${r}`);throw new Error(c)}if(!i.isValidRequest(s)){const{message:c}=i.getInternalError("MISSING_OR_INVALID",`request() ${JSON.stringify(s)}`);throw new Error(c)}if(!i.isValidNamespacesRequest(o,r,s.method)){const{message:c}=i.getInternalError("MISSING_OR_INVALID",`request() method: ${s.method}`);throw new Error(c)}if(n&&!i.isValidRequestExpiry(n,z)){const{message:c}=i.getInternalError("MISSING_OR_INVALID",`request() expiry: ${n}. Expiry must be a number (in seconds) between ${z.min} and ${z.max}`);throw new Error(c)}}),l(this,"isValidRespond",async t=>{var e;if(!i.isValidParams(t)){const{message:n}=i.getInternalError("MISSING_OR_INVALID",`respond() params: ${t}`);throw new Error(n)}const{topic:s,response:r}=t;try{await this.isValidSessionTopic(s)}catch(n){throw(e=t?.response)!=null&&e.id&&this.cleanupAfterResponse(t),n}if(!i.isValidResponse(r)){const{message:n}=i.getInternalError("MISSING_OR_INVALID",`respond() response: ${JSON.stringify(r)}`);throw new Error(n)}}),l(this,"isValidPing",async t=>{if(!i.isValidParams(t)){const{message:s}=i.getInternalError("MISSING_OR_INVALID",`ping() params: ${t}`);throw new Error(s)}const{topic:e}=t;await this.isValidSessionOrPairingTopic(e)}),l(this,"isValidEmit",async t=>{if(!i.isValidParams(t)){const{message:o}=i.getInternalError("MISSING_OR_INVALID",`emit() params: ${t}`);throw new Error(o)}const{topic:e,event:s,chainId:r}=t;await this.isValidSessionTopic(e);const{namespaces:n}=this.client.session.get(e);if(!i.isValidNamespacesChainId(n,r)){const{message:o}=i.getInternalError("MISSING_OR_INVALID",`emit() chainId: ${r}`);throw new Error(o)}if(!i.isValidEvent(s)){const{message:o}=i.getInternalError("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(s)}`);throw new Error(o)}if(!i.isValidNamespacesEvent(n,r,s.name)){const{message:o}=i.getInternalError("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(s)}`);throw new Error(o)}}),l(this,"isValidDisconnect",async t=>{if(!i.isValidParams(t)){const{message:s}=i.getInternalError("MISSING_OR_INVALID",`disconnect() params: ${t}`);throw new Error(s)}const{topic:e}=t;await this.isValidSessionOrPairingTopic(e)}),l(this,"isValidAuthenticate",t=>{const{chains:e,uri:s,domain:r,nonce:n}=t;if(!Array.isArray(e)||e.length===0)throw new Error("chains is required and must be a non-empty array");if(!i.isValidString(s,!1))throw new Error("uri is required parameter");if(!i.isValidString(r,!1))throw new Error("domain is required parameter");if(!i.isValidString(n,!1))throw new Error("nonce is required parameter");if([...new Set(e.map(c=>i.parseChainId(c).namespace))].length>1)throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");const{namespace:o}=i.parseChainId(e[0]);if(o!=="eip155")throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.")}),l(this,"getVerifyContext",async t=>{const{attestationId:e,hash:s,encryptedId:r,metadata:n,transportType:o}=t,c={verified:{verifyUrl:n.verifyUrl||h.VERIFY_SERVER,validation:"UNKNOWN",origin:n.url||""}};try{if(o===h.TRANSPORT_TYPES.link_mode){const d=this.getAppLinkIfEnabled(n,o);return c.verified.validation=d&&new URL(d).origin===new URL(n.url).origin?"VALID":"INVALID",c}const p=await this.client.core.verify.resolve({attestationId:e,hash:s,encryptedId:r,verifyUrl:n.verifyUrl});p&&(c.verified.origin=p.origin,c.verified.isScam=p.isScam,c.verified.validation=p.origin===new URL(n.url).origin?"VALID":"INVALID")}catch(p){this.client.logger.warn(p)}return this.client.logger.debug(`Verify context: ${JSON.stringify(c)}`),c}),l(this,"validateSessionProps",(t,e)=>{Object.values(t).forEach((s,r)=>{if(s==null){const{message:n}=i.getInternalError("MISSING_OR_INVALID",`${e} must contain an existing value for each key. Received: ${s} for key ${Object.keys(t)[r]}`);throw new Error(n)}})}),l(this,"getPendingAuthRequest",t=>{const e=this.client.auth.requests.get(t);return typeof e=="object"?e:void 0}),l(this,"addToRecentlyDeleted",(t,e)=>{if(this.recentlyDeletedMap.set(t,e),this.recentlyDeletedMap.size>=this.recentlyDeletedLimit){let s=0;const r=this.recentlyDeletedLimit/2;for(const n of this.recentlyDeletedMap.keys()){if(s++>=r)break;this.recentlyDeletedMap.delete(n)}}}),l(this,"checkRecentlyDeleted",t=>{const e=this.recentlyDeletedMap.get(t);if(e){const{message:s}=i.getInternalError("MISSING_OR_INVALID",`Record was recently deleted - ${e}: ${t}`);throw new Error(s)}}),l(this,"isLinkModeEnabled",(t,e)=>{var s,r,n,o,c,p,d,u,E;return!t||e!==h.TRANSPORT_TYPES.link_mode?!1:((r=(s=this.client.metadata)==null?void 0:s.redirect)==null?void 0:r.linkMode)===!0&&((o=(n=this.client.metadata)==null?void 0:n.redirect)==null?void 0:o.universal)!==void 0&&((p=(c=this.client.metadata)==null?void 0:c.redirect)==null?void 0:p.universal)!==""&&((d=t?.redirect)==null?void 0:d.universal)!==void 0&&((u=t?.redirect)==null?void 0:u.universal)!==""&&((E=t?.redirect)==null?void 0:E.linkMode)===!0&&this.client.core.linkModeSupportedApps.includes(t.redirect.universal)&&typeof(global==null?void 0:global.Linking)<"u"}),l(this,"getAppLinkIfEnabled",(t,e)=>{var s;return this.isLinkModeEnabled(t,e)?(s=t?.redirect)==null?void 0:s.universal:void 0}),l(this,"handleLinkModeMessage",({url:t})=>{if(!t||!t.includes("wc_ev")||!t.includes("topic"))return;const e=i.getSearchParamFromURL(t,"topic")||"",s=decodeURIComponent(i.getSearchParamFromURL(t,"wc_ev")||""),r=this.client.session.keys.includes(e);r&&this.client.session.update(e,{transportType:h.TRANSPORT_TYPES.link_mode}),this.client.core.dispatchEnvelope({topic:e,message:s,sessionExists:r})}),l(this,"registerLinkModeListeners",async()=>{var t;if(i.isTestRun()||i.isReactNative()&&(t=this.client.metadata.redirect)!=null&&t.linkMode){const e=global==null?void 0:global.Linking;if(typeof e<"u"){e.addEventListener("url",this.handleLinkModeMessage,this.client.name);const s=await e.getInitialURL();s&&setTimeout(()=>{this.handleLinkModeMessage({url:s})},50)}}}),l(this,"getTVFParams",(t,e,s)=>{var r,n,o;if(!((r=e.request)!=null&&r.method))return{};const c={correlationId:t,rpcMethods:[e.request.method],chainId:e.chainId};try{const p=this.extractTxHashesFromResult(e.request,s);c.txHashes=p,c.contractAddresses=this.isValidContractData(e.request.params)?[(o=(n=e.request.params)==null?void 0:n[0])==null?void 0:o.to]:[]}catch(p){this.client.logger.warn("Error getting TVF params",p)}return c}),l(this,"isValidContractData",t=>{var e;if(!t)return!1;try{const s=t?.data||((e=t?.[0])==null?void 0:e.data);if(!s.startsWith("0x"))return!1;const r=s.slice(2);return/^[0-9a-fA-F]*$/.test(r)?r.length%2===0:!1}catch{}return!1}),l(this,"extractTxHashesFromResult",(t,e)=>{var s;try{if(!e)return[];const r=t.method,n=fe[r];if(r==="sui_signTransaction")return[i.getSuiDigest(e.transactionBytes)];if(r==="near_signTransaction")return[i.getNearTransactionIdFromSignedTransaction(e)];if(r==="near_signTransactions")return e.map(c=>i.getNearTransactionIdFromSignedTransaction(c));if(r==="xrpl_signTransactionFor"||r==="xrpl_signTransaction")return[(s=e.tx_json)==null?void 0:s.hash];if(r==="polkadot_signTransaction")return[i.buildSignedExtrinsicHash({transaction:t.params.transactionPayload,signature:e.signature})];if(r==="algo_signTxn")return i.isValidArray(e)?e.map(c=>i.getAlgorandTransactionId(c)):[i.getAlgorandTransactionId(e)];if(r==="cosmos_signDirect")return[i.getSignDirectHash(e)];if(typeof e=="string")return[e];const o=e[n.key];if(i.isValidArray(o))return r==="solana_signAllTransactions"?o.map(c=>i.extractSolanaTransactionId(c)):o;if(typeof o=="string")return[o]}catch(r){this.client.logger.warn("Error extracting tx hashes from result",r)}return[]})}async processPendingMessageEvents(){try{const a=this.client.session.keys,t=this.client.core.relayer.messages.getWithoutAck(a);for(const[e,s]of Object.entries(t))for(const r of s)try{await this.onProviderMessageEvent({topic:e,message:r,publishedAt:Date.now()})}catch{this.client.logger.warn(`Error processing pending message event for topic: ${e}, message: ${r}`)}}catch(a){this.client.logger.warn("processPendingMessageEvents failed",a)}}isInitialized(){if(!this.initialized){const{message:a}=i.getInternalError("NOT_INITIALIZED",this.name);throw new Error(a)}}async confirmOnlineStateOrThrow(){await this.client.core.relayer.confirmOnlineStateOrThrow()}registerRelayerEvents(){this.client.core.relayer.on(h.RELAYER_EVENTS.message,a=>{this.onProviderMessageEvent(a)})}async onRelayMessage(a){const{topic:t,message:e,attestation:s,transportType:r}=a,{publicKey:n}=this.client.auth.authKeys.keys.includes(G)?this.client.auth.authKeys.get(G):{responseTopic:void 0,publicKey:void 0};try{const o=await this.client.core.crypto.decode(t,e,{receiverPublicKey:n,encoding:r===h.TRANSPORT_TYPES.link_mode?i.BASE64URL:i.BASE64});R.isJsonRpcRequest(o)?(this.client.core.history.set(t,o),await this.onRelayEventRequest({topic:t,payload:o,attestation:s,transportType:r,encryptedId:i.hashMessage(e)})):R.isJsonRpcResponse(o)?(await this.client.core.history.resolve(o),await this.onRelayEventResponse({topic:t,payload:o,transportType:r}),this.client.core.history.delete(t,o.id)):await this.onRelayEventUnknownPayload({topic:t,payload:o,transportType:r}),await this.client.core.relayer.messages.ack(t,e)}catch(o){this.client.logger.error(o)}}registerExpirerEvents(){this.client.core.expirer.on(h.EXPIRER_EVENTS.expired,async a=>{const{topic:t,id:e}=i.parseExpirerTarget(a.target);if(e&&this.client.pendingRequest.keys.includes(e))return await this.deletePendingSessionRequest(e,i.getInternalError("EXPIRED"),!0);if(e&&this.client.auth.requests.keys.includes(e))return await this.deletePendingAuthRequest(e,i.getInternalError("EXPIRED"),!0);t?this.client.session.keys.includes(t)&&(await this.deleteSession({topic:t,expirerHasDeleted:!0}),this.client.events.emit("session_expire",{topic:t})):e&&(await this.deleteProposal(e,!0),this.client.events.emit("proposal_expire",{id:e}))})}registerPairingEvents(){this.client.core.pairing.events.on(h.PAIRING_EVENTS.create,a=>this.onPairingCreated(a)),this.client.core.pairing.events.on(h.PAIRING_EVENTS.delete,a=>{this.addToRecentlyDeleted(a.topic,"pairing")})}isValidPairingTopic(a){if(!i.isValidString(a,!1)){const{message:t}=i.getInternalError("MISSING_OR_INVALID",`pairing topic should be a string: ${a}`);throw new Error(t)}if(!this.client.core.pairing.pairings.keys.includes(a)){const{message:t}=i.getInternalError("NO_MATCHING_KEY",`pairing topic doesn't exist: ${a}`);throw new Error(t)}if(i.isExpired(this.client.core.pairing.pairings.get(a).expiry)){const{message:t}=i.getInternalError("EXPIRED",`pairing topic: ${a}`);throw new Error(t)}}async isValidSessionTopic(a){if(!i.isValidString(a,!1)){const{message:t}=i.getInternalError("MISSING_OR_INVALID",`session topic should be a string: ${a}`);throw new Error(t)}if(this.checkRecentlyDeleted(a),!this.client.session.keys.includes(a)){const{message:t}=i.getInternalError("NO_MATCHING_KEY",`session topic doesn't exist: ${a}`);throw new Error(t)}if(i.isExpired(this.client.session.get(a).expiry)){await this.deleteSession({topic:a});const{message:t}=i.getInternalError("EXPIRED",`session topic: ${a}`);throw new Error(t)}if(!this.client.core.crypto.keychain.has(a)){const{message:t}=i.getInternalError("MISSING_OR_INVALID",`session topic does not exist in keychain: ${a}`);throw await this.deleteSession({topic:a}),new Error(t)}}async isValidSessionOrPairingTopic(a){if(this.checkRecentlyDeleted(a),this.client.session.keys.includes(a))await this.isValidSessionTopic(a);else if(this.client.core.pairing.pairings.keys.includes(a))this.isValidPairingTopic(a);else if(i.isValidString(a,!1)){const{message:t}=i.getInternalError("NO_MATCHING_KEY",`session or pairing topic doesn't exist: ${a}`);throw new Error(t)}else{const{message:t}=i.getInternalError("MISSING_OR_INVALID",`session or pairing topic should be a string: ${a}`);throw new Error(t)}}async isValidProposalId(a){if(!i.isValidId(a)){const{message:t}=i.getInternalError("MISSING_OR_INVALID",`proposal id should be a number: ${a}`);throw new Error(t)}if(!this.client.proposal.keys.includes(a)){const{message:t}=i.getInternalError("NO_MATCHING_KEY",`proposal id doesn't exist: ${a}`);throw new Error(t)}if(i.isExpired(this.client.proposal.get(a).expiryTimestamp)){await this.deleteProposal(a);const{message:t}=i.getInternalError("EXPIRED",`proposal id: ${a}`);throw new Error(t)}}}class Ze extends h.Store{constructor(a,t){super(a,t,Re,Q),this.core=a,this.logger=t}}class xe extends h.Store{constructor(a,t){super(a,t,Ie,Q),this.core=a,this.logger=t}}class et extends h.Store{constructor(a,t){super(a,t,ve,Q,e=>e.id),this.core=a,this.logger=t}}class tt extends h.Store{constructor(a,t){super(a,t,Ae,F,()=>G),this.core=a,this.logger=t}}class st extends h.Store{constructor(a,t){super(a,t,Ce,F),this.core=a,this.logger=t}}class it extends h.Store{constructor(a,t){super(a,t,Ve,F,e=>e.id),this.core=a,this.logger=t}}var rt=Object.defineProperty,nt=(S,a,t)=>a in S?rt(S,a,{enumerable:!0,configurable:!0,writable:!0,value:t}):S[a]=t,ue=(S,a,t)=>nt(S,typeof a!="symbol"?a+"":a,t);class ot{constructor(a,t){this.core=a,this.logger=t,ue(this,"authKeys"),ue(this,"pairingTopics"),ue(this,"requests"),this.authKeys=new tt(this.core,this.logger),this.pairingTopics=new st(this.core,this.logger),this.requests=new it(this.core,this.logger)}async init(){await this.authKeys.init(),await this.pairingTopics.init(),await this.requests.init()}}var at=Object.defineProperty,ct=(S,a,t)=>a in S?at(S,a,{enumerable:!0,configurable:!0,writable:!0,value:t}):S[a]=t,I=(S,a,t)=>ct(S,typeof a!="symbol"?a+"":a,t);class B extends Se.ISignClient{constructor(a){super(a),I(this,"protocol",ae),I(this,"version",ce),I(this,"name",X.name),I(this,"metadata"),I(this,"core"),I(this,"logger"),I(this,"events",new Te.EventEmitter),I(this,"engine"),I(this,"session"),I(this,"proposal"),I(this,"pendingRequest"),I(this,"auth"),I(this,"signConfig"),I(this,"on",(e,s)=>this.events.on(e,s)),I(this,"once",(e,s)=>this.events.once(e,s)),I(this,"off",(e,s)=>this.events.off(e,s)),I(this,"removeListener",(e,s)=>this.events.removeListener(e,s)),I(this,"removeAllListeners",e=>this.events.removeAllListeners(e)),I(this,"connect",async e=>{try{return await this.engine.connect(e)}catch(s){throw this.logger.error(s.message),s}}),I(this,"pair",async e=>{try{return await this.engine.pair(e)}catch(s){throw this.logger.error(s.message),s}}),I(this,"approve",async e=>{try{return await this.engine.approve(e)}catch(s){throw this.logger.error(s.message),s}}),I(this,"reject",async e=>{try{return await this.engine.reject(e)}catch(s){throw this.logger.error(s.message),s}}),I(this,"update",async e=>{try{return await this.engine.update(e)}catch(s){throw this.logger.error(s.message),s}}),I(this,"extend",async e=>{try{return await this.engine.extend(e)}catch(s){throw this.logger.error(s.message),s}}),I(this,"request",async e=>{try{return await this.engine.request(e)}catch(s){throw this.logger.error(s.message),s}}),I(this,"respond",async e=>{try{return await this.engine.respond(e)}catch(s){throw this.logger.error(s.message),s}}),I(this,"ping",async e=>{try{return await this.engine.ping(e)}catch(s){throw this.logger.error(s.message),s}}),I(this,"emit",async e=>{try{return await this.engine.emit(e)}catch(s){throw this.logger.error(s.message),s}}),I(this,"disconnect",async e=>{try{return await this.engine.disconnect(e)}catch(s){throw this.logger.error(s.message),s}}),I(this,"find",e=>{try{return this.engine.find(e)}catch(s){throw this.logger.error(s.message),s}}),I(this,"getPendingSessionRequests",()=>{try{return this.engine.getPendingSessionRequests()}catch(e){throw this.logger.error(e.message),e}}),I(this,"authenticate",async(e,s)=>{try{return await this.engine.authenticate(e,s)}catch(r){throw this.logger.error(r.message),r}}),I(this,"formatAuthMessage",e=>{try{return this.engine.formatAuthMessage(e)}catch(s){throw this.logger.error(s.message),s}}),I(this,"approveSessionAuthenticate",async e=>{try{return await this.engine.approveSessionAuthenticate(e)}catch(s){throw this.logger.error(s.message),s}}),I(this,"rejectSessionAuthenticate",async e=>{try{return await this.engine.rejectSessionAuthenticate(e)}catch(s){throw this.logger.error(s.message),s}}),this.name=a?.name||X.name,this.metadata=i.populateAppMetadata(a?.metadata),this.signConfig=a?.signConfig;const t=typeof a?.logger<"u"&&typeof a?.logger!="string"?a.logger:J.pino(J.getDefaultLoggerOptions({level:a?.logger||X.logger}));this.core=a?.core||new h.Core(a),this.logger=J.generateChildLogger(t,this.name),this.session=new xe(this.core,this.logger),this.proposal=new Ze(this.core,this.logger),this.pendingRequest=new et(this.core,this.logger),this.engine=new We(this),this.auth=new ot(this.core,this.logger)}static async init(a){const t=new B(a);return await t.initialize(),t}get context(){return J.getLoggerContext(this.logger)}get pairing(){return this.core.pairing.pairings}async initialize(){this.logger.trace("Initialized");try{await this.core.start(),await this.session.init(),await this.proposal.init(),await this.pendingRequest.init(),await this.auth.init(),await this.engine.init(),this.logger.info("SignClient Initialization Success")}catch(a){throw this.logger.info("SignClient Initialization Failure"),this.logger.error(a.message),a}}}const lt=xe,pt=B;exports.AUTH_CONTEXT=qe,exports.AUTH_KEYS_CONTEXT=Ae,exports.AUTH_PAIRING_TOPIC_CONTEXT=Ce,exports.AUTH_PROTOCOL=Oe,exports.AUTH_PUBLIC_KEY_NAME=G,exports.AUTH_REQUEST_CONTEXT=Ve,exports.AUTH_STORAGE_PREFIX=F,exports.AUTH_VERSION=He,exports.ENGINE_CONTEXT=Ne,exports.ENGINE_QUEUE_STATES=b,exports.ENGINE_RPC_OPTS=q,exports.HISTORY_CONTEXT=Ge,exports.HISTORY_EVENTS=Fe,exports.HISTORY_STORAGE_VERSION=Ye,exports.METHODS_TO_VERIFY=Pe,exports.PROPOSAL_CONTEXT=Re,exports.PROPOSAL_EXPIRY=je,exports.PROPOSAL_EXPIRY_MESSAGE=he,exports.REQUEST_CONTEXT=ve,exports.SESSION_CONTEXT=Ie,exports.SESSION_EXPIRY=M,exports.SESSION_REQUEST_EXPIRY_BOUNDARIES=z,exports.SIGN_CLIENT_CONTEXT=le,exports.SIGN_CLIENT_DEFAULT=X,exports.SIGN_CLIENT_EVENTS=$e,exports.SIGN_CLIENT_PROTOCOL=ae,exports.SIGN_CLIENT_STORAGE_OPTIONS=Ke,exports.SIGN_CLIENT_STORAGE_PREFIX=Q,exports.SIGN_CLIENT_VERSION=ce,exports.SessionStore=lt,exports.SignClient=pt,exports.TVF_METHODS=fe,exports.WALLETCONNECT_DEEPLINK_CHOICE=pe,exports.default=B;
//# sourceMappingURL=index.cjs.js.map
