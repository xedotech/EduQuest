'use strict';

var _objectSpread = require('@babel/runtime/helpers/objectSpread2');
var core = require('@sentry/core');

const defaultPattern = /(private|key|secret|authorization|address|email|login_hint)+/i;
function isHex(s) {
  return /^(-0x|0x)?[0-9a-f]*$/i.test(s);
}
function redactInternalEventData(data, keyPattern = defaultPattern) {
  if (typeof data !== "object" || data === null) return data;
  const keys = Object.keys(data);
  for (const k of keys) {
    const v = data[k];
    if (typeof v === "string" && keyPattern.test(k)) data[k] = "***";else data[k] = redactInternalEventData(v, keyPattern);
  }
  return data;
}
function redactEventData(data, keyPattern = defaultPattern, maxDepth = 8) {
  const normalizedData = core.normalize(data, maxDepth);
  return redactInternalEventData(normalizedData, keyPattern);
}
function redactInternalBreadcrumbData(data) {
  let result = data;
  if (typeof data === "object") {
    result = _objectSpread({}, data);
  } else if (Array.isArray(data)) {
    // Workaround TypeScript limitation to map types between `data` and `result`
    result = [...data];
  } else {
    return data;
  }
  for (const k in data) {
    if (Object.prototype.hasOwnProperty.call(data, k)) {
      const v = data[k];
      if (typeof v === "string" && isHex(v)) {
        // Workaround TypeScript limitation to map types between `data` and `result`
        result[k] = "***";
      } else {
        try {
          result[k] = redactInternalBreadcrumbData(v);
        } catch {
          // We are not able to redact the value
          result[k] = "***";
        }
      }
    }
  }
  return result;
}
function redactBreadcrumbData(data, maxDepth = 8) {
  if (!data) return data;
  const normalizedData = core.normalize(data, maxDepth);
  return redactInternalBreadcrumbData(normalizedData);
}

exports.redactBreadcrumbData = redactBreadcrumbData;
exports.redactEventData = redactEventData;
