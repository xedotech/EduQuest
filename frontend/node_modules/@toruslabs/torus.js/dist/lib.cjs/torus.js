'use strict';

var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var constants = require('@toruslabs/constants');
var httpHelpers = require('@toruslabs/http-helpers');
var BN = require('bn.js');
var elliptic = require('elliptic');
var config = require('./config.js');
var common = require('./helpers/common.js');
var errorUtils = require('./helpers/errorUtils.js');
var keyUtils = require('./helpers/keyUtils.js');
var metadataUtils = require('./helpers/metadataUtils.js');
var nodeUtils = require('./helpers/nodeUtils.js');
require('loglevel');
var loglevel = require('./loglevel.js');

// Implement threshold logic wrappers around public APIs
// of Torus nodes to handle malicious node responses
class Torus {
  constructor({
    enableOneKey = false,
    clientId,
    network,
    serverTimeOffset = 0,
    allowHost,
    legacyMetadataHost,
    keyType = constants.KEY_TYPE.SECP256K1
  }) {
    // 86400 = 24 hour
    _defineProperty(this, "allowHost", void 0);
    _defineProperty(this, "serverTimeOffset", void 0);
    _defineProperty(this, "network", void 0);
    _defineProperty(this, "clientId", void 0);
    _defineProperty(this, "ec", void 0);
    _defineProperty(this, "enableOneKey", void 0);
    _defineProperty(this, "legacyMetadataHost", void 0);
    _defineProperty(this, "keyType", constants.KEY_TYPE.SECP256K1);
    if (!clientId) throw new Error("Please provide a valid clientId in constructor");
    if (!network) throw new Error("Please provide a valid network in constructor");
    if (keyType === constants.KEY_TYPE.ED25519 && constants.LEGACY_NETWORKS_ROUTE_MAP[network]) {
      throw new Error(`keyType: ${keyType} is not supported by ${network} network`);
    }
    this.keyType = keyType;
    this.ec = new elliptic.ec(this.keyType);
    this.serverTimeOffset = serverTimeOffset || 0; // ms
    this.network = network;
    this.clientId = clientId;
    this.allowHost = allowHost || `${constants.SIGNER_MAP[network]}/api/allow`;
    this.enableOneKey = enableOneKey;
    this.legacyMetadataHost = legacyMetadataHost || constants.METADATA_MAP[network];
  }
  static enableLogging(v = true) {
    if (v) {
      loglevel.enableAll();
      config.config.logRequestTracing = true;
    } else loglevel.disableAll();
  }
  static setAPIKey(apiKey) {
    httpHelpers.setAPIKey(apiKey);
  }
  static setEmbedHost(embedHost) {
    httpHelpers.setEmbedHost(embedHost);
  }
  static setSessionTime(sessionTime) {
    Torus.sessionTime = sessionTime;
  }
  static isGetOrSetNonceError(err) {
    return err instanceof errorUtils.GetOrSetNonceError;
  }
  static getPostboxKey(torusKey) {
    if (torusKey.metadata.typeOfUser === "v1") {
      return torusKey.finalKeyData.privKey || torusKey.postboxKeyData.privKey;
    }
    return torusKey.postboxKeyData.privKey;
  }
  async retrieveShares(params) {
    const {
      verifier,
      verifierParams,
      idToken,
      nodePubkeys,
      indexes,
      endpoints,
      useDkg,
      extraParams = {},
      checkCommitment = true
    } = params;
    if (nodePubkeys.length === 0) {
      throw new Error("nodePubkeys param is required");
    }
    if (nodePubkeys.length !== indexes.length) {
      throw new Error("nodePubkeys length must be same as indexes length");
    }
    if (nodePubkeys.length !== endpoints.length) {
      throw new Error("nodePubkeys length must be same as endpoints length");
    }
    // dkg is used by default only for secp256k1 keys,
    // for ed25519 keys import keys flows is the default
    let shouldUseDkg;
    if (typeof useDkg === "boolean") {
      if (useDkg === false && constants.LEGACY_NETWORKS_ROUTE_MAP[this.network]) {
        throw new Error(`useDkg cannot be false for legacy network; ${this.network}`);
      }
      shouldUseDkg = this.keyType === constants.KEY_TYPE.ED25519 ? false : useDkg;
    } else if (this.keyType === constants.KEY_TYPE.ED25519) {
      shouldUseDkg = false;
    } else {
      shouldUseDkg = true;
    }
    if (!shouldUseDkg && nodePubkeys.length === 0) {
      throw new Error("nodePubkeys param is required");
    }
    if (!extraParams.session_token_exp_second) {
      extraParams.session_token_exp_second = Torus.sessionTime;
    }
    return nodeUtils.retrieveOrImportShare({
      legacyMetadataHost: this.legacyMetadataHost,
      serverTimeOffset: this.serverTimeOffset,
      enableOneKey: this.enableOneKey,
      ecCurve: this.ec,
      keyType: this.keyType,
      allowHost: this.allowHost,
      network: this.network,
      clientId: this.clientId,
      endpoints,
      indexes,
      verifier,
      verifierParams,
      idToken,
      useDkg: shouldUseDkg,
      newImportedShares: [],
      overrideExistingKey: false,
      nodePubkeys,
      extraParams,
      checkCommitment
    });
  }
  async getPublicAddress(endpoints, torusNodePubs, {
    verifier,
    verifierId,
    extendedVerifierId,
    keyType
  }) {
    loglevel.info(torusNodePubs, {
      verifier,
      verifierId,
      extendedVerifierId
    });
    const localKeyType = keyType !== null && keyType !== void 0 ? keyType : this.keyType;
    return this.getNewPublicAddress(endpoints, {
      verifier,
      verifierId,
      extendedVerifierId,
      keyType: localKeyType
    }, this.enableOneKey);
  }
  async importPrivateKey(params) {
    const {
      nodeIndexes,
      newPrivateKey,
      verifier,
      verifierParams,
      idToken,
      nodePubkeys,
      endpoints,
      extraParams = {},
      checkCommitment = true
    } = params;
    if (constants.LEGACY_NETWORKS_ROUTE_MAP[this.network]) {
      throw new Error(`importPrivateKey is not supported by legacy network; ${this.network}`);
    }
    if (endpoints.length !== nodeIndexes.length) {
      throw new Error(`length of endpoints array must be same as length of nodeIndexes array`);
    }
    if (!extraParams.session_token_exp_second) {
      extraParams.session_token_exp_second = Torus.sessionTime;
    }
    let privKeyBuffer;
    if (this.keyType === constants.KEY_TYPE.SECP256K1) {
      privKeyBuffer = Buffer.from(newPrivateKey.padStart(64, "0"), "hex");
      if (privKeyBuffer.length !== 32) {
        throw new Error("Invalid private key length for given secp256k1 key");
      }
    }
    if (this.keyType === constants.KEY_TYPE.ED25519) {
      privKeyBuffer = Buffer.from(newPrivateKey.padStart(64, "0"), "hex");
      if (privKeyBuffer.length !== 32) {
        throw new Error("Invalid private key length for given ed25519 key");
      }
    }
    const sharesData = await keyUtils.generateShares(this.ec, this.keyType, this.serverTimeOffset, nodeIndexes, nodePubkeys, privKeyBuffer);
    if (this.keyType === constants.KEY_TYPE.ED25519) {
      const ed25519Key = keyUtils.getEd25519ExtendedPublicKey(privKeyBuffer);
      const ed25519PubKey = keyUtils.encodeEd25519Point(ed25519Key.point);
      const encodedPubKey = keyUtils.encodeEd25519Point(sharesData[0].final_user_point);
      const importedPubKey = Buffer.from(ed25519PubKey).toString("hex");
      const derivedPubKey = encodedPubKey.toString("hex");
      if (importedPubKey !== derivedPubKey) {
        throw new Error("invalid shares data for ed25519 key, public key is not matching after generating shares");
      }
    }
    return nodeUtils.retrieveOrImportShare({
      legacyMetadataHost: this.legacyMetadataHost,
      serverTimeOffset: this.serverTimeOffset,
      enableOneKey: this.enableOneKey,
      ecCurve: this.ec,
      keyType: this.keyType,
      allowHost: this.allowHost,
      network: this.network,
      clientId: this.clientId,
      endpoints,
      indexes: nodeIndexes,
      verifier,
      verifierParams,
      idToken,
      useDkg: false,
      overrideExistingKey: true,
      newImportedShares: sharesData,
      nodePubkeys,
      extraParams,
      checkCommitment
    });
  }
  /**
   * Note: use this function only for openlogin tkey account lookups.
   * this is a legacy function, use getPublicAddress instead for new networks
   */
  async getUserTypeAndAddress(endpoints, {
    verifier,
    verifierId,
    extendedVerifierId
  }) {
    return this.getNewPublicAddress(endpoints, {
      verifier,
      verifierId,
      extendedVerifierId
    }, true);
  }
  async getNewPublicAddress(endpoints, {
    verifier,
    verifierId,
    extendedVerifierId,
    keyType
  }, enableOneKey) {
    const localKeyType = keyType !== null && keyType !== void 0 ? keyType : this.keyType;
    const localEc = common.getKeyCurve(localKeyType);
    if (localKeyType === constants.KEY_TYPE.ED25519 && constants.LEGACY_NETWORKS_ROUTE_MAP[this.network]) {
      throw new Error(`keyType: ${keyType} is not supported by ${this.network} network`);
    }
    const keyAssignResult = await nodeUtils.GetPubKeyOrKeyAssign({
      endpoints,
      network: this.network,
      verifier,
      verifierId,
      keyType: localKeyType,
      extendedVerifierId
    });
    const {
      errorResult,
      keyResult,
      nodeIndexes = [],
      serverTimeOffset
    } = keyAssignResult;
    const finalServerTimeOffset = this.serverTimeOffset || serverTimeOffset;
    const {
      nonceResult
    } = keyAssignResult;
    if (errorResult && JSON.stringify(errorResult).toLowerCase().includes("verifier not supported")) {
      // change error msg
      throw new Error(`Verifier not supported. Check if you: \n
      1. Are on the right network (Torus testnet/mainnet) \n
      2. Have setup a verifier on dashboard.web3auth.io?`);
    }
    if (errorResult) {
      throw new Error(`node results do not match at first lookup ${JSON.stringify(keyResult || {})}, ${JSON.stringify(errorResult || {})}`);
    }
    if (!(keyResult !== null && keyResult !== void 0 && keyResult.keys)) {
      throw new Error(`node results do not match at final lookup ${JSON.stringify(keyResult || {})}, ${JSON.stringify(errorResult || {})}`);
    }
    // no need of nonce for extendedVerifierId (tss verifier id)
    if (!nonceResult && !extendedVerifierId && !constants.LEGACY_NETWORKS_ROUTE_MAP[this.network]) {
      throw new errorUtils.GetOrSetNonceError("metadata nonce is missing in share response");
    }
    const {
      pub_key_X: X,
      pub_key_Y: Y
    } = keyResult.keys[0];
    let pubNonce;
    const nonce = new BN((nonceResult === null || nonceResult === void 0 ? void 0 : nonceResult.nonce) || "0", 16);
    let oAuthPubKey;
    let finalPubKey;
    if (extendedVerifierId) {
      // for tss key no need to add pub nonce
      finalPubKey = localEc.keyFromPublic({
        x: X,
        y: Y
      }).getPublic();
      oAuthPubKey = finalPubKey;
    } else if (constants.LEGACY_NETWORKS_ROUTE_MAP[this.network]) {
      return this.formatLegacyPublicKeyData({
        isNewKey: keyResult.is_new_key,
        enableOneKey,
        finalKeyResult: {
          keys: keyResult.keys
        },
        serverTimeOffset: finalServerTimeOffset
      });
    } else {
      const v2NonceResult = nonceResult;
      oAuthPubKey = localEc.keyFromPublic({
        x: X,
        y: Y
      }).getPublic();
      finalPubKey = localEc.keyFromPublic({
        x: X,
        y: Y
      }).getPublic().add(localEc.keyFromPublic({
        x: v2NonceResult.pubNonce.x,
        y: v2NonceResult.pubNonce.y
      }).getPublic());
      pubNonce = {
        X: v2NonceResult.pubNonce.x,
        Y: v2NonceResult.pubNonce.y
      };
    }
    if (!oAuthPubKey) {
      throw new Error("Unable to derive oAuthPubKey");
    }
    const oAuthX = oAuthPubKey.getX().toString(16, 64);
    const oAuthY = oAuthPubKey.getY().toString(16, 64);
    const oAuthAddress = keyUtils.generateAddressFromPubKey(localKeyType, oAuthPubKey.getX(), oAuthPubKey.getY());
    if (!finalPubKey) {
      throw new Error("Unable to derive finalPubKey");
    }
    const finalX = finalPubKey ? finalPubKey.getX().toString(16, 64) : "";
    const finalY = finalPubKey ? finalPubKey.getY().toString(16, 64) : "";
    const finalAddress = finalPubKey ? keyUtils.generateAddressFromPubKey(localKeyType, finalPubKey.getX(), finalPubKey.getY()) : "";
    return {
      oAuthKeyData: {
        walletAddress: oAuthAddress,
        X: oAuthX,
        Y: oAuthY
      },
      finalKeyData: {
        walletAddress: finalAddress,
        X: finalX,
        Y: finalY
      },
      metadata: {
        pubNonce,
        nonce,
        upgraded: (nonceResult === null || nonceResult === void 0 ? void 0 : nonceResult.upgraded) || false,
        typeOfUser: "v2",
        serverTimeOffset: finalServerTimeOffset
      },
      nodesData: {
        nodeIndexes
      }
    };
  }
  async formatLegacyPublicKeyData(params) {
    var _nonceResult;
    const {
      finalKeyResult,
      enableOneKey,
      isNewKey,
      serverTimeOffset,
      keyType
    } = params;
    const localKeyType = keyType !== null && keyType !== void 0 ? keyType : this.keyType;
    const localEc = common.getKeyCurve(localKeyType);
    const {
      pub_key_X: X,
      pub_key_Y: Y
    } = finalKeyResult.keys[0];
    let nonceResult;
    let nonce;
    let finalPubKey;
    let typeOfUser;
    let pubNonce;
    const oAuthPubKey = localEc.keyFromPublic({
      x: X,
      y: Y
    }).getPublic();
    const finalServerTimeOffset = this.serverTimeOffset || serverTimeOffset;
    if (enableOneKey) {
      try {
        nonceResult = await metadataUtils.getOrSetNonce(this.legacyMetadataHost, localEc, finalServerTimeOffset, X, Y, undefined, !isNewKey);
        nonce = new BN(nonceResult.nonce || "0", 16);
        typeOfUser = nonceResult.typeOfUser;
      } catch {
        throw new errorUtils.GetOrSetNonceError();
      }
      if (nonceResult.typeOfUser === "v1") {
        nonce = await metadataUtils.getMetadata(this.legacyMetadataHost, {
          pub_key_X: X,
          pub_key_Y: Y
        });
        finalPubKey = localEc.keyFromPublic({
          x: X,
          y: Y
        }).getPublic().add(localEc.keyFromPrivate(nonce.toString(16, 64), "hex").getPublic());
      } else if (nonceResult.typeOfUser === "v2") {
        finalPubKey = localEc.keyFromPublic({
          x: X,
          y: Y
        }).getPublic().add(localEc.keyFromPublic({
          x: nonceResult.pubNonce.x,
          y: nonceResult.pubNonce.y
        }).getPublic());
        pubNonce = {
          X: nonceResult.pubNonce.x,
          Y: nonceResult.pubNonce.y
        };
      } else {
        throw new Error("getOrSetNonce should always return typeOfUser.");
      }
    } else {
      typeOfUser = "v1";
      nonce = await metadataUtils.getMetadata(this.legacyMetadataHost, {
        pub_key_X: X,
        pub_key_Y: Y
      });
      finalPubKey = localEc.keyFromPublic({
        x: X,
        y: Y
      }).getPublic().add(localEc.keyFromPrivate(nonce.toString(16, 64), "hex").getPublic());
    }
    if (!oAuthPubKey) {
      throw new Error("Unable to derive oAuthPubKey");
    }
    const oAuthX = oAuthPubKey.getX().toString(16, 64);
    const oAuthY = oAuthPubKey.getY().toString(16, 64);
    const oAuthAddress = keyUtils.generateAddressFromPubKey(localKeyType, oAuthPubKey.getX(), oAuthPubKey.getY());
    if (typeOfUser === "v2" && !finalPubKey) {
      throw new Error("Unable to derive finalPubKey");
    }
    const finalX = finalPubKey ? finalPubKey.getX().toString(16, 64) : "";
    const finalY = finalPubKey ? finalPubKey.getY().toString(16, 64) : "";
    const finalAddress = finalPubKey ? keyUtils.generateAddressFromPubKey(localKeyType, finalPubKey.getX(), finalPubKey.getY()) : "";
    return {
      oAuthKeyData: {
        walletAddress: oAuthAddress,
        X: oAuthX,
        Y: oAuthY
      },
      finalKeyData: {
        walletAddress: finalAddress,
        X: finalX,
        Y: finalY
      },
      metadata: {
        pubNonce,
        nonce,
        upgraded: ((_nonceResult = nonceResult) === null || _nonceResult === void 0 ? void 0 : _nonceResult.upgraded) || false,
        typeOfUser,
        serverTimeOffset: finalServerTimeOffset
      },
      nodesData: {
        nodeIndexes: []
      }
    };
  }
}
_defineProperty(Torus, "sessionTime", 86400);

module.exports = Torus;
