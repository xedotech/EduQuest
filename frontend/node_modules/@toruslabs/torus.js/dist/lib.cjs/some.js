'use strict';

var _defineProperty = require('@babel/runtime/helpers/defineProperty');

/* eslint-disable promise/catch-or-return */
function capitalizeFirstLetter(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
class SomeError extends Error {
  constructor({
    errors,
    responses,
    predicate
  }) {
    // its fine to log responses in errors logs for better debugging,
    // as data is always encrypted with temp key
    // temp key should not be logged anywhere
    const message = `Unable to resolve enough promises. 
      errors: ${errors.map(x => (x === null || x === void 0 ? void 0 : x.message) || x).join(", ")}, 
      predicate error: ${predicate},
      ${responses.length} responses,
      responses: ${JSON.stringify(responses)}`;
    super(message);
    _defineProperty(this, "errors", void 0);
    _defineProperty(this, "responses", void 0);
    _defineProperty(this, "predicate", void 0);
    this.errors = errors;
    this.responses = responses;
    this.predicate = predicate;
  }
  get message() {
    return `${super.message}. errors: ${this.errors.map(x => (x === null || x === void 0 ? void 0 : x.message) || x).join(", ")} and ${this.responses.length} responses: ${JSON.stringify(this.responses)},
      predicate error: ${this.predicate}`;
  }
  toString() {
    return this.message;
  }
}
const Some = (promises, predicate) => new Promise((resolve, reject) => {
  let finishedCount = 0;
  const sharedState = {
    resolved: false
  };
  const errorArr = new Array(promises.length).fill(undefined);
  const resultArr = new Array(promises.length).fill(undefined);
  let predicateError;
  promises.forEach((x, index) => {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    x.then(resp => {
      resultArr[index] = resp;
      return undefined;
    }).catch(error => {
      errorArr[index] = error;
    })
    // eslint-disable-next-line promise/no-return-in-finally
    .finally(() => {
      if (sharedState.resolved) return;
      return predicate(resultArr.slice(0), sharedState)
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      .then(data => {
        sharedState.resolved = true;
        resolve(data);
        return undefined;
      }).catch(error => {
        // log only the last predicate error
        predicateError = error;
      }).finally(() => {
        finishedCount += 1;
        if (finishedCount === promises.length) {
          const errors = Object.values(resultArr.reduce((acc, z) => {
            if (z) {
              var _error$data;
              const {
                id,
                error
              } = z;
              if ((error === null || error === void 0 || (_error$data = error.data) === null || _error$data === void 0 ? void 0 : _error$data.length) > 0) {
                if (error.data.startsWith("Error occurred while verifying params")) acc[id] = capitalizeFirstLetter(error.data);else acc[id] = error.data;
              }
            }
            return acc;
          }, {}));
          if (errors.length > 0) {
            // Format-able errors
            const msg = errors.length > 1 ? `\n${errors.map(it => `â€¢ ${it}`).join("\n")}` : errors[0];
            reject(new Error(msg));
          } else {
            var _predicateError;
            reject(new SomeError({
              errors: errorArr,
              responses: resultArr,
              predicate: ((_predicateError = predicateError) === null || _predicateError === void 0 ? void 0 : _predicateError.message) || predicateError
            }));
          }
        }
      });
    });
  });
});

exports.Some = Some;
exports.SomeError = SomeError;
