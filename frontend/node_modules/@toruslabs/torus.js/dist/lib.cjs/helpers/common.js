'use strict';

var constants = require('@toruslabs/constants');
var BN = require('bn.js');
var elliptic = require('elliptic');
var keccak = require('ethereum-cryptography/keccak');
var stringify = require('json-stable-stringify');

function keccak256(a) {
  const hash = Buffer.from(keccak.keccak256(a)).toString("hex");
  return `0x${hash}`;
}
const generatePrivateKey = (ecCurve, buf) => {
  return ecCurve.genKeyPair().getPrivate().toArrayLike(buf);
};
let secp256k1EC;
let ed25519EC;
const getKeyCurve = keyType => {
  if (keyType === constants.KEY_TYPE.SECP256K1) {
    if (!secp256k1EC) secp256k1EC = new elliptic.ec("secp256k1");
    return secp256k1EC;
  } else if (keyType === constants.KEY_TYPE.ED25519) {
    if (!ed25519EC) ed25519EC = new elliptic.ec("ed25519");
    return ed25519EC;
  }
  throw new Error(`Invalid keyType: ${keyType}`);
};
// this function normalizes the result from nodes before passing the result to threshold check function
// For ex: some fields returns by nodes might be different from each other
// like created_at field might vary and nonce_data might not be returned by all nodes because
// of the metadata implementation in sapphire.
const normalizeKeysResult = result => {
  const finalResult = {
    keys: [],
    is_new_key: result.is_new_key
  };
  if (result && result.keys && result.keys.length > 0) {
    const finalKey = result.keys[0];
    finalResult.keys = [{
      pub_key_X: finalKey.pub_key_X,
      pub_key_Y: finalKey.pub_key_Y,
      address: finalKey.address
    }];
  }
  return finalResult;
};
const normalizeLookUpResult = result => {
  const finalResult = {
    keys: []
  };
  if (result && result.keys && result.keys.length > 0) {
    const finalKey = result.keys[0];
    finalResult.keys = [{
      pub_key_X: finalKey.pub_key_X,
      pub_key_Y: finalKey.pub_key_Y,
      address: finalKey.address
    }];
  }
  return finalResult;
};
const kCombinations = (s, k) => {
  let set = s;
  if (typeof set === "number") {
    set = Array.from({
      length: set
    }, (_, i) => i);
  }
  if (k > set.length || k <= 0) {
    return [];
  }
  if (k === set.length) {
    return [set];
  }
  if (k === 1) {
    return set.reduce((acc, cur) => [...acc, [cur]], []);
  }
  const combs = [];
  let tailCombs = [];
  for (let i = 0; i <= set.length - k + 1; i += 1) {
    tailCombs = kCombinations(set.slice(i + 1), k - 1);
    for (let j = 0; j < tailCombs.length; j += 1) {
      combs.push([set[i], ...tailCombs[j]]);
    }
  }
  return combs;
};
const thresholdSame = (arr, t) => {
  const hashMap = {};
  for (let i = 0; i < arr.length; i += 1) {
    const str = stringify(arr[i]);
    hashMap[str] = hashMap[str] ? hashMap[str] + 1 : 1;
    if (hashMap[str] === t) {
      return arr[i];
    }
  }
  return undefined;
};
function encParamsBufToHex(encParams) {
  return {
    iv: Buffer.from(encParams.iv).toString("hex"),
    ephemPublicKey: Buffer.from(encParams.ephemPublicKey).toString("hex"),
    ciphertext: Buffer.from(encParams.ciphertext).toString("hex"),
    mac: Buffer.from(encParams.mac).toString("hex"),
    mode: "AES256"
  };
}
function encParamsHexToBuf(eciesData) {
  return {
    ephemPublicKey: Buffer.from(eciesData.ephemPublicKey, "hex"),
    iv: Buffer.from(eciesData.iv, "hex"),
    mac: Buffer.from(eciesData.mac, "hex")
  };
}
function getProxyCoordinatorEndpointIndex(endpoints, verifier, verifierId) {
  const verifierIdStr = `${verifier}${verifierId}`;
  const hashedVerifierId = keccak256(Buffer.from(verifierIdStr, "utf8")).slice(2);
  const proxyEndpointNum = new BN.BN(hashedVerifierId, "hex").mod(new BN.BN(endpoints.length)).toNumber();
  return proxyEndpointNum;
}
function calculateMedian(arr) {
  const arrSize = arr.length;
  if (arrSize === 0) return 0;
  const sortedArr = arr.sort(function (a, b) {
    return a - b;
  });
  // odd length
  if (arrSize % 2 !== 0) {
    return sortedArr[Math.floor(arrSize / 2)];
  }
  // return average of two mid values in case of even arrSize
  const mid1 = sortedArr[arrSize / 2 - 1];
  const mid2 = sortedArr[arrSize / 2];
  return (mid1 + mid2) / 2;
}
function waitFor(milliseconds) {
  return new Promise((resolve, reject) => {
    // hack to bypass eslint warning.
    if (milliseconds > 0) {
      setTimeout(resolve, milliseconds);
    } else {
      reject(new Error("value of milliseconds must be greater than 0"));
    }
  });
}
function retryCommitment(executionPromise, maxRetries) {
  // Notice that we declare an inner function here
  // so we can encapsulate the retries and don't expose
  // it to the caller. This is also a recursive function
  async function retryWithBackoff(retries) {
    try {
      // we don't wait on the first attempt
      if (retries > 0) {
        // on every retry, we exponentially increase the time to wait.
        // Here is how it looks for a `maxRetries` = 4
        // (2 ** 1) * 100 = 200 ms
        // (2 ** 2) * 100 = 400 ms
        // (2 ** 3) * 100 = 800 ms
        const timeToWait = 2 ** retries * 100;
        await waitFor(timeToWait);
      }
      const a = await executionPromise();
      return a;
    } catch (e) {
      const errorMsg = e.message;
      const acceptedErrorMsgs = [
      // Slow node
      "Timed out", "Failed to fetch", "fetch failed", "Load failed", "cancelled", "NetworkError when attempting to fetch resource.",
      // Happens when the node is not reachable (dns issue etc)
      "TypeError: Failed to fetch",
      // All except iOS and Firefox
      "TypeError: cancelled",
      // iOS
      "TypeError: NetworkError when attempting to fetch resource." // Firefox
      ];
      if (retries < maxRetries && (acceptedErrorMsgs.includes(errorMsg) || errorMsg && errorMsg.includes("reason: getaddrinfo EAI_AGAIN"))) {
        // only retry if we didn't reach the limit
        // otherwise, let the caller handle the error
        return retryWithBackoff(retries + 1);
      }
      throw e;
    }
  }
  return retryWithBackoff(0);
}

exports.calculateMedian = calculateMedian;
exports.encParamsBufToHex = encParamsBufToHex;
exports.encParamsHexToBuf = encParamsHexToBuf;
exports.generatePrivateKey = generatePrivateKey;
exports.getKeyCurve = getKeyCurve;
exports.getProxyCoordinatorEndpointIndex = getProxyCoordinatorEndpointIndex;
exports.kCombinations = kCombinations;
exports.keccak256 = keccak256;
exports.normalizeKeysResult = normalizeKeysResult;
exports.normalizeLookUpResult = normalizeLookUpResult;
exports.retryCommitment = retryCommitment;
exports.thresholdSame = thresholdSame;
exports.waitFor = waitFor;
