import { KEY_TYPE } from '@toruslabs/constants';
import { post, generateJsonRPCObject } from '@toruslabs/http-helpers';
import log from 'loglevel';
import { JRPC_METHODS } from '../constants.js';
import { Some } from '../some.js';
import { thresholdSame, normalizeKeysResult } from './common.js';

// Note: Endpoints should be the sss node endpoints along with path

// for ex: [https://node-1.node.web3auth.io/sss/jrpc, https://node-2.node.web3auth.io/sss/jrpc ....]
const GetOrSetTssDKGPubKey = async params => {
  const {
    endpoints,
    verifier,
    verifierId,
    tssVerifierId,
    keyType = KEY_TYPE.SECP256K1
  } = params;
  const minThreshold = ~~(endpoints.length / 2) + 1;
  const lookupPromises = endpoints.map(x => post(x, generateJsonRPCObject(JRPC_METHODS.GET_OR_SET_KEY, {
    distributed_metadata: true,
    verifier,
    verifier_id: verifierId,
    extended_verifier_id: tssVerifierId,
    one_key_flow: true,
    key_type: keyType,
    fetch_node_index: true,
    client_time: Math.floor(Date.now() / 1000).toString()
  }), {}, {
    logTracingHeader: false
  }).catch(err => log.error(`${JRPC_METHODS.GET_OR_SET_KEY} request failed`, err)));
  const nodeIndexes = [];
  const result = await Some(lookupPromises, async lookupResults => {
    const lookupPubKeys = lookupResults.filter(x1 => {
      if (x1 && !x1.error) {
        return x1;
      }
      return false;
    });
    const errorResult = thresholdSame(lookupResults.map(x2 => x2 && x2.error), minThreshold);
    const keyResult = thresholdSame(lookupPubKeys.map(x3 => x3 && normalizeKeysResult(x3.result)), minThreshold);
    if (keyResult || errorResult) {
      if (keyResult) {
        lookupResults.forEach(x1 => {
          if (x1 && x1.result) {
            const currentNodePubKey = x1.result.keys[0].pub_key_X.toLowerCase();
            const thresholdPubKey = keyResult.keys[0].pub_key_X.toLowerCase();
            // push only those indexes for nodes who are returning pub key matching with threshold pub key.
            // this check is important when different nodes have different keys assigned to a user.
            if (currentNodePubKey === thresholdPubKey) {
              const nodeIndex = Number.parseInt(x1.result.node_index);
              if (nodeIndex) nodeIndexes.push(nodeIndex);
            }
          }
        });
      }
      return Promise.resolve({
        keyResult,
        nodeIndexes,
        errorResult
      });
    }
    return Promise.reject(new Error(`invalid public key result: ${JSON.stringify(lookupResults)} for tssVerifierId: ${tssVerifierId} `));
  });
  if (result.errorResult) {
    throw new Error(`invalid public key result,errorResult: ${JSON.stringify(result.errorResult)}`);
  }
  const key = result.keyResult.keys[0];
  return {
    key: {
      pubKeyX: key.pub_key_X,
      pubKeyY: key.pub_key_Y,
      address: key.address,
      createdAt: key.created_at
    },
    nodeIndexes: result.nodeIndexes,
    isNewKey: result.keyResult.is_new_key
  };
};

export { GetOrSetTssDKGPubKey };
