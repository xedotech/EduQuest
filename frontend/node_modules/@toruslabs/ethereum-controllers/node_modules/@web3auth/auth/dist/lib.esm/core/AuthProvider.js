import _defineProperty from '@babel/runtime/helpers/defineProperty';
import { randomId } from '@toruslabs/customauth';
import { IFRAME_MODAL_ID, JRPC_METHODS } from '../utils/constants.js';
import { THEME_MODES } from '../utils/interfaces.js';
import { log } from '../utils/logger.js';
import { htmlToElement } from '../utils/utils.js';

const authServiceIframeMap = new Map();
function getTheme(theme) {
  if (theme === THEME_MODES.light) return "light";
  if (theme === THEME_MODES.dark) return "dark";
  return window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
}
class AuthProvider {
  constructor({
    sdkUrl,
    whiteLabel
  }) {
    _defineProperty(this, "sdkUrl", void 0);
    _defineProperty(this, "whiteLabel", void 0);
    _defineProperty(this, "initialized", false);
    _defineProperty(this, "loginCallbackSuccess", null);
    _defineProperty(this, "loginCallbackFailed", null);
    _defineProperty(this, "embedNonce", randomId());
    this.sdkUrl = sdkUrl;
    this.whiteLabel = whiteLabel;
  }
  get targetOrigin() {
    return new URL(this.sdkUrl).origin;
  }
  getAuthServiceIframe() {
    return authServiceIframeMap.get(this.embedNonce);
  }
  registerAuthServiceIframe(iframe) {
    authServiceIframeMap.set(this.embedNonce, iframe);
  }
  cleanup() {
    const iframe = authServiceIframeMap.get(this.embedNonce);
    if (iframe && iframe.parentNode) {
      iframe.parentNode.removeChild(iframe);
      authServiceIframeMap.delete(this.embedNonce);
    }
  }
  async init({
    network,
    clientId
  }) {
    if (typeof window === "undefined" || typeof document === "undefined") throw new Error("window or document is not available");
    if (this.initialized) throw new Error("AuthProvider already initialized");
    const authIframeUrl = new URL(this.sdkUrl);
    if (authIframeUrl.pathname.endsWith("/")) authIframeUrl.pathname += "frame";else authIframeUrl.pathname += "/frame";
    const hashParams = new URLSearchParams();
    hashParams.append("origin", window.location.origin);
    hashParams.append("nonce", this.embedNonce);
    authIframeUrl.hash = hashParams.toString();
    const colorScheme = getTheme(this.whiteLabel.mode || THEME_MODES.light);
    const authServiceIframe = htmlToElement(`<iframe
        id="${IFRAME_MODAL_ID}-${this.embedNonce}"
        class="${IFRAME_MODAL_ID}-${this.embedNonce}"
        sandbox="allow-popups allow-scripts allow-same-origin allow-forms allow-modals allow-downloads"
        src="${authIframeUrl.href}"
        style="display: none; position: fixed; top: 0; right: 0; width: 100%; z-index: 10000000;
        height: 100%; border: none; border-radius: 0; color-scheme: ${colorScheme};"
        allow="clipboard-write"
      ></iframe>`);
    this.registerAuthServiceIframe(authServiceIframe);
    return new Promise((resolve, reject) => {
      try {
        window.document.body.appendChild(authServiceIframe);
        const handleMessage = event => {
          var _this$getAuthServiceI, _this$loginCallbackFa, _this$loginCallbackSu;
          if (event.origin !== this.targetOrigin) return;
          const {
            data
          } = event;
          const {
            type,
            nonce
          } = data;
          // dont do anything if the nonce is not the same.
          if (nonce !== this.embedNonce) return;
          const messageData = data.data;
          switch (type) {
            case JRPC_METHODS.SETUP_COMPLETE:
              (_this$getAuthServiceI = this.getAuthServiceIframe()) === null || _this$getAuthServiceI === void 0 || (_this$getAuthServiceI = _this$getAuthServiceI.contentWindow) === null || _this$getAuthServiceI === void 0 || _this$getAuthServiceI.postMessage({
                type: JRPC_METHODS.INIT_DAPP,
                data: {
                  network,
                  clientId
                }
              }, this.targetOrigin);
              this.initialized = true;
              resolve();
              break;
            case JRPC_METHODS.LOGIN_FAILED:
              (_this$loginCallbackFa = this.loginCallbackFailed) === null || _this$loginCallbackFa === void 0 || _this$loginCallbackFa.call(this, (messageData === null || messageData === void 0 ? void 0 : messageData.error) || "Login failed, reason: unknown");
              break;
            case JRPC_METHODS.DISPLAY_IFRAME:
              this.getAuthServiceIframe().style.display = "block";
              break;
            case JRPC_METHODS.HIDE_IFRAME:
              this.getAuthServiceIframe().style.display = "none";
              break;
            case JRPC_METHODS.LOGIN_SUCCESS:
              log.info("LOGIN_SUCCESS", messageData);
              this.getAuthServiceIframe().style.display = "none";
              if (messageData !== null && messageData !== void 0 && messageData.sessionId) (_this$loginCallbackSu = this.loginCallbackSuccess) === null || _this$loginCallbackSu === void 0 || _this$loginCallbackSu.call(this, messageData);
              break;
            default:
              log.warn(`Unknown message type: ${type}`);
              break;
          }
        };
        window.addEventListener("message", handleMessage);
      } catch (error) {
        reject(error);
      }
    });
  }
  postLoginInitiatedMessage(loginConfig, nonce) {
    var _this$getAuthServiceI2;
    if (!this.initialized) throw new Error("Iframe not initialized");
    (_this$getAuthServiceI2 = this.getAuthServiceIframe().contentWindow) === null || _this$getAuthServiceI2 === void 0 || _this$getAuthServiceI2.postMessage({
      type: JRPC_METHODS.LOGIN_INITIATED,
      data: {
        loginConfig,
        nonce
      }
    }, this.targetOrigin);
    return new Promise((resolve, reject) => {
      this.loginCallbackSuccess = resolve;
      this.loginCallbackFailed = reject;
    });
  }
  postLoginCancelledMessage(nonce) {
    var _this$getAuthServiceI3;
    if (!this.initialized) throw new Error("Iframe not initialized");
    (_this$getAuthServiceI3 = this.getAuthServiceIframe().contentWindow) === null || _this$getAuthServiceI3 === void 0 || _this$getAuthServiceI3.postMessage({
      type: JRPC_METHODS.LOGIN_CANCELLED,
      data: {
        nonce
      }
    }, this.targetOrigin);
  }
}

export { AuthProvider };
