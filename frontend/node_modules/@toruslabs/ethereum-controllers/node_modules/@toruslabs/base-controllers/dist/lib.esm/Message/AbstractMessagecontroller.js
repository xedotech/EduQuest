import _defineProperty from '@babel/runtime/helpers/defineProperty';
import { providerErrors, rpcErrors } from '@web3auth/auth';
import { BaseController } from '../BaseController.js';
import { MessageStatus } from './constants.js';

class AbstractMessageController extends BaseController {
  /**
   * Controller in charge of managing - storing, adding, removing, updating - Messages.
   *
   */
  constructor({
    config,
    state
  }) {
    super({
      config,
      state
    });
    _defineProperty(this, "messages", void 0);
    this.defaultState = {
      unapprovedMessages: {},
      unapprovedMessagesCount: 0
    };
    this.messages = [];
    this.defaultConfig = {};
    super.initialize();
  }
  getMessage(messageId) {
    return this.messages.find(message => message.id === messageId);
  }
  getAllMessages() {
    return this.messages;
  }
  setMetadata(messageId, metadata) {
    const message = this.getMessage(messageId);
    if (!message) {
      throw new Error(`${this.name}: Message not found for id: ${messageId}.`);
    }
    message.metadata = metadata;
    this.updateMessage(message);
  }
  getUnapprovedMessages() {
    return this.messages.filter(message => message.status === MessageStatus.UNAPPROVED).reduce((result, message) => {
      result[message.id] = message;
      return result;
    }, {});
  }
  async addMessage(message) {
    this.messages.push(message);
    this.saveMessageList();
  }
  approveMessage(messageId, messageParams) {
    this.setMessageStatus(messageId, MessageStatus.APPROVED);
    return this.prepMessageForSigning(messageParams);
  }
  setMessageStatus(messageId, status) {
    const message = this.getMessage(messageId);
    if (!message) {
      throw new Error(`${this.name}: Message not found for id: ${messageId}.`);
    }
    message.status = status;
    this.updateMessage(message);
    this.emit(`${messageId}:${status}`, message);
    if (status === MessageStatus.REJECTED || status === MessageStatus.SIGNED || status === MessageStatus.FAILED) {
      this.emit(`${messageId}:finished`, message);
    }
  }
  async waitForFinishStatus(msgParams, messageName) {
    return new Promise((resolve, reject) => {
      const handleFinished = msg => {
        if (msg.status === MessageStatus.REJECTED) {
          return reject(providerErrors.userRejectedRequest(`${messageName} Signature: User denied message signature`));
        }
        if (msg.status === MessageStatus.FAILED) {
          return reject(rpcErrors.internal(`${messageName} Signature: failed to sign message ${msg.error}`));
        }
        if (msg.status === MessageStatus.SIGNED) {
          return resolve(msg.rawSig);
        }
        return reject(rpcErrors.internal(`${messageName} Signature: Unknown problem: ${JSON.stringify(msgParams)}`));
      };
      this.once(`${msgParams.id}:finished`, handleFinished);
    });
  }
  updateMessage(message) {
    const index = this.messages.findIndex(msg => message.id === msg.id);
    if (index !== -1) {
      this.messages[index] = message;
    }
    this.saveMessageList();
  }
  saveMessageList() {
    const unapprovedMessages = this.getUnapprovedMessages();
    const unapprovedMessagesCount = Object.keys(unapprovedMessages).length;
    this.update({
      unapprovedMessages,
      unapprovedMessagesCount
    });
  }
}

export { AbstractMessageController };
