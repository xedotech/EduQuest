import { BroadcastChannel } from "./broadcast-channel";
import { EventType, IBroadcastChannel, Method, Options as BroadcastChannelOptions } from "./types";
type Nonce = `${number}-${number}`;
export type WrappedMessage = {
    nonce: Nonce;
    message: unknown;
};
/**
 * The RedundantAdaptiveBroadcastChannel class is designed to add fallback to during channel post message and synchronization issues between senders and receivers in a broadcast communication scenario. It achieves this by:
 * Creating a separate channel for each communication method, allowing all methods to listen simultaneously.
 * Implementing redundant message delivery by attempting to send messages through multiple channels when the primary channel fails.
 * Ensuring message delivery by using multiple communication methods simultaneously while preventing duplicate message processing.
 */
export declare class RedundantAdaptiveBroadcastChannel<T = any> implements IBroadcastChannel<T> {
    name: string;
    options: BroadcastChannelOptions;
    closed: boolean;
    onML: ((event: T) => void) | null;
    methodPriority: Method["type"][];
    channels: Map<Method["type"], BroadcastChannel<T>>;
    listeners: Set<(message: T) => void>;
    processedNonces: Set<string>;
    nonce: number;
    constructor(name: string, options?: BroadcastChannelOptions);
    set onmessage(fn: ((data: T) => void) | null);
    initChannels(): void;
    allChannels(): Method["type"][];
    hasChannel(method: Method["type"]): boolean;
    handleMessage(event: WrappedMessage): void;
    postMessage(message: T): Promise<T>;
    generateNonce(): Nonce;
    addEventListener(_type: EventType, listener: (data: T) => void): void;
    removeEventListener(_type: EventType, listener: (data: T) => void): void;
    close(): Promise<void>;
}
export {};
