'use strict';

var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var constants = require('@toruslabs/constants');
var eccrypto = require('@toruslabs/eccrypto');
var metadataHelpers = require('@toruslabs/metadata-helpers');
var base = require('./base.js');
var util = require('./util.js');

const DEFAULT_SESSION_TIMEOUT = 86400;
class SessionManager extends base.BaseSessionManager {
  constructor({
    sessionServerBaseUrl,
    sessionNamespace,
    sessionTime,
    sessionId,
    allowedOrigin
  } = {}) {
    super();
    _defineProperty(this, "sessionServerBaseUrl", constants.SESSION_SERVER_API_URL);
    _defineProperty(this, "sessionNamespace", void 0);
    _defineProperty(this, "allowedOrigin", void 0);
    _defineProperty(this, "sessionTime", DEFAULT_SESSION_TIMEOUT);
    _defineProperty(this, "sessionId", "");
    if (sessionServerBaseUrl) {
      this.sessionServerBaseUrl = sessionServerBaseUrl;
    }
    if (sessionNamespace) this.sessionNamespace = sessionNamespace;
    if (sessionTime) this.sessionTime = sessionTime;
    if (sessionId) this.sessionId = util.padHexString(sessionId);
    if (allowedOrigin) {
      this.allowedOrigin = allowedOrigin;
    } else {
      this.allowedOrigin = "*";
    }
  }
  static generateRandomSessionKey() {
    return util.padHexString(eccrypto.generatePrivate().toString("hex"));
  }
  async createSession(data, headers = {}) {
    super.checkSessionParams();
    const privKey = Buffer.from(this.sessionId, "hex");
    const pubKey = eccrypto.getPublic(privKey).toString("hex");
    const encData = await metadataHelpers.encryptData(this.sessionId, data);
    const signature = (await eccrypto.sign(privKey, metadataHelpers.keccak256(Buffer.from(encData, "utf8")))).toString("hex");
    const body = {
      key: pubKey,
      data: encData,
      signature,
      namespace: this.sessionNamespace,
      timeout: this.sessionTime,
      allowedOrigin: this.allowedOrigin
    };
    await super.request({
      method: "POST",
      url: `${this.sessionServerBaseUrl}/v2/store/set`,
      data: body,
      headers
    });
    return this.sessionId;
  }
  async authorizeSession({
    headers
  } = {
    headers: {}
  }) {
    super.checkSessionParams();
    const pubkey = eccrypto.getPublic(Buffer.from(this.sessionId, "hex")).toString("hex");
    const body = {
      key: pubkey,
      namespace: this.sessionNamespace
    };
    const result = await super.request({
      method: "POST",
      url: `${this.sessionServerBaseUrl}/v2/store/get`,
      data: body,
      headers
    });
    if (!result.message) {
      throw new Error("Session Expired or Invalid public key");
    }
    const response = await metadataHelpers.decryptData(this.sessionId, result.message);
    if (response.error) {
      throw new Error("There was an error decrypting data.");
    }
    return response;
  }
  async updateSession(data, headers = {}) {
    super.checkSessionParams();
    const privKey = Buffer.from(this.sessionId, "hex");
    const pubKey = eccrypto.getPublic(privKey).toString("hex");
    const encData = await metadataHelpers.encryptData(this.sessionId, data);
    const signature = (await eccrypto.sign(privKey, metadataHelpers.keccak256(Buffer.from(encData, "utf8")))).toString("hex");
    const body = {
      key: pubKey,
      data: encData,
      signature,
      namespace: this.sessionNamespace,
      allowedOrigin: this.allowedOrigin
    };
    await super.request({
      method: "PUT",
      url: `${this.sessionServerBaseUrl}/v2/store/update`,
      data: body,
      headers
    });
  }
  async invalidateSession(headers = {}) {
    super.checkSessionParams();
    const privKey = Buffer.from(this.sessionId, "hex");
    const pubKey = eccrypto.getPublic(privKey).toString("hex");
    const encData = await metadataHelpers.encryptData(this.sessionId, {});
    const signature = (await eccrypto.sign(privKey, metadataHelpers.keccak256(Buffer.from(encData, "utf8")))).toString("hex");
    const data = {
      key: pubKey,
      data: encData,
      signature,
      namespace: this.sessionNamespace,
      timeout: 1
    };
    await super.request({
      method: "POST",
      url: `${this.sessionServerBaseUrl}/v2/store/set`,
      data,
      headers
    });
    this.sessionId = "";
    return true;
  }
}

exports.SessionManager = SessionManager;
