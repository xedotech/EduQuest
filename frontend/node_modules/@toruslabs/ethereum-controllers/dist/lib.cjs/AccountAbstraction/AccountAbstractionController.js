'use strict';

var _objectSpread = require('@babel/runtime/helpers/objectSpread2');
var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var util = require('@ethereumjs/util');
var baseControllers = require('@toruslabs/base-controllers');
var auth = require('@web3auth/auth');
var ethers = require('ethers');
var log = require('loglevel');
var viem = require('viem');
var accountAbstraction = require('viem/account-abstraction');

const eoaInterceptorMiddleware = eoaAddress => (req, res, next, end) => {
  req.isAAProviderRequest = true;
  if (req.method === "eth_accounts" || req.method === "eth_requestAccounts") {
    res.result = [eoaAddress];
    end();
    return;
  }
  next();
};
function eoaProviderAsMiddleware(provider) {
  return async (req, res, _next, end) => {
    // send request to provider
    try {
      const providerRes = await provider.request(req);
      res.result = providerRes;
      return end();
    } catch (error) {
      return end(error);
    }
  };
}
class AccountAbstractionController extends baseControllers.BaseController {
  constructor({
    config,
    state,
    getProviderConfig,
    onNetworkStateChange
  }) {
    super({
      state,
      config
    });
    _defineProperty(this, "_smartAccount", void 0);
    _defineProperty(this, "_publicClient", void 0);
    _defineProperty(this, "_bundlerClient", void 0);
    _defineProperty(this, "_paymasterClient", void 0);
    _defineProperty(this, "getProviderConfig", void 0);
    this.initialize();
    this.getProviderConfig = getProviderConfig;
    // TODO: handle network change in torus controller & call setupProvider
    onNetworkStateChange(networkState => {
      if (networkState.chainId !== this.config.chainId) {
        this.configure({
          chainId: networkState.chainId
        });
      }
    });
  }
  get smartAccount() {
    return this._smartAccount;
  }
  get bundlerClient() {
    return this._bundlerClient;
  }
  async setupProvider(eoaProvider, eoaAddress) {
    const providerConfig = this.getProviderConfig();
    const chain = viem.defineChain({
      id: Number.parseInt(providerConfig.chainId, 16),
      // id in number form
      name: providerConfig.displayName,
      rpcUrls: {
        default: {
          http: [providerConfig.rpcTarget],
          webSocket: [providerConfig.wsTarget]
        }
      },
      blockExplorers: providerConfig.blockExplorerUrl ? {
        default: {
          name: "explorer",
          // TODO: correct name if chain config has it
          url: providerConfig.blockExplorerUrl
        }
      } : undefined,
      nativeCurrency: {
        name: providerConfig.tickerName,
        symbol: providerConfig.ticker,
        decimals: providerConfig.decimals || 18
      }
    });
    this._publicClient = viem.createPublicClient({
      chain,
      transport: viem.http(providerConfig.rpcTarget)
    });
    // viem wallet client using json-rpc account from eoaProvider
    const aaEngine = new auth.JRPCEngine();
    aaEngine.push(eoaInterceptorMiddleware(eoaAddress));
    aaEngine.push(eoaProviderAsMiddleware(eoaProvider));
    const provider = auth.providerFromEngine(aaEngine);
    // need to hoist the account address https://viem.sh/docs/clients/wallet#optional-hoist-the-account
    const eoaWalletClient = viem.createWalletClient({
      account: eoaAddress,
      chain,
      transport: viem.custom(provider)
    });
    this._smartAccount = await this.config.smartAccountInit.getSmartAccount({
      walletClient: eoaWalletClient,
      client: this._publicClient
    });
    if (this.config.paymasterConfig) {
      this._paymasterClient = accountAbstraction.createPaymasterClient(_objectSpread(_objectSpread({}, this.config.paymasterConfig), {}, {
        transport: viem.custom(provider)
      }));
    }
    this._bundlerClient = accountAbstraction.createBundlerClient(_objectSpread(_objectSpread({}, this.config.bundlerConfig), {}, {
      account: this.smartAccount,
      client: this._publicClient,
      transport: viem.custom(provider),
      paymaster: this._paymasterClient
    }));
    log.info("check: this._smartAccount", this.smartAccount.address);
    this.update({
      smartAccountAddress: this.smartAccount.address
    });
  }
  async sendTransaction(id, tx, address) {
    var _txParams$chainId, _txReceipt$receipt, _txReceipt$nonce, _txReceipt$receipt2, _txReceipt$receipt3, _txReceipt$receipt4;
    if (address.toLowerCase() !== this.smartAccount.address.toLowerCase()) {
      throw new Error("Invalid address");
    }
    const txParams = tx;
    // @ts-expect-error TODO: viem types are too deep
    const userOperationParams = {
      account: this.smartAccount,
      calls: [{
        to: txParams.to,
        // Explicit conversation required to avoid value being passed as hex
        value: txParams.value ? BigInt(txParams.value) : undefined,
        data: txParams.data
      }],
      maxFeePerGas: txParams.maxFeePerGas ? BigInt(txParams.maxFeePerGas) : undefined,
      maxPriorityFeePerGas: txParams.maxPriorityFeePerGas ? BigInt(txParams.maxPriorityFeePerGas) : undefined,
      callGasLimit: txParams.callGasLimit ? BigInt(txParams.callGasLimit) : undefined,
      preVerificationGas: txParams.preVerificationGas ? BigInt(txParams.preVerificationGas) : undefined,
      verificationGasLimit: txParams.verificationGasLimit ? BigInt(txParams.verificationGasLimit) : undefined,
      paymasterVerificationGasLimit: txParams.paymasterVerificationGasLimit ? BigInt(txParams.paymasterVerificationGasLimit) : undefined,
      paymasterPostOpGasLimit: txParams.paymasterPostOpGasLimit ? BigInt(txParams.paymasterPostOpGasLimit) : undefined
    };
    const userOpMeta = {
      transactionParams: txParams,
      chainId: (_txParams$chainId = txParams.chainId) !== null && _txParams$chainId !== void 0 ? _txParams$chainId : this.getProviderConfig().chainId,
      createdAt: new Date(),
      status: baseControllers.TransactionStatus.approved
    };
    this.updateUserOpMeta(id, userOpMeta);
    const userOpHash = await this.bundlerClient.sendUserOperation(userOperationParams);
    this.updateUserOpMeta(id, {
      userOpHash,
      status: baseControllers.TransactionStatus.submitted
    });
    const txReceipt = await this.bundlerClient.waitForUserOperationReceipt({
      hash: userOpHash
    });
    this.updateUserOpMeta(id, {
      receipt: {
        transactionHash: (_txReceipt$receipt = txReceipt.receipt) === null || _txReceipt$receipt === void 0 ? void 0 : _txReceipt$receipt.transactionHash,
        nonce: (_txReceipt$nonce = txReceipt.nonce) === null || _txReceipt$nonce === void 0 ? void 0 : _txReceipt$nonce.toString(),
        gasUsed: util.addHexPrefix((_txReceipt$receipt2 = txReceipt.receipt) === null || _txReceipt$receipt2 === void 0 || (_txReceipt$receipt2 = _txReceipt$receipt2.gasUsed) === null || _txReceipt$receipt2 === void 0 ? void 0 : _txReceipt$receipt2.toString(16)),
        effectiveGasPrice: util.addHexPrefix((_txReceipt$receipt3 = txReceipt.receipt) === null || _txReceipt$receipt3 === void 0 || (_txReceipt$receipt3 = _txReceipt$receipt3.effectiveGasPrice) === null || _txReceipt$receipt3 === void 0 ? void 0 : _txReceipt$receipt3.toString(16)),
        type: (_txReceipt$receipt4 = txReceipt.receipt) === null || _txReceipt$receipt4 === void 0 ? void 0 : _txReceipt$receipt4.type,
        reason: txReceipt.reason
      },
      status: txReceipt.success ? baseControllers.TransactionStatus.confirmed : baseControllers.TransactionStatus.failed
    });
    return txReceipt.receipt.transactionHash;
  }
  async signTransaction(id, tx, address) {
    var _txParams$chainId2;
    if (address.toLowerCase() !== this.smartAccount.address.toLowerCase()) {
      throw new Error("Invalid address");
    }
    const txParams = tx;
    const userOpMeta = {
      transactionParams: txParams,
      chainId: (_txParams$chainId2 = txParams.chainId) !== null && _txParams$chainId2 !== void 0 ? _txParams$chainId2 : this.getProviderConfig().chainId,
      createdAt: new Date(),
      status: baseControllers.TransactionStatus.approved
    };
    this.updateUserOpMeta(id, userOpMeta);
    const request = await this.bundlerClient.prepareUserOperation({
      account: this.smartAccount,
      calls: [{
        to: txParams.to,
        // Explicit conversation required to avoid value being passed as hex
        value: txParams.value ? BigInt(txParams.value) : undefined,
        data: txParams.data
      }],
      maxFeePerGas: txParams.maxFeePerGas ? BigInt(txParams.maxFeePerGas) : undefined,
      maxPriorityFeePerGas: txParams.maxPriorityFeePerGas ? BigInt(txParams.maxPriorityFeePerGas) : undefined,
      callGasLimit: txParams.callGasLimit ? BigInt(txParams.callGasLimit) : undefined,
      preVerificationGas: txParams.preVerificationGas ? BigInt(txParams.preVerificationGas) : undefined,
      verificationGasLimit: txParams.verificationGasLimit ? BigInt(txParams.verificationGasLimit) : undefined,
      paymasterVerificationGasLimit: txParams.paymasterVerificationGasLimit ? BigInt(txParams.paymasterVerificationGasLimit) : undefined,
      paymasterPostOpGasLimit: txParams.paymasterPostOpGasLimit ? BigInt(txParams.paymasterPostOpGasLimit) : undefined
    });
    const signature = await this.smartAccount.signUserOperation(request);
    this.updateUserOpMeta(id, {
      signature,
      status: baseControllers.TransactionStatus.signed
    });
    return signature;
  }
  async estimateGas(txParams, address) {
    if (address.toLowerCase() !== this.smartAccount.address.toLowerCase()) throw new Error("Invalid address");
    const calls = [{
      to: txParams.to,
      value: txParams.value ? BigInt(txParams.value) : undefined,
      data: txParams.data
    }];
    const maxFeePerGas = txParams.maxFeePerGas ? BigInt(txParams.maxFeePerGas) : undefined;
    const maxPriorityFeePerGas = txParams.maxPriorityFeePerGas ? BigInt(txParams.maxPriorityFeePerGas) : undefined;
    // estimate gas: maxFeePerGas and maxPriorityFeePerGas are not required
    const estimateGasParams = {
      account: this.smartAccount,
      calls,
      maxFeePerGas,
      maxPriorityFeePerGas,
      stateOverride: [
      // override state to estimate gas for an ERC-20 transfer without causing a RPC error due to insufficient funds
      // ref: https://docs.cometh.io/connect-4337/bundler/bundler-api/eth_estimateuseroperationgas#optional-state-override-set
      {
        address: this.smartAccount.address,
        balance: viem.parseEther("1")
      }]
    };
    // bundler only support factoryArgs for estimate user operation gas in entryPoint v0.7
    let factoryArgs;
    if (this.smartAccount.entryPoint.version !== "0.6") {
      factoryArgs = await this.smartAccount.getFactoryArgs(); // will return undefined if smart account already deployed
    }
    if (factoryArgs) {
      // using object spread here will cause type error because of viem's excessively deep types
      // TODO: currently using single property assignment, check again when viem types are updated
      if (factoryArgs.factory) {
        estimateGasParams.factory = factoryArgs.factory;
      }
      if (factoryArgs.factoryData) {
        estimateGasParams.factoryData = factoryArgs.factoryData;
      }
    }
    const result = await this.bundlerClient.estimateUserOperationGas(estimateGasParams);
    const gasData = {
      callGasLimit: viem.toHex(result.callGasLimit),
      preVerificationGas: viem.toHex(result.preVerificationGas),
      verificationGasLimit: viem.toHex(result.verificationGasLimit)
    };
    // NOTE: paymasterVerificationGasLimit and paymasterPostOpGasLimit are optional don't include it in the object otherwise bundler rpc call will throw error (depend on bundler)
    if (result.paymasterVerificationGasLimit) {
      gasData.paymasterVerificationGasLimit = viem.toHex(result.paymasterVerificationGasLimit);
    }
    if (result.paymasterPostOpGasLimit) {
      gasData.paymasterPostOpGasLimit = viem.toHex(result.paymasterPostOpGasLimit);
    }
    return gasData;
  }
  async signMessage(message, address) {
    if (address.toLowerCase() !== this.smartAccount.address.toLowerCase()) {
      throw new Error("Invalid address");
    }
    return this.smartAccount.sign({
      hash: message
    });
  }
  async signPersonalMessage(message, address) {
    var _this$smartAccount;
    if (address.toLowerCase() !== this.smartAccount.address.toLowerCase()) {
      throw new Error("Invalid address");
    }
    return (_this$smartAccount = this.smartAccount) === null || _this$smartAccount === void 0 ? void 0 : _this$smartAccount.signMessage({
      message: ethers.isHexString(message) ? {
        raw: message
      } : message
    });
  }
  async signTypedData(data, address) {
    var _this$smartAccount2;
    if (address.toLowerCase() !== this.smartAccount.address.toLowerCase()) {
      throw new Error("Invalid address");
    }
    return (_this$smartAccount2 = this.smartAccount) === null || _this$smartAccount2 === void 0 ? void 0 : _this$smartAccount2.signTypedData({
      domain: _objectSpread(_objectSpread({}, data.domain), {}, {
        verifyingContract: data.domain.verifyingContract,
        salt: data.domain.salt,
        chainId: Number(data.domain.chainId)
      }),
      primaryType: data.primaryType,
      types: data.types,
      message: data.message
    });
  }
  updateUserOpMeta(id, data) {
    const userOp = this.state.userOperations[id];
    this.update({
      userOperations: _objectSpread(_objectSpread({}, this.state.userOperations), {}, {
        [id]: _objectSpread(_objectSpread({}, userOp), data)
      })
    });
  }
}

exports.AccountAbstractionController = AccountAbstractionController;
exports.eoaInterceptorMiddleware = eoaInterceptorMiddleware;
exports.eoaProviderAsMiddleware = eoaProviderAsMiddleware;
