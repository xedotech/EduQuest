'use strict';

var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var asyncMutex = require('async-mutex');
var constants = require('../utils/constants.js');

class NonceTracker {
  constructor({
    provider,
    blockTracker,
    getPendingTransactions,
    getConfirmedTransactions
  }) {
    _defineProperty(this, "provider", void 0);
    _defineProperty(this, "blockTracker", void 0);
    _defineProperty(this, "getPendingTransactions", void 0);
    _defineProperty(this, "getConfirmedTransactions", void 0);
    _defineProperty(this, "lockMap", void 0);
    this.provider = provider;
    this.blockTracker = blockTracker;
    this.getPendingTransactions = getPendingTransactions;
    this.getConfirmedTransactions = getConfirmedTransactions;
    this.lockMap = {};
  }
  async getGlobalLock() {
    const globalMutex = this._lookupMutex("global");
    // await global mutex free
    const releaseLock = await globalMutex.acquire();
    return {
      releaseLock
    };
  }
  /**
    this will return an object with the `nextNonce`
    `nonceDetails`, and the releaseLock.
    Note: releaseLock must be called after adding a signed tx
    to pending transactions (or discarding).
  */
  async getNonceLock(address) {
    // await global mutex free
    await this._globalMutexFree();
    // await lock free, then take lock
    const releaseLock = await this._takeMutex(address);
    try {
      // evaluate multiple nextNonce strategies
      const nonceDetails = {};
      const networkNonceResult = await this._getNetworkNextNonce(address);
      const highestLocallyConfirmed = this._getHighestLocallyConfirmed(address);
      const nextNetworkNonce = networkNonceResult.nonce;
      const highestSuggested = Math.max(nextNetworkNonce, highestLocallyConfirmed);
      const pendingTxs = this.getPendingTransactions(address);
      const localNonceResult = this._getHighestContinuousFrom(pendingTxs, highestSuggested);
      nonceDetails.params = {
        highestLocallyConfirmed,
        highestSuggested,
        nextNetworkNonce
      };
      nonceDetails.local = localNonceResult;
      nonceDetails.network = networkNonceResult;
      const nextNonce = Math.max(networkNonceResult.nonce, localNonceResult.nonce);
      // return nonce and release cb
      return {
        nextNonce,
        nonceDetails,
        releaseLock
      };
    } catch (error) {
      // release lock if we encounter an error
      releaseLock();
      throw error;
    }
  }
  async _globalMutexFree() {
    const globalMutex = this._lookupMutex("global");
    const releaseLock = await globalMutex.acquire();
    releaseLock();
  }
  async _takeMutex(lockId) {
    const mutex = this._lookupMutex(lockId);
    const releaseLock = await mutex.acquire();
    return releaseLock;
  }
  _lookupMutex(lockId) {
    let mutex = this.lockMap[lockId];
    if (!mutex) {
      mutex = new asyncMutex.Mutex();
      this.lockMap[lockId] = mutex;
    }
    return mutex;
  }
  async _getNetworkNextNonce(address) {
    // calculate next nonce
    // we need to make sure our base count
    // and pending count are from the same block
    const block = await this.blockTracker.getLatestBlock();
    const baseCountStr = await this.provider.request({
      method: constants.METHOD_TYPES.ETH_GET_TRANSACTION_COUNT,
      params: [address, block.idempotencyKey]
    });
    const baseCount = Number.parseInt(baseCountStr, 16);
    const nonceDetails = {
      block,
      baseCount
    };
    return {
      name: "network",
      nonce: baseCount,
      details: nonceDetails
    };
  }
  _getHighestLocallyConfirmed(address) {
    const confirmedTransactions = this.getConfirmedTransactions(address);
    const highest = this._getHighestNonce(confirmedTransactions);
    return Number.isInteger(highest) ? highest + 1 : 0;
  }
  _getHighestNonce(txList) {
    const nonces = txList.map(txMeta => {
      const {
        nonce
      } = txMeta.transaction;
      return Number.parseInt(nonce, 16);
    });
    const highestNonce = Math.max.apply(null, nonces);
    return highestNonce;
  }
  _getHighestContinuousFrom(txList, startPoint) {
    const nonces = new Set(txList.map(txMeta => {
      const {
        nonce
      } = txMeta.transaction;
      return Number.parseInt(nonce, 16);
    }));
    let highest = startPoint;
    while (nonces.has(highest)) {
      highest += 1;
    }
    return {
      name: "local",
      nonce: highest,
      details: {
        startPoint,
        highest
      }
    };
  }
}

exports.NonceTracker = NonceTracker;
