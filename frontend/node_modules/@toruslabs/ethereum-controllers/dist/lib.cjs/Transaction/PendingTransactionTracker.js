'use strict';

var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var baseControllers = require('@toruslabs/base-controllers');
var auth = require('@web3auth/auth');
var log = require('loglevel');
var constants = require('../utils/constants.js');

class PendingTransactionTracker extends auth.SafeEventEmitter {
  constructor({
    provider,
    nonceTracker,
    approveTransaction,
    publishTransaction,
    getPendingTransactions,
    getConfirmedTransactions
  }) {
    super();
    _defineProperty(this, "DROPPED_BUFFER_COUNT", 3);
    _defineProperty(this, "nonceTracker", void 0);
    _defineProperty(this, "provider", void 0);
    _defineProperty(this, "approveTransaction", void 0);
    _defineProperty(this, "droppedBlocksBufferByHash", void 0);
    _defineProperty(this, "getConfirmedTransactions", void 0);
    _defineProperty(this, "getPendingTransactions", void 0);
    _defineProperty(this, "publishTransaction", void 0);
    this.provider = provider;
    this.nonceTracker = nonceTracker;
    this.approveTransaction = approveTransaction;
    this.publishTransaction = publishTransaction;
    this.getPendingTransactions = getPendingTransactions;
    this.getConfirmedTransactions = getConfirmedTransactions;
    this.droppedBlocksBufferByHash = new Map();
  }
  /**
    checks the network for signed txs and releases the nonce global lock if it is
  */
  async updatePendingTxs() {
    // in order to keep the nonceTracker accurate we block it while updating pending transactions
    const nonceGlobalLock = await this.nonceTracker.getGlobalLock();
    try {
      const pendingTxs = this.getPendingTransactions();
      await Promise.all(pendingTxs.map(txMeta => this._checkPendingTx(txMeta)));
    } catch (error) {
      log.error("PendingTransactionTracker - Error updating pending transactions");
      log.error(error);
    }
    nonceGlobalLock.releaseLock();
  }
  async resubmitPendingTxs(block) {
    const pending = this.getPendingTransactions();
    // only try resubmitting if their are transactions to resubmit
    if (pending.length === 0) return;
    // Keep this as a for loop because we want to wait for each item to be submitted
    for (const txMeta of pending) {
      try {
        await this._resubmitTx(txMeta, block.idempotencyKey);
      } catch (error) {
        var _error$value;
        /*
        Dont marked as failed if the error is a "known" transaction warning
        "there is already a transaction with the same sender-nonce
        but higher/same gas price"
               Also don't mark as failed if it has ever been broadcast successfully.
        A successful broadcast means it may still be mined.
        */
        const errorMessage = ((_error$value = error.value) === null || _error$value === void 0 || (_error$value = _error$value.message) === null || _error$value === void 0 ? void 0 : _error$value.toLowerCase()) || error.message.toLowerCase();
        const isKnownTx =
        // geth
        errorMessage.includes("replacement transaction underpriced") || errorMessage.includes("known transaction") ||
        // parity
        errorMessage.includes("gas price too low to replace") || errorMessage.includes("transaction with the same hash was already imported") ||
        // other
        errorMessage.includes("gateway timeout") || errorMessage.includes("nonce too low");
        // ignore resubmit warnings, return early
        if (isKnownTx) return;
        // encountered real error - transition to error state
        txMeta.warning = {
          error: errorMessage,
          message: "There was an error when resubmitting this transaction."
        };
        this.emit(baseControllers.TX_EVENTS.TX_WARNING, {
          txMeta,
          txId: txMeta.id
        });
      }
    }
  }
  async _resubmitTx(txMeta, latestBlockNumber) {
    if (txMeta.userOpHash) return;
    if (!txMeta.firstRetryBlockNumber) {
      this.emit(baseControllers.TX_EVENTS.TX_BLOCK_UPDATE, {
        txMeta,
        latestBlockNumber,
        txId: txMeta.id
      });
    }
    const firstRetryBlockNumber = txMeta.firstRetryBlockNumber || latestBlockNumber;
    const txBlockDistance = Number.parseInt(latestBlockNumber, 16) - Number.parseInt(firstRetryBlockNumber, 16);
    const retryCount = txMeta.retryCount || 0;
    // Exponential backoff to limit retries at publishing (capped at last 15 mins)
    if (txBlockDistance <= Math.min(50, 2 ** retryCount)) return undefined;
    // Only auto-submit already-signed txs:
    if (!("rawTransaction" in txMeta)) return this.approveTransaction(txMeta.id);
    const {
      rawTransaction
    } = txMeta;
    const txHash = await this.publishTransaction(rawTransaction);
    // Increment successful tries:
    this.emit(baseControllers.TX_EVENTS.TX_RETRY, {
      txMeta,
      txId: txMeta.id
    });
    return txHash;
  }
  async _checkPendingTx(foundTx) {
    const txMeta = foundTx;
    const txHash = txMeta.transactionHash;
    const txId = txMeta.id;
    // Only check submitted txs
    if (txMeta.status !== baseControllers.TransactionStatus.submitted || txMeta.isUserOperation) return;
    // extra check in case there was an uncaught error during the
    // signature and submission process
    if (!txHash) {
      const noTxHashError = new Error("We had an error while submitting this transaction, please try again.");
      noTxHashError.name = "NoTxHashError";
      this.emit(baseControllers.TX_EVENTS.TX_FAILED, {
        txId,
        error: noTxHashError
      });
      return;
    }
    // If another tx with the same nonce is mined, set as failed.
    if (this._checkIfNonceIsTaken(txMeta)) {
      this.emit(baseControllers.TX_EVENTS.TX_DROPPED, {
        txId
      });
      return;
    }
    try {
      const transactionReceipt = await this.provider.request({
        method: constants.METHOD_TYPES.ETH_GET_TRANSACTION_RECEIPT,
        params: [txHash]
      });
      if (transactionReceipt !== null && transactionReceipt !== void 0 && transactionReceipt.blockNumber) {
        const {
          baseFeePerGas,
          timestamp
        } = await this.provider.request({
          method: constants.METHOD_TYPES.ETH_GET_BLOCK_BY_HASH,
          params: [transactionReceipt.blockHash, false]
        });
        this.emit(baseControllers.TX_EVENTS.TX_CONFIRMED, {
          txId,
          txReceipt: transactionReceipt,
          baseFeePerGas,
          blockTimestamp: timestamp
        });
        return;
      }
    } catch (error) {
      log.error("error while loading tx", error);
      txMeta.warning = {
        error: error.message,
        message: "There was a problem loading this transaction."
      };
      this.emit(baseControllers.TX_EVENTS.TX_WARNING, {
        txMeta,
        txId
      });
    }
    if (await this._checkIfTxWasDropped(txMeta)) {
      this.emit(baseControllers.TX_EVENTS.TX_DROPPED, {
        txId
      });
    }
  }
  async _checkIfTxWasDropped(txMeta) {
    const {
      transactionHash: txHash,
      transaction: {
        nonce,
        from
      }
    } = txMeta;
    const networkNextNonce = await this.provider.request({
      method: constants.METHOD_TYPES.ETH_GET_TRANSACTION_COUNT,
      params: [from, "latest"]
    });
    if (Number.parseInt(nonce, 16) >= Number.parseInt(networkNextNonce, 16)) {
      return false;
    }
    if (!this.droppedBlocksBufferByHash.has(txHash)) {
      this.droppedBlocksBufferByHash.set(txHash, 0);
    }
    const currentBlockBuffer = this.droppedBlocksBufferByHash.get(txHash);
    if (currentBlockBuffer < this.DROPPED_BUFFER_COUNT) {
      this.droppedBlocksBufferByHash.set(txHash, currentBlockBuffer + 1);
      return false;
    }
    this.droppedBlocksBufferByHash.delete(txHash);
    return true;
  }
  _checkIfNonceIsTaken(txMeta) {
    const address = txMeta.transaction.from;
    const completed = this.getConfirmedTransactions(address);
    return completed.some(otherMeta => {
      if (otherMeta.id === txMeta.id) {
        return false;
      }
      return otherMeta.transaction.nonce === txMeta.transaction.nonce;
    });
  }
}

exports.PendingTransactionTracker = PendingTransactionTracker;
