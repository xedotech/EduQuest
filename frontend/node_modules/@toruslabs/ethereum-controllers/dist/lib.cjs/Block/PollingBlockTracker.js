'use strict';

var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var baseControllers = require('@toruslabs/base-controllers');
var log = require('loglevel');

const DEFAULT_POLLING_INTERVAL = 20;
const DEFAULT_RETRY_TIMEOUT = 2;
const SEC = 1000;
class PollingBlockTracker extends baseControllers.BaseBlockTracker {
  constructor({
    config,
    state = {},
    idleTimeTracker
  }) {
    if (!config.provider) {
      throw new Error("PollingBlockTracker - no provider specified.");
    }
    if (!idleTimeTracker) {
      throw new Error("PollingBlockTracker - no idleTimeTracker specified.");
    }
    super({
      config,
      state
    });
    _defineProperty(this, "pollingManager", void 0);
    const pollingInterval = config.pollingInterval || DEFAULT_POLLING_INTERVAL;
    const retryTimeout = config.retryTimeout || DEFAULT_RETRY_TIMEOUT;
    // merge default + provided config.
    this.defaultConfig = {
      provider: config.provider,
      pollingInterval: pollingInterval * SEC,
      retryTimeout: retryTimeout * SEC,
      setSkipCacheFlag: config.setSkipCacheFlag || false
    };
    this.initialize();
    this.pollingManager = new baseControllers.PollingManager(idleTimeTracker, pollingInterval);
  }
  async checkForLatestBlock() {
    await this._updateLatestBlock();
    return this.getLatestBlock();
  }
  // overrides the BaseBlockTracker._start method.
  _start() {
    this.pollingManager.start(async () => {
      await this._synchronize().catch(err => {
        this.emit("error", err);
      });
    });
  }
  _end() {
    this.pollingManager.stop();
  }
  async _synchronize() {
    try {
      await this._updateLatestBlock();
    } catch (err) {
      const newErr = new Error(`PollingBlockTracker - encountered an error while attempting to update latest block:\n${err.stack}`);
      try {
        this.emit("error", newErr);
      } catch {
        log.error(newErr);
      }
      await baseControllers.timeout(this.config.retryTimeout);
    }
  }
  async _updateLatestBlock() {
    // fetch + set latest block
    const latestBlock = await this._fetchLatestBlock();
    this._newPotentialLatest(latestBlock);
  }
  async _fetchLatestBlock() {
    try {
      const block = await this.config.provider.request({
        method: "eth_getBlockByNumber",
        params: ["latest", false]
      });
      return {
        blockHash: block.hash,
        idempotencyKey: block.number,
        timestamp: block.timestamp,
        baseFeePerGas: block.baseFeePerGas,
        gasLimit: block.gasLimit
      };
    } catch (error) {
      log.error("Polling Block Tracker: ", error);
      throw new Error(`PollingBlockTracker - encountered error fetching block:\n${error.message}`);
    }
  }
}

exports.PollingBlockTracker = PollingBlockTracker;
