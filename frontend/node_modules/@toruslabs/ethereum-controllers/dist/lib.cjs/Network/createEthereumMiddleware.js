'use strict';

var baseControllers = require('@toruslabs/base-controllers');
var auth = require('@web3auth/auth');
var constants = require('../utils/constants.js');

function createGetAccountsMiddleware({
  getAccounts
}) {
  return auth.createAsyncMiddleware(async (request, response, next) => {
    const {
      method
    } = request;
    if (method !== constants.METHOD_TYPES.GET_ACCOUNTS) return next();
    if (!getAccounts) throw new Error("WalletMiddleware - opts.getAccounts not provided");
    const accounts = await getAccounts(request);
    response.result = accounts;
  });
}
function createProcessTransactionMiddleware({
  processTransaction
}) {
  return auth.createAsyncMiddleware(async (request, response, next) => {
    const {
      method
    } = request;
    if (method !== constants.METHOD_TYPES.ETH_TRANSACTION) return next();
    if (!processTransaction) throw new Error("WalletMiddleware - opts.processTransaction not provided");
    response.result = await processTransaction(request.params, request);
  });
}
function createProcessSignTransactionMiddleware({
  processSignTransaction
}) {
  return auth.createAsyncMiddleware(async (request, response, next) => {
    const {
      method
    } = request;
    if (method !== constants.METHOD_TYPES.ETH_SIGN_TRANSACTION) return next();
    if (!processSignTransaction) throw new Error("WalletMiddleware - opts.processSignTransaction not provided");
    response.result = await processSignTransaction(request.params, request);
  });
}
function createProcessEstimateUserOperationGasMiddleware({
  processEstimateUserOperationGas
}) {
  return auth.createAsyncMiddleware(async (request, response, next) => {
    const {
      method
    } = request;
    if (method !== constants.METHOD_TYPES.ETH_ESTIMATE_AA_TRANSACTION_GAS) return next();
    if (!processEstimateUserOperationGas) throw new Error("WalletMiddleware - opts.processEstimateUserOperationGas not provided");
    response.result = await processEstimateUserOperationGas(request.params, request);
  });
}
function createProcessEthSignMessage({
  processEthSignMessage
}) {
  return auth.createAsyncMiddleware(async (request, response, next) => {
    const {
      method
    } = request;
    if (method !== constants.METHOD_TYPES.ETH_SIGN) return next();
    if (!processEthSignMessage) throw new Error("WalletMiddleware - opts.processEthSignMessage not provided");
    if (!(request !== null && request !== void 0 && request.params)) throw new Error("WalletMiddleware - missing params");
    let msgParams = request.params;
    if (Array.isArray(request.params)) {
      if (!(request.params.length === 2)) throw new Error(`WalletMiddleware - incorrect params for ${method} method. expected [address, message]`);
      const params = request.params;
      const address = params[0];
      const message = params[1];
      msgParams = {
        from: address,
        data: message
      };
    }
    response.result = await processEthSignMessage(msgParams, request);
  });
}
function createProcessTypedMessageV4({
  processTypedMessageV4
}) {
  return auth.createAsyncMiddleware(async (request, response, next) => {
    const {
      method
    } = request;
    if (method !== constants.METHOD_TYPES.ETH_SIGN_TYPED_DATA_V4) return next();
    if (!processTypedMessageV4) throw new Error("WalletMiddleware - opts.processTypedMessageV4 is not provided");
    if (!(request !== null && request !== void 0 && request.params)) throw new Error("WalletMiddleware - missing params");
    let msgParams = request.params;
    if (Array.isArray(request.params)) {
      if (!(request.params.length === 2)) throw new Error(`WalletMiddleware - incorrect params for ${method} method. expected [address, typedData]`);
      const params = request.params;
      const address = params[0];
      const message = params[1];
      msgParams = {
        from: address,
        data: message
      };
    }
    response.result = await processTypedMessageV4(msgParams, request);
  });
}
function createProcessPersonalMessage({
  processPersonalMessage
}) {
  return auth.createAsyncMiddleware(async (request, response, next) => {
    const {
      method
    } = request;
    if (method !== constants.METHOD_TYPES.PERSONAL_SIGN) return next();
    if (!processPersonalMessage) throw new Error("WalletMiddleware - opts.processPersonalMessage is not provided");
    if (!(request !== null && request !== void 0 && request.params)) throw new Error("WalletMiddleware - missing params");
    let msgParams = request.params;
    if (Array.isArray(request.params)) {
      if (!(request.params.length >= 2)) throw new Error(`WalletMiddleware - incorrect params for ${method} method. expected [message, address]`);
      const params = request.params;
      if (typeof params[0] === "object") {
        const {
          challenge,
          address
        } = params[0];
        msgParams = {
          from: address,
          data: challenge
        };
      } else {
        const message = params[0];
        const address = params[1];
        msgParams = {
          from: address,
          data: message
        };
      }
    }
    response.result = await processPersonalMessage(msgParams, request);
  });
}
function createPendingNonceMiddleware({
  getPendingNonce
}) {
  return auth.createAsyncMiddleware(async (request, response, next) => {
    const {
      params,
      method
    } = request;
    if (method !== constants.METHOD_TYPES.ETH_GET_TRANSACTION_COUNT) return next();
    const {
      blockReference
    } = params;
    if (blockReference !== "pending") return next();
    response.result = await getPendingNonce(params, request);
  });
}
function formatTxMetaForRpcResult(txMeta) {
  const {
    r,
    s,
    v,
    txReceipt,
    transaction,
    transactionHash,
    accessList
  } = txMeta;
  const {
    to,
    data,
    nonce,
    gas,
    from,
    value,
    gasPrice,
    maxFeePerGas,
    maxPriorityFeePerGas
  } = transaction;
  const formattedTxMeta = {
    v,
    r,
    s,
    to,
    gas,
    from,
    hash: transactionHash,
    nonce,
    input: data || "0x",
    value: value || "0x0",
    accessList: accessList || null,
    blockHash: (txReceipt === null || txReceipt === void 0 ? void 0 : txReceipt.blockHash) || null,
    blockNumber: (txReceipt === null || txReceipt === void 0 ? void 0 : txReceipt.blockNumber) || null,
    transactionIndex: (txReceipt === null || txReceipt === void 0 ? void 0 : txReceipt.transactionIndex) || null,
    type: null
  };
  if (maxFeePerGas && maxPriorityFeePerGas) {
    formattedTxMeta.maxFeePerGas = maxFeePerGas;
    formattedTxMeta.maxPriorityFeePerGas = maxPriorityFeePerGas;
    formattedTxMeta.type = constants.TRANSACTION_ENVELOPE_TYPES.FEE_MARKET;
  } else {
    formattedTxMeta.gasPrice = gasPrice;
    formattedTxMeta.type = constants.TRANSACTION_ENVELOPE_TYPES.LEGACY;
  }
  return formattedTxMeta;
}
function createPendingTxMiddleware({
  getPendingTransactionByHash
}) {
  return auth.createAsyncMiddleware(async (request, response, next) => {
    const {
      params,
      method
    } = request;
    if (method !== constants.METHOD_TYPES.ETH_GET_TRANSACTION_BY_HASH) return next();
    if (!getPendingTransactionByHash) throw new Error("WalletMiddleware - opts.getPendingTransactionByHash not provided");
    const txMeta = await getPendingTransactionByHash(params, request);
    if (!txMeta) {
      return next();
    }
    response.result = formatTxMetaForRpcResult(txMeta);
    return undefined;
  });
}
function createProcessSwitchEthereumChain({
  processSwitchEthereumChain
}) {
  return auth.createAsyncMiddleware(async (request, response, next) => {
    const {
      method
    } = request;
    if (method !== constants.METHOD_TYPES.SWITCH_CHAIN) return next();
    if (!processSwitchEthereumChain) throw new Error("WalletMiddleware - opts.processSwitchEthereumChain not provided");
    if (!(request !== null && request !== void 0 && request.params)) throw new Error("WalletMiddleware - missing params");
    let msgParams = request.params;
    if (Array.isArray(request.params)) {
      if (!(request.params.length === 1)) throw new Error(`WalletMiddleware - incorrect params for ${method} method. expected [data]`);
      const [message] = request.params;
      msgParams = message;
    }
    response.result = await processSwitchEthereumChain(msgParams, request);
  });
}
function createProcessWalletSwitchChain({
  processWalletSwitchChain
}) {
  return auth.createAsyncMiddleware(async (request, response, next) => {
    const {
      method
    } = request;
    if (method !== baseControllers.PROVIDER_JRPC_METHODS.WALLET_SWITCH_CHAIN) return next();
    if (!processWalletSwitchChain) throw new Error("WalletMiddleware - opts.processWalletSwitchChain not provided");
    if (!(request !== null && request !== void 0 && request.params)) throw new Error("WalletMiddleware - missing params");
    let msgParams = request.params;
    if (Array.isArray(request.params)) {
      if (!(request.params.length === 1)) throw new Error(`WalletMiddleware - incorrect params for ${method} method. expected [data]`);
      const [message] = request.params;
      msgParams = message;
    }
    response.result = await processWalletSwitchChain(msgParams, request);
  });
}
function createProcessAddEthereumChain({
  processAddEthereumChain
}) {
  return auth.createAsyncMiddleware(async (request, response, next) => {
    const {
      method
    } = request;
    if (method !== constants.METHOD_TYPES.ADD_CHAIN) return next();
    if (!processAddEthereumChain) throw new Error("WalletMiddleware - opts.processAddEthereumChain not provided");
    if (!(request !== null && request !== void 0 && request.params)) throw new Error("WalletMiddleware - missing params");
    let msgParams = request.params;
    if (Array.isArray(request.params)) {
      if (!(request.params.length === 1)) throw new Error(`WalletMiddleware - incorrect params for ${method} method. expected [data]`);
      const [message] = request.params;
      msgParams = message;
    }
    response.result = await processAddEthereumChain(msgParams, request);
  });
}
function createRequestAccountsMiddleware({
  requestAccounts
}) {
  return auth.createAsyncMiddleware(async (request, response, next) => {
    const {
      method
    } = request;
    if (method !== "eth_requestAccounts") return next();
    if (!requestAccounts) throw new Error("WalletMiddleware - opts.requestAccounts not provided");
    // This calls the UI login function
    const accounts = await requestAccounts(request);
    response.result = accounts;
    return undefined;
  });
}
/**
 * Middleware to handle bundler/paymaster rpc method
 */
function createAAMiddleware({
  bundlerUrl,
  paymasterUrl,
  providerConfig,
  analytics
}) {
  // forward request to bundler/paymaster
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const middlewares = [];
  // NOTE: bundler/paymaster rpc only accept number as request id, we need to handle that here if client doesn't handle request id themselves
  const idNumberRemapMiddleware = (req, res, next, _end) => {
    // skip if not bundler/paymaster methods
    if (!constants.BUNDLER_METHOD_TYPES.includes(req.method) && !constants.PAYMASTER_METHOD_TYPES.includes(req.method)) {
      return next();
    }
    const originalId = req.id;
    const newId = Math.floor(Math.random() * 1000000);
    req.id = newId;
    res.id = newId;
    next(done => {
      req.id = originalId;
      res.id = originalId;
      done();
    });
  };
  const bundlerFetchMiddleware = baseControllers.createFetchMiddleware({
    rpcTarget: bundlerUrl,
    providerConfig,
    analytics
  });
  middlewares.push(idNumberRemapMiddleware);
  middlewares.push((request, response, next, end) => {
    if (!constants.BUNDLER_METHOD_TYPES.includes(request.method)) {
      return next();
    }
    bundlerFetchMiddleware(request, response, next, end);
  });
  if (paymasterUrl) {
    const paymasterFetchMiddleware = baseControllers.createFetchMiddleware({
      rpcTarget: paymasterUrl,
      providerConfig,
      analytics
    });
    middlewares.push((request, response, next, end) => {
      if (!constants.PAYMASTER_METHOD_TYPES.includes(request.method)) {
        return next();
      }
      paymasterFetchMiddleware(request, response, next, end);
    });
  }
  return auth.mergeMiddleware(middlewares);
}
function createEthereumMiddleware(providerHandlers, providerConfig, analytics) {
  const {
    requestAccounts,
    getAccounts,
    getPrivateKey,
    getPublicKey,
    processTransaction,
    processSignTransaction,
    processEstimateUserOperationGas,
    processEthSignMessage,
    processTypedMessageV4,
    processPersonalMessage,
    getPendingNonce,
    getPendingTransactionByHash,
    processSwitchEthereumChain,
    processWalletSwitchChain,
    processAddEthereumChain,
    getProviderState,
    aaConfig,
    version
  } = providerHandlers;
  const middlewares = [auth.createScaffoldMiddleware({
    version,
    [baseControllers.PROVIDER_JRPC_METHODS.GET_PROVIDER_STATE]: getProviderState
  }), createRequestAccountsMiddleware({
    requestAccounts
  }), createGetAccountsMiddleware({
    getAccounts
  }), baseControllers.createGenericJRPCMiddleware(constants.METHOD_TYPES.ETH_PRIVATE_KEY, getPrivateKey), baseControllers.createGenericJRPCMiddleware(constants.METHOD_TYPES.PRIVATE_KEY, getPrivateKey), baseControllers.createGenericJRPCMiddleware(constants.METHOD_TYPES.ETH_PUBLIC_KEY, getPublicKey), baseControllers.createGenericJRPCMiddleware(constants.METHOD_TYPES.PUBLIC_KEY, getPublicKey), createProcessTransactionMiddleware({
    processTransaction
  }), createProcessSignTransactionMiddleware({
    processSignTransaction
  }), createProcessEstimateUserOperationGasMiddleware({
    processEstimateUserOperationGas
  }), createProcessEthSignMessage({
    processEthSignMessage
  }), createProcessTypedMessageV4({
    processTypedMessageV4
  }), createProcessPersonalMessage({
    processPersonalMessage
  }), createPendingNonceMiddleware({
    getPendingNonce
  }), createPendingTxMiddleware({
    getPendingTransactionByHash
  }), createProcessSwitchEthereumChain({
    processSwitchEthereumChain
  }), createProcessWalletSwitchChain({
    processWalletSwitchChain
  }), createProcessAddEthereumChain({
    processAddEthereumChain
  })];
  if (aaConfig) {
    middlewares.push(createAAMiddleware({
      bundlerUrl: aaConfig.bundlerUrl,
      paymasterUrl: aaConfig.paymasterUrl,
      providerConfig,
      analytics
    }));
  }
  return auth.mergeMiddleware(middlewares);
}

exports.createAAMiddleware = createAAMiddleware;
exports.createEthereumMiddleware = createEthereumMiddleware;
exports.createGetAccountsMiddleware = createGetAccountsMiddleware;
exports.createPendingNonceMiddleware = createPendingNonceMiddleware;
exports.createPendingTxMiddleware = createPendingTxMiddleware;
exports.createProcessAddEthereumChain = createProcessAddEthereumChain;
exports.createProcessEstimateUserOperationGasMiddleware = createProcessEstimateUserOperationGasMiddleware;
exports.createProcessEthSignMessage = createProcessEthSignMessage;
exports.createProcessPersonalMessage = createProcessPersonalMessage;
exports.createProcessSignTransactionMiddleware = createProcessSignTransactionMiddleware;
exports.createProcessSwitchEthereumChain = createProcessSwitchEthereumChain;
exports.createProcessTransactionMiddleware = createProcessTransactionMiddleware;
exports.createProcessTypedMessageV4 = createProcessTypedMessageV4;
exports.createProcessWalletSwitchChain = createProcessWalletSwitchChain;
exports.createRequestAccountsMiddleware = createRequestAccountsMiddleware;
exports.formatTxMetaForRpcResult = formatTxMetaForRpcResult;
