'use strict';

var _objectSpread = require('@babel/runtime/helpers/objectSpread2');
var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var baseControllers = require('@toruslabs/base-controllers');
var log = require('loglevel');
var constants = require('../utils/constants.js');
var utils = require('./utils.js');

class TypedMessageController extends baseControllers.AbstractMessageController {
  constructor({
    config,
    state,
    signTypedData,
    getNetworkIdentifier
  }) {
    super({
      config,
      state
    });
    _defineProperty(this, "name", "TypedMessageController");
    _defineProperty(this, "signTypedData", void 0);
    _defineProperty(this, "getNetworkIdentifier", void 0);
    this.signTypedData = signTypedData;
    this.getNetworkIdentifier = getNetworkIdentifier;
    this.initialize();
  }
  async processSignTypedMessage(messageId) {
    const msgObject = this.getMessage(messageId);
    if (!msgObject) {
      throw new Error(`Message not found`);
    }
    try {
      const cleanMsgParams = await this.approveMessage(messageId, msgObject.messageParams);
      const msgData = JSON.parse(cleanMsgParams.data);
      const rawSig = await this.signTypedData(msgData, cleanMsgParams.from);
      this.updateMessage(_objectSpread(_objectSpread({}, msgObject), {}, {
        rawSig
      }));
      this.setMessageStatus(messageId, baseControllers.MessageStatus.SIGNED);
      return rawSig;
    } catch (error) {
      log.error(error);
      msgObject.error = (error === null || error === void 0 ? void 0 : error.message) || (error === null || error === void 0 ? void 0 : error.toString());
      this.setMessageStatus(messageId, baseControllers.MessageStatus.FAILED);
    }
  }
  async addNewUnapprovedMessage(messageParams, req) {
    await this.addUnapprovedMessage(messageParams, req);
    return this.waitForFinishStatus(messageParams, this.name);
  }
  async addUnapprovedMessage(messageParams, req) {
    const currentChainId = this.getNetworkIdentifier();
    await utils.validateTypedSignMessageDataV4(messageParams, currentChainId);
    if (typeof messageParams.data !== "string") {
      messageParams.data = JSON.stringify(messageParams.data);
    }
    if (req) {
      messageParams.origin = req.origin;
    }
    const messageId = messageParams.id || baseControllers.randomId();
    const messageData = {
      id: messageId,
      messageParams,
      status: baseControllers.MessageStatus.UNAPPROVED,
      time: Date.now(),
      type: constants.METHOD_TYPES.ETH_SIGN_TYPED_DATA_V4
    };
    await this.addMessage(messageData);
    this.emit(baseControllers.MESSAGE_EVENTS.UNAPPROVED_MESSAGE, {
      messageData,
      req
    });
    return messageId;
  }
  prepMessageForSigning(messageParams) {
    return Promise.resolve(messageParams);
  }
}

exports.TypedMessageController = TypedMessageController;
