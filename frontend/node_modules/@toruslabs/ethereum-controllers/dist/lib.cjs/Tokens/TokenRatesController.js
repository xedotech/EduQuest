'use strict';

var _objectSpread = require('@babel/runtime/helpers/objectSpread2');
var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var baseControllers = require('@toruslabs/base-controllers');
var httpHelpers = require('@toruslabs/http-helpers');
var log = require('loglevel');
var constants = require('../utils/constants.js');

const DEFAULT_CURRENCY = "eth";
class TokenRatesController extends baseControllers.BaseController {
  constructor({
    config,
    state,
    idleTimeTracker,
    onPreferencesStateChange,
    onNetworkStateChange,
    onTokensStateChange
  }) {
    super({
      config,
      state
    });
    _defineProperty(this, "pollingManager", void 0);
    this.defaultState = _objectSpread(_objectSpread({}, this.defaultState), {}, {
      contractExchangeRates: {}
    });
    this.initialize();
    onPreferencesStateChange(preferencesState => {
      const {
        selectedAddress
      } = preferencesState;
      this.configure({
        selectedAddress
      });
    });
    onNetworkStateChange(networkState => {
      const {
        chainId,
        ticker
      } = networkState.providerConfig;
      this.configure({
        chainId,
        nativeCurrency: ticker
      });
    });
    onTokensStateChange(tokensState => {
      const {
        tokens
      } = tokensState;
      const currentUserTokens = tokens[this.config.selectedAddress];
      if ((currentUserTokens === null || currentUserTokens === void 0 ? void 0 : currentUserTokens.length) > 0 && this.config.tokens !== tokens[this.config.selectedAddress]) {
        this.configure({
          tokens: tokens[this.config.selectedAddress]
        });
        this.updateExchangeRates();
      }
    });
    this.pollingManager = new baseControllers.PollingManager(idleTimeTracker, this.config.pollInterval);
  }
  /**
   * Creates a new poll, using setInterval, to periodically call updateConversionRate. The id of the interval is
   * stored at the controller's conversionInterval property. If it is called and such an id already exists, the
   * previous interval is clear and a new one is created.
   */
  async scheduleConversionInterval() {
    this.pollingManager.start(this.updateExchangeRates.bind(this));
  }
  async updateExchangeRates() {
    const chainCodes = constants.COINGECKO_PLATFORMS_CHAIN_CODE_MAP[this.config.chainId];
    let newContractExchangeRates = {};
    if (!chainCodes) {
      log.info(`ChainId ${this.config.chainId} not supported by coingecko`);
      this.config.tokens.forEach(token => {
        newContractExchangeRates[token.tokenAddress] = undefined;
      });
    } else {
      newContractExchangeRates = await this.fetchExchangeRates(this.config.nativeCurrency, chainCodes);
    }
    this.update({
      contractExchangeRates: newContractExchangeRates
    });
  }
  async fetchExchangeRates(nativeCurrency, chainCodes) {
    const contractAddresses = this.config.tokens.map(token => token.tokenAddress);
    const isNativeCurrencySupported = constants.COINGECKO_SUPPORTED_CURRENCIES.has(nativeCurrency.toLowerCase());
    if (isNativeCurrencySupported) {
      const response = await httpHelpers.get(`${this.config.currencyApi}/currency/exchange-rates?platform=${chainCodes.platform}&contract_addresses=${contractAddresses.join(",")}&vs_currencies=${nativeCurrency.toLowerCase()}`);
      const newContractExchangeRates = {};
      Object.keys(response).forEach(contractAddress => {
        newContractExchangeRates[contractAddress] = response[contractAddress][nativeCurrency.toLowerCase()] || 0;
      });
      return newContractExchangeRates;
    }
    const [response, currencyResponse] = await Promise.all([httpHelpers.get(`${this.config.currencyApi}/currency/exchange-rates?platform=${chainCodes.platform}&contract_addresses=${contractAddresses.join(",")}&vs_currencies=${DEFAULT_CURRENCY}`), httpHelpers.get(`${this.config.currencyApi}/currency?fsym=${nativeCurrency.toUpperCase()}&tsyms=${DEFAULT_CURRENCY.toUpperCase()}`)]);
    const newContractExchangeRates = {};
    Object.keys(response).forEach(contractAddress => {
      newContractExchangeRates[contractAddress] = response[contractAddress][DEFAULT_CURRENCY] * Number.parseFloat(currencyResponse[DEFAULT_CURRENCY]) || 0;
    });
    return newContractExchangeRates;
  }
}

exports.DEFAULT_CURRENCY = DEFAULT_CURRENCY;
exports.TokenRatesController = TokenRatesController;
