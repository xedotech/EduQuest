'use strict';

var _objectSpread = require('@babel/runtime/helpers/objectSpread2');
var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var baseControllers = require('@toruslabs/base-controllers');
var ethers = require('ethers');
var log = require('loglevel');
var abis = require('../utils/abis.js');
var constants = require('../utils/constants.js');
var contractAddresses = require('../utils/contractAddresses.js');
var TokenHandler = require('./TokenHandler.js');

const DEFAULT_INTERVAL = 180 * 1000;
class TokensController extends baseControllers.BaseController {
  constructor({
    config,
    state,
    provider,
    idleTimeTracker,
    getCustomTokens,
    getEtherScanTokens,
    getProviderConfig,
    onPreferencesStateChange,
    onNetworkStateChange
  }) {
    super({
      config,
      state
    });
    _defineProperty(this, "name", "TokensController");
    _defineProperty(this, "provider", void 0);
    _defineProperty(this, "ethersProvider", void 0);
    _defineProperty(this, "pollingManager", void 0);
    _defineProperty(this, "getProviderConfig", void 0);
    _defineProperty(this, "getCustomTokens", void 0);
    _defineProperty(this, "getEtherScanTokens", void 0);
    this.provider = provider;
    this.ethersProvider = new ethers.BrowserProvider(this.provider, "any");
    this.getCustomTokens = getCustomTokens;
    this.getEtherScanTokens = getEtherScanTokens;
    this.getProviderConfig = getProviderConfig;
    this.defaultConfig = {
      interval: DEFAULT_INTERVAL,
      selectedAddress: "",
      chainId: ""
    };
    this.defaultState = {
      tokens: {}
    };
    this.initialize();
    onPreferencesStateChange(preferencesState => {
      if (preferencesState.selectedAddress !== this.config.selectedAddress) {
        this.configure({
          selectedAddress: preferencesState.selectedAddress
        });
        this.restartTokenDetection();
      }
    });
    onNetworkStateChange(networkState => {
      const {
        chainId
      } = networkState.providerConfig;
      if (chainId !== this.config.chainId) {
        this.configure({
          chainId
        });
        this.restartTokenDetection();
      }
    });
    this.pollingManager = new baseControllers.PollingManager(idleTimeTracker, this.config.interval);
  }
  get userSelectedAddress() {
    return this.config.selectedAddress;
  }
  get userTokens() {
    var _this$state$tokens$th;
    if (!this.userSelectedAddress) return [];
    return (_this$state$tokens$th = this.state.tokens[this.userSelectedAddress]) !== null && _this$state$tokens$th !== void 0 ? _this$state$tokens$th : [];
  }
  startTokenDetection(selectedAddress) {
    this.configure({
      selectedAddress
    });
    this.restartTokenDetection();
  }
  /**
   * Restart token detection polling period and call detectNewTokens
   * in case of address change or user session initialization.
   *
   */
  restartTokenDetection() {
    if (!this.userSelectedAddress) {
      return;
    }
    this.pollingManager.start(async () => {
      this.detectNewTokens();
      await this.refreshTokenBalances();
    });
  }
  detectNewTokens() {
    const userAddress = this.userSelectedAddress;
    if (!userAddress) return;
    const currentChainId = this.config.chainId;
    const tokens = []; // object[]
    if (!currentChainId) {
      this.update({
        tokens: {
          [userAddress]: [...tokens]
        }
      });
      return;
    }
    const networkConfig = this.getProviderConfig();
    if (networkConfig !== null && networkConfig !== void 0 && networkConfig.isErc20 && networkConfig !== null && networkConfig !== void 0 && networkConfig.tokenAddress) {
      tokens.push({
        tokenAddress: networkConfig.tokenAddress,
        name: networkConfig.tickerName,
        logo: networkConfig.logo,
        erc20: true,
        symbol: networkConfig.ticker,
        decimals: "18",
        chainId: currentChainId
      });
    }
    if (this.getCustomTokens) {
      const customTokens = this.getCustomTokens(userAddress);
      tokens.push(...customTokens.reduce((acc, x) => {
        if (x.network === currentChainId) acc.push({
          tokenAddress: x.token_address,
          name: x.token_name,
          logo: "eth.svg",
          erc20: true,
          symbol: x.token_symbol,
          decimals: x.decimals,
          balance: "",
          customTokenId: x.id.toString(),
          chainId: x.network
        });
        return acc;
      }, []));
    }
    this.update({
      tokens: {
        [userAddress]: [...tokens]
      }
    });
  }
  async refreshTokenBalances(skipCache) {
    const userAddress = this.userSelectedAddress;
    if (userAddress === "") return;
    const oldTokens = [...this.userTokens];
    // - fetch from Etherscan, if failed then fetch from TokenHandler
    // - if there are remaining tokens, fetch either from SingleAddressContract (if failed then use TokenHandler) or TokenHandler
    try {
      const nonZeroTokens = [];
      const currentChainId = this.config.chainId;
      if (constants.MM_TOKEN_API_SUPPORTED_CHAINS.includes(currentChainId)) {
        const etherscanBalances = await this.getEtherScanTokens(userAddress, currentChainId, skipCache);
        nonZeroTokens.push(...etherscanBalances);
      }
      // only fetch balances for tokens that are not already in the nonZeroTokens array
      const remainingTokens = oldTokens.filter(x => !nonZeroTokens.find(y => {
        var _y$tokenAddress, _x$tokenAddress;
        return ((_y$tokenAddress = y.tokenAddress) === null || _y$tokenAddress === void 0 ? void 0 : _y$tokenAddress.toLocaleLowerCase()) === ((_x$tokenAddress = x.tokenAddress) === null || _x$tokenAddress === void 0 ? void 0 : _x$tokenAddress.toLocaleLowerCase());
      }));
      if (remainingTokens.length > 0) {
        const remainingTokensAddresses = remainingTokens.map(x => x.tokenAddress);
        const currentSingleCallAddress = contractAddresses.SINGLE_CALL_BALANCES_ADDRESSES[currentChainId];
        if (currentSingleCallAddress) {
          const ethContract = new ethers.Contract(currentSingleCallAddress, abis.singleBalanceCheckerAbi, this.ethersProvider);
          const result = await ethContract.balances([userAddress], remainingTokensAddresses);
          remainingTokensAddresses.forEach((_, index) => {
            const balance = ethers.toQuantity(result[index]);
            if (balance && balance !== "0x0") {
              nonZeroTokens.push(_objectSpread(_objectSpread({}, remainingTokens[index]), {}, {
                balance,
                chainId: currentChainId
              }));
            }
          });
        } else {
          const fetchedRemainingTokens = await this.getTokenBalancesUsingHandler(remainingTokens);
          nonZeroTokens.push(...fetchedRemainingTokens);
        }
      }
      this.update({
        tokens: {
          [userAddress]: nonZeroTokens
        }
      });
    } catch (error) {
      log.error(error, "unable to fetch token balances using single call balance address");
      const fetchedTokens = await this.getTokenBalancesUsingHandler(oldTokens);
      this.update({
        tokens: {
          [userAddress]: fetchedTokens
        }
      });
    }
  }
  async getTokenBalancesUsingHandler(customTokens) {
    if (!this.userSelectedAddress) return [];
    const currentNetworkTokens = customTokens;
    const promiseSettledResult = await Promise.allSettled(currentNetworkTokens.map(async x => {
      try {
        const tokenInstance = new TokenHandler.TokenHandler({
          address: x.tokenAddress,
          decimals: Number.parseInt(x.decimals),
          name: x.name,
          symbol: x.symbol,
          provider: this.ethersProvider
        });
        const balance = await tokenInstance.getUserBalance(this.userSelectedAddress);
        return {
          decimals: tokenInstance.decimals.toString(),
          erc20: true,
          logo: x.logo || "eth.svg",
          name: tokenInstance.name,
          symbol: tokenInstance.symbol,
          tokenAddress: tokenInstance.address,
          balance: `0x${balance}`,
          customTokenId: x.customTokenId,
          network: x.chainId,
          chainId: x.chainId
        };
      } catch (error) {
        log.warn("could not fetch user token balance", error);
        return undefined;
      }
    }));
    const nonZeroTokens = promiseSettledResult.reduce((acc, x) => {
      if (x.status === "fulfilled" && x.value) acc.push(x.value);
      return acc;
    }, []);
    return nonZeroTokens;
  }
}

exports.TokensController = TokensController;
