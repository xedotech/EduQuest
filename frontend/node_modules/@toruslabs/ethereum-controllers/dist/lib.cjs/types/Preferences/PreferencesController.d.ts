import { BasePreferencesController, CustomNft, CustomToken, InitPreferencesParams, IPreferencesController, PreferencesConfig, PreferencesState } from "@toruslabs/base-controllers";
import { SafeEventEmitterProvider } from "@web3auth/auth";
import { KeyringController } from "../Keyring/KeyringController";
import { NetworkController } from "../Network/NetworkController";
import { EthereumNftInfo as CustomNftInfo } from "../Nfts/INftsController";
import type { AddChainMessageParams, CustomNetworkPayload, CustomTokenInfo, EtherscanTransaction, TransactionPayload } from "../utils/interfaces";
import { ExtendedAddressPreferences } from "./IPreferencesController";
export interface IPreferencesControllerOptions {
    config?: Partial<PreferencesConfig> & Pick<PreferencesConfig, "api" | "commonApiHost">;
    state?: Partial<PreferencesState<ExtendedAddressPreferences>>;
    provider: SafeEventEmitterProvider;
    signAuthMessage?: KeyringController["signAuthMessage"];
    getProviderConfig?: NetworkController["getProviderConfig"];
    setProviderConfig?: NetworkController["setProviderConfig"];
    validateSignMessage: (message: string) => Promise<void>;
}
export declare class PreferencesController extends BasePreferencesController<ExtendedAddressPreferences, PreferencesConfig, PreferencesState<ExtendedAddressPreferences>> implements IPreferencesController<ExtendedAddressPreferences, PreferencesConfig, PreferencesState<ExtendedAddressPreferences>> {
    protected chainNamespace: "eip155";
    private _handle?;
    private _mutex;
    private getProviderConfig;
    private setProviderConfig;
    private provider;
    constructor({ config, state, provider, signAuthMessage, getProviderConfig, setProviderConfig, validateSignMessage, }: IPreferencesControllerOptions);
    poll(interval?: number): Promise<void>;
    initPreferences(params: InitPreferencesParams & {
        eoaAddress?: string;
        aaProvider?: string;
        mainAddress?: string;
    }): Promise<void>;
    getSelectedAddress(): string;
    sync(address: string): Promise<boolean>;
    patchNewTx(tx: TransactionPayload, address: string): Promise<void>;
    recalculatePastTx(address?: string): void;
    refetchEtherscanTx(address?: string): Promise<EtherscanTransaction[]>;
    fetchEtherscanTx<T>(parameters: {
        selectedAddress: string;
        chainId: string;
    }): Promise<T[]>;
    fetchQuote<T>(parameters: {
        chainId: string;
        fromToken: string;
        toToken: string;
        fromValue: string;
        recipient: string;
        nativeToken: {
            chainId: string;
            name: string;
            symbol: string;
            logoURI: string;
            decimals: number;
        };
        slippageTolerance?: string;
        transactionDeadline?: number;
    }): Promise<T[]>;
    getEtherScanTokens(address: string, chainId: string, skipCache?: boolean): Promise<CustomTokenInfo[]>;
    getSimpleHashNfts(address: string, chainId: string, skipCache?: boolean): Promise<CustomNftInfo[]>;
    getCustomTokens(address?: string): CustomToken[];
    getCustomNfts(address?: string): CustomNft[];
    isChainIdSupported(address: string, chainId: string): boolean;
    addChain(network: AddChainMessageParams): Promise<void>;
    switchChain(data: {
        chainId: string;
    }): void;
    addCustomNetwork({ network }: {
        network: CustomNetworkPayload;
    }): Promise<number>;
    deleteCustomNetwork(id: number): Promise<boolean>;
    editCustomNetwork({ network, id }: {
        network: CustomNetworkPayload;
        id: number | null;
    }): Promise<boolean>;
    private getChainOptions;
    private getBlockExplorerUrl;
    private calculatePastTx;
    private cancelTxCalculate;
}
