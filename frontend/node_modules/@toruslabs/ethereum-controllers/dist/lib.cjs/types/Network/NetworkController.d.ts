import { type Analytics, BaseController, IdleTimeTracker, INetworkController } from "@toruslabs/base-controllers";
import { SafeEventEmitterProvider } from "@web3auth/auth";
import { PollingBlockTracker } from "../Block/PollingBlockTracker";
import { EthereumNetworkConfig, EthereumNetworkState, EthereumProviderConfig, NetworkControllerEvents } from "../utils/interfaces";
import { IProviderHandlers } from "./createEthereumMiddleware";
export declare class NetworkController extends BaseController<EthereumNetworkConfig, EthereumNetworkState, NetworkControllerEvents<EthereumNetworkState>> implements INetworkController<EthereumNetworkConfig, EthereumNetworkState> {
    name: string;
    providerProxy: SafeEventEmitterProvider;
    blockTrackerProxy: PollingBlockTracker;
    private mutex;
    private provider?;
    private blockTracker?;
    private baseProviderHandlers;
    private idleTimeTracker;
    private analytics?;
    constructor({ config, state, idleTimeTracker, analytics, }: {
        config?: Partial<EthereumNetworkConfig>;
        state?: Partial<EthereumNetworkState>;
        idleTimeTracker: IdleTimeTracker;
        analytics: Analytics;
    });
    getNetworkIdentifier(): string;
    getNetworkRPCUrl(): string;
    /**
     * Called by orchestrator once while initializing the class
     * @param providerHandlers - JRPC handlers for provider
     * @returns - provider - Returns the providerProxy
     */
    initializeProvider(providerHandlers: IProviderHandlers): SafeEventEmitterProvider;
    getProvider(): SafeEventEmitterProvider;
    getBlockTracker(): PollingBlockTracker;
    getProviderConfig(): EthereumProviderConfig;
    setProviderConfig(config: EthereumProviderConfig): void;
    getEIP1559Compatibility(): Promise<boolean>;
    /**
     * Refreshes the current network code
     */
    lookupNetwork(): Promise<void>;
    private configureProvider;
    private setNetworkClient;
    private setProvider;
    private configureStandardProvider;
    private refreshNetwork;
}
