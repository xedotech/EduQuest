import { type Analytics, InPageWalletProviderState, MessageParams, type ProviderConfig, SwitchChainMessageParams, UserRequestApprovalParams } from "@toruslabs/base-controllers";
import { JRPCEngineEndCallback, JRPCEngineNextCallback, JRPCMiddleware, JRPCRequest, JRPCResponse } from "@web3auth/auth";
import { AddChainMessageParams, BlockParams, EthereumTransactionMeta, TransactionParams, TransactionRPCMeta, TypedMessageParams, UserOperationGas } from "../utils/interfaces";
export interface IProviderHandlers {
    version: string;
    aaConfig?: {
        bundlerUrl: string;
        paymasterUrl?: string;
    };
    requestAccounts?: (req: JRPCRequest<string[]>) => Promise<string[]>;
    getAccounts: (req: JRPCRequest<string[]>) => Promise<string[]>;
    getPrivateKey?: (req: JRPCRequest<unknown>) => Promise<string>;
    getPublicKey?: (req: JRPCRequest<unknown>) => Promise<string>;
    processTransaction?: (txParams: TransactionParams, req: JRPCRequest<TransactionParams> & UserRequestApprovalParams) => Promise<string>;
    processSignTransaction?: (txParams: TransactionParams, req: JRPCRequest<TransactionParams> & UserRequestApprovalParams) => Promise<string>;
    processEthSignMessage?: (msgParams: MessageParams, req: JRPCRequest<unknown> & UserRequestApprovalParams) => Promise<string>;
    processTypedMessageV4?: (msgParams: TypedMessageParams, req: JRPCRequest<unknown> & UserRequestApprovalParams) => Promise<string>;
    processPersonalMessage?: (msgParams: MessageParams, req: JRPCRequest<unknown> & UserRequestApprovalParams) => Promise<string>;
    processSwitchEthereumChain?: (msgParams: SwitchChainMessageParams, req: JRPCRequest<unknown> & UserRequestApprovalParams) => Promise<string>;
    processWalletSwitchChain?: (msgParams: SwitchChainMessageParams, req: JRPCRequest<unknown> & UserRequestApprovalParams) => Promise<string>;
    processAddEthereumChain?: (msgParams: AddChainMessageParams, req: JRPCRequest<unknown> & UserRequestApprovalParams) => Promise<string>;
    processEstimateUserOperationGas?: (txParams: TransactionParams, req: JRPCRequest<TransactionParams>) => Promise<UserOperationGas>;
    getPendingNonce?: (nonceParams: {
        address: string;
        blockReference: string;
    }, req: JRPCRequest<{
        address: string;
        blockReference: string;
    }>) => Promise<string>;
    getPendingTransactionByHash?: (hash: string, req: JRPCRequest<string>) => Promise<EthereumTransactionMeta>;
    getProviderState: (req: JRPCRequest<[]>, res: JRPCResponse<InPageWalletProviderState>, next: JRPCEngineNextCallback, end: JRPCEngineEndCallback) => void;
}
export declare function createGetAccountsMiddleware({ getAccounts }: {
    getAccounts: IProviderHandlers["getAccounts"];
}): JRPCMiddleware<never, string[]>;
export declare function createProcessTransactionMiddleware({ processTransaction, }: {
    processTransaction: IProviderHandlers["processTransaction"];
}): JRPCMiddleware<TransactionParams, string>;
export declare function createProcessSignTransactionMiddleware({ processSignTransaction, }: {
    processSignTransaction: IProviderHandlers["processTransaction"];
}): JRPCMiddleware<TransactionParams, string>;
export declare function createProcessEstimateUserOperationGasMiddleware({ processEstimateUserOperationGas, }: {
    processEstimateUserOperationGas: IProviderHandlers["processEstimateUserOperationGas"];
}): JRPCMiddleware<TransactionParams, string | UserOperationGas>;
export declare function createProcessEthSignMessage({ processEthSignMessage, }: {
    processEthSignMessage: IProviderHandlers["processEthSignMessage"];
}): JRPCMiddleware<unknown, string>;
export declare function createProcessTypedMessageV4({ processTypedMessageV4, }: {
    processTypedMessageV4: IProviderHandlers["processTypedMessageV4"];
}): JRPCMiddleware<unknown, string>;
export declare function createProcessPersonalMessage({ processPersonalMessage, }: {
    processPersonalMessage: IProviderHandlers["processPersonalMessage"];
}): JRPCMiddleware<unknown, string>;
export declare function createPendingNonceMiddleware({ getPendingNonce, }: {
    getPendingNonce: IProviderHandlers["getPendingNonce"];
}): JRPCMiddleware<{
    address: string;
    blockReference: BlockParams;
}, string>;
export declare function formatTxMetaForRpcResult(txMeta: EthereumTransactionMeta): TransactionRPCMeta;
export declare function createPendingTxMiddleware({ getPendingTransactionByHash, }: {
    getPendingTransactionByHash: IProviderHandlers["getPendingTransactionByHash"];
}): JRPCMiddleware<string, TransactionRPCMeta>;
export declare function createProcessSwitchEthereumChain({ processSwitchEthereumChain, }: {
    processSwitchEthereumChain: IProviderHandlers["processSwitchEthereumChain"];
}): JRPCMiddleware<unknown, string>;
export declare function createProcessWalletSwitchChain({ processWalletSwitchChain, }: {
    processWalletSwitchChain: IProviderHandlers["processWalletSwitchChain"];
}): JRPCMiddleware<unknown, string>;
export declare function createProcessAddEthereumChain({ processAddEthereumChain, }: {
    processAddEthereumChain: IProviderHandlers["processAddEthereumChain"];
}): JRPCMiddleware<unknown, string>;
export declare function createRequestAccountsMiddleware({ requestAccounts, }: {
    requestAccounts: IProviderHandlers["requestAccounts"];
}): JRPCMiddleware<string[], unknown>;
/**
 * Middleware to handle bundler/paymaster rpc method
 */
export declare function createAAMiddleware({ bundlerUrl, paymasterUrl, providerConfig, analytics, }: {
    bundlerUrl: string;
    paymasterUrl?: string;
    providerConfig: ProviderConfig;
    analytics?: Analytics;
}): JRPCMiddleware<unknown, unknown>;
export declare function createEthereumMiddleware(providerHandlers: IProviderHandlers, providerConfig?: ProviderConfig, analytics?: Analytics): JRPCMiddleware<unknown, unknown>;
