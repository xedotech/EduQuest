import { AccountTrackerConfig, AccountTrackerState, BaseController, IAccountTrackerController, PreferencesState } from "@toruslabs/base-controllers";
import { SafeEventEmitterProvider } from "@web3auth/auth";
import { PollingBlockTracker } from "../Block/PollingBlockTracker";
import { NetworkController } from "../Network/NetworkController";
import { ExtendedAddressPreferences } from "../Preferences/IPreferencesController";
import { EthereumBlock } from "../utils/interfaces";
interface AccountTrackerControllerOptions {
    config: AccountTrackerConfig<EthereumBlock>;
    state: Partial<AccountTrackerState>;
    provider: SafeEventEmitterProvider;
    blockTracker?: PollingBlockTracker;
    getIdentities: () => PreferencesState<ExtendedAddressPreferences>["identities"];
    onPreferencesStateChange: (listener: (preferencesState: PreferencesState<ExtendedAddressPreferences>) => void) => void;
    getCurrentChainId: NetworkController["getNetworkIdentifier"];
}
/**
 * Tracks accounts based on blocks.
 * If block tracker provides latest block, we query accounts from it.
 * Preferences state changes also retrigger accounts update.
 * Network state changes also retrigger accounts update.
 */
export declare class AccountTrackerController extends BaseController<AccountTrackerConfig<EthereumBlock>, AccountTrackerState> implements IAccountTrackerController<AccountTrackerConfig<EthereumBlock>, AccountTrackerState> {
    private provider;
    private blockTracker;
    private mutex;
    private ethersProvider;
    private getIdentities;
    private getCurrentChainId;
    constructor({ config, state, provider, blockTracker, getIdentities, onPreferencesStateChange, getCurrentChainId, }: AccountTrackerControllerOptions);
    blockTrackerListener(): void;
    startPolling(): void;
    stopPolling(): void;
    syncAccounts(): boolean;
    refresh(): Promise<void>;
    private _updateAccounts;
    private _updateAccount;
    private _updateAccountsViaBalanceChecker;
}
export {};
