import _defineProperty from '@babel/runtime/helpers/defineProperty';
import { stripHexPrefix } from '@ethereumjs/util';
import { BasePreferencesController, CHAIN_NAMESPACES, isUnauthorizedError, TransactionStatus } from '@toruslabs/base-controllers';
import { Mutex } from 'async-mutex';
import log from 'loglevel';
import { MM_TOKEN_API_SUPPORTED_CHAINS, SUPPORTED_NETWORKS } from '../utils/constants.js';
import { formatPastTx, addEtherscanTransactions, getEthTxStatus, formatTime, formatDate } from '../utils/helpers.js';

class PreferencesController extends BasePreferencesController {
  constructor({
    config,
    state,
    provider,
    signAuthMessage,
    getProviderConfig,
    setProviderConfig,
    validateSignMessage
  }) {
    super({
      config,
      state,
      defaultPreferences: {
        formattedPastTransactions: [],
        fetchedPastTx: [],
        paymentTx: [],
        etherscanTransactions: []
      },
      signAuthMessage,
      validateSignMessage
    });
    _defineProperty(this, "chainNamespace", CHAIN_NAMESPACES.EIP155);
    _defineProperty(this, "_handle", void 0);
    _defineProperty(this, "_mutex", new Mutex());
    _defineProperty(this, "getProviderConfig", void 0);
    _defineProperty(this, "setProviderConfig", void 0);
    _defineProperty(this, "provider", void 0);
    this.provider = provider;
    this.getProviderConfig = getProviderConfig;
    this.setProviderConfig = setProviderConfig;
  }
  async poll(interval) {
    var _this$getAddressState;
    const releaseLock = await this._mutex.acquire();
    if (interval) this.configure({
      pollInterval: interval
    });
    if (this._handle) window.clearTimeout(this._handle);
    // call here
    const storeSelectedAddress = this.state.selectedAddress;
    if (!storeSelectedAddress) return;
    if (!((_this$getAddressState = this.getAddressState(storeSelectedAddress)) !== null && _this$getAddressState !== void 0 && _this$getAddressState.jwtToken)) return;
    // This should never throw
    await this.sync(storeSelectedAddress);
    releaseLock();
    this._handle = window.setTimeout(() => {
      this.poll(this.config.pollInterval);
    }, this.config.pollInterval);
  }
  async initPreferences(params) {
    const {
      address,
      jwtToken,
      calledFromEmbed,
      userInfo,
      rehydrate,
      locale = "en",
      type,
      signatures,
      web3AuthClientId,
      web3AuthNetwork,
      loginMode,
      sessionPubKey,
      aaProvider,
      eoaAddress,
      mainAddress
    } = params;
    const {
      chainId
    } = this.getProviderConfig();
    await super.init({
      address,
      userInfo,
      idToken: jwtToken,
      type,
      metadata: {
        email: userInfo.email,
        signatures,
        network: web3AuthNetwork,
        eoa_address: eoaAddress,
        aa_provider: aaProvider,
        chain_id: chainId,
        main_address: mainAddress
      }
    });
    const {
      groupedAuthConnectionId,
      authConnectionId,
      userId
    } = userInfo || {};
    const userExists = await this.sync(address);
    if (!userExists) {
      const accountState = this.getAddressState(address);
      await this.createUser({
        selectedCurrency: accountState.selectedCurrency,
        theme: accountState.theme,
        groupedAuthConnectionId,
        authConnectionId,
        userId,
        locale,
        address,
        type,
        web3AuthNetwork,
        metadata: {
          aa_provider: aaProvider,
          chain_id: chainId,
          eoa_address: eoaAddress
        }
      });
    }
    if (eoaAddress) this.updateState({
      eoaAddress
    }, address);
    this.storeUserLogin({
      groupedAuthConnectionId,
      authConnectionId,
      userId,
      options: {
        calledFromEmbed,
        rehydrate
      },
      address,
      web3AuthClientId,
      web3AuthNetwork,
      sessionPubKey,
      loginMode
    });
  }
  getSelectedAddress() {
    return this.state.selectedAddress;
  }
  async sync(address) {
    try {
      const user = await this.getUser(address);
      if (user) {
        const {
          default_currency: defaultCurrency,
          contacts,
          theme,
          locale,
          public_address: userPublicAddress,
          default_public_address: defaultPublicAddress,
          customNetworks,
          customTokens,
          customNfts,
          account_type: accountType
        } = user || {};

        // update latest data in state.
        this.updateState({
          contacts,
          theme,
          selectedCurrency: defaultCurrency,
          locale,
          defaultPublicAddress: defaultPublicAddress || userPublicAddress,
          customTokens,
          customNfts,
          customNetworks,
          accountType: accountType
        }, address);
        return true;
      }
      return false;
    } catch (error) {
      if (isUnauthorizedError(error)) {
        throw error;
      }
      log.error(error);
      return false;
    } finally {
      this.getWalletOrders(address).then(walletTx => {
        // eslint-disable-next-line promise/always-return
        if (walletTx && walletTx.length > 0) {
          this.updateState({
            fetchedPastTx: [...walletTx]
          }, address);
          this.calculatePastTx(walletTx, address);
        }
      }).catch(error => log.error(error));
    }
  }
  async patchNewTx(tx, address) {
    var _this$getAddressState2;
    const formattedTx = formatPastTx({
      transaction: tx,
      blockExplorerUrl: this.getBlockExplorerUrl()
    });
    const storePastTx = ((_this$getAddressState2 = this.getAddressState(address)) === null || _this$getAddressState2 === void 0 ? void 0 : _this$getAddressState2.formattedPastTransactions) || [];
    const duplicateIndex = storePastTx.findIndex(x => x.transaction_hash === tx.transaction_hash && x.chainId === tx.chain_id);
    if (tx.status === TransactionStatus.submitted || tx.status === TransactionStatus.confirmed) {
      if (duplicateIndex === -1) {
        var _tx$to;
        // No duplicate found

        const finalTx = this.cancelTxCalculate([...storePastTx, formattedTx]);
        tx.is_cancel = formattedTx.is_cancel;
        tx.to = (_tx$to = tx.to) === null || _tx$to === void 0 ? void 0 : _tx$to.toLowerCase();
        tx.from = tx.from.toLowerCase();
        this.updateState({
          formattedPastTransactions: finalTx
        }, address);
        this.postPastTx(tx, address);
      } else {
        // avoid overriding is_cancel
        formattedTx.is_cancel = storePastTx[duplicateIndex].is_cancel;
        storePastTx[duplicateIndex] = formattedTx;
        this.updateState({
          formattedPastTransactions: this.cancelTxCalculate([...storePastTx])
        }, address);
      }
    }
  }
  recalculatePastTx(address) {
    // This triggers store update which calculates past Tx status for that network
    const selectedAddress = address || this.state.selectedAddress;
    const state = this.getAddressState(selectedAddress);
    if (!(state !== null && state !== void 0 && state.fetchedPastTx)) return;
    this.calculatePastTx(state.fetchedPastTx, selectedAddress);
  }
  async refetchEtherscanTx(address) {
    var _this$getAddressState3;
    const selectedAddress = address || this.state.selectedAddress;
    if (!selectedAddress) return [];
    const lowerCaseSelectedAddress = selectedAddress === null || selectedAddress === void 0 ? void 0 : selectedAddress.toLowerCase();
    if ((_this$getAddressState3 = this.getAddressState(selectedAddress)) !== null && _this$getAddressState3 !== void 0 && _this$getAddressState3.jwtToken) {
      const {
        chainId
      } = this.getProviderConfig();
      if (MM_TOKEN_API_SUPPORTED_CHAINS.includes(chainId)) {
        const etherscanTxn = await this.fetchEtherscanTx({
          selectedAddress,
          chainId: this.getProviderConfig().chainId
        });
        const finalEthScanTxn = await addEtherscanTransactions({
          txn: etherscanTxn,
          lowerCaseSelectedAddress,
          provider: this.provider,
          chainId,
          blockExplorerUrl: this.getBlockExplorerUrl()
        });
        log.info("Formatted Etherscan Response", finalEthScanTxn);
        this.updateState({
          etherscanTransactions: finalEthScanTxn
        });
        return etherscanTxn;
      }
    }
  }
  async fetchEtherscanTx(parameters) {
    try {
      const response = await this.wsApiClient.authGet(`etherscan?chainId=${parameters.chainId}`, this.authCredentials(parameters.selectedAddress));
      log.info("Etherscan Response API", response);
      return response.success ? response.data : [];
    } catch (error) {
      log.error("unable to fetch etherscan tx", error);
      return [];
    }
  }
  async fetchQuote(parameters) {
    try {
      const response = await this.wsApiClient.authPost("quote", parameters, this.authCredentials());
      return response.success ? response.data : [];
    } catch (error) {
      log.error("unable to get swap quote", error);
      return [];
    }
  }
  async getEtherScanTokens(address, chainId, skipCache) {
    const selectedAddress = address;
    let path = `tokens?chainId=${chainId}&address=${selectedAddress}`;
    if (skipCache) {
      path += `&skipCache=true`;
    }
    const result = await this.wsApiClient.authGet(path, this.authCredentials());
    return result.data;
  }
  async getSimpleHashNfts(address, chainId, skipCache) {
    const selectedAddress = address;
    let path = `nfts?chainId=${chainId}&address=${selectedAddress}`;
    if (skipCache) {
      path += `&skipCache=true`;
    }
    const result = await this.wsApiClient.authGet(path, this.authCredentials());
    return result.data;
  }
  getCustomTokens(address) {
    var _this$getAddressState4, _this$getAddressState5;
    return (_this$getAddressState4 = (_this$getAddressState5 = this.getAddressState(address)) === null || _this$getAddressState5 === void 0 ? void 0 : _this$getAddressState5.customTokens) !== null && _this$getAddressState4 !== void 0 ? _this$getAddressState4 : [];
  }
  getCustomNfts(address) {
    var _this$getAddressState6, _this$getAddressState7;
    return (_this$getAddressState6 = (_this$getAddressState7 = this.getAddressState(address)) === null || _this$getAddressState7 === void 0 ? void 0 : _this$getAddressState7.customNfts) !== null && _this$getAddressState6 !== void 0 ? _this$getAddressState6 : [];
  }
  isChainIdSupported(address, chainId) {
    const approveChainOptions = this.getChainOptions(address);
    const providerConfig = approveChainOptions.find(x => stripHexPrefix(x.chainId) === chainId);
    return !!providerConfig;
  }
  async addChain(network) {
    const approveChainOptions = this.getChainOptions();
    const providerConfig = approveChainOptions.find(x => x.chainId === network.chainId);
    if (providerConfig) return;
    const newNetwork = {
      displayName: network.chainName,
      rpcTarget: network.rpcUrls[0],
      ticker: network.nativeCurrency.symbol,
      chainId: network.chainId,
      blockExplorerUrl: network.blockExplorerUrls[0],
      tickerName: network.nativeCurrency.name,
      logo: network.nativeCurrency.symbol
    };
    const isSuccess = await this.addCustomNetwork({
      network: newNetwork
    });
    if (!isSuccess) throw new Error("unable to add custom network");
  }
  switchChain(data) {
    const chainOptions = this.getChainOptions();
    const providerConfig = chainOptions.find(x => x.chainId === data.chainId);
    if (providerConfig) {
      this.setProviderConfig(providerConfig);
    } else {
      throw new Error(`chainId ${data.chainId} is not supported`);
    }
  }

  // Custom Network methods
  async addCustomNetwork({
    network
  }) {
    try {
      const {
        selectedAddress
      } = this.state;
      const payload = {
        network_name: network.displayName,
        rpc_url: network.rpcTarget,
        chain_id: network.chainId,
        symbol: network.ticker,
        block_explorer_url: network.blockExplorerUrl || undefined,
        is_testnet: network.isTestnet || false,
        logo: network.logo,
        symbol_name: network.tickerName
      };
      const res = await this.wsApiClient.authPost("customnetwork", payload, this.authCredentials(selectedAddress), {
        useAPIKey: true
      });
      await this.sync(selectedAddress);
      return res.data.id;
    } catch {
      log.error("error adding custom network");
      return null;
    }
  }
  async deleteCustomNetwork(id) {
    try {
      const {
        selectedAddress
      } = this.state;
      await this.wsApiClient.authRemove(`customnetwork/${id}`, {}, this.authCredentials(selectedAddress), {
        useAPIKey: true
      });
      await this.sync(selectedAddress);
      return true;
    } catch {
      log.error("error deleting custom network");
      return false;
    }
  }
  async editCustomNetwork({
    network,
    id
  }) {
    try {
      const {
        selectedAddress
      } = this.state;
      const payload = {
        network_name: network.displayName,
        rpc_url: network.rpcTarget,
        chain_id: network.chainId,
        symbol: network.ticker || undefined,
        block_explorer_url: network.blockExplorerUrl || undefined,
        is_testnet: network.isTestnet || false
      };
      await this.wsApiClient.authPatch(`customnetwork/${id}`, payload, this.authCredentials(selectedAddress), {
        useAPIKey: true
      });
      await this.sync(selectedAddress);
      return true;
    } catch {
      log.error("error editing custom network");
      return false;
    }
  }
  getChainOptions(address = this.state.selectedAddress) {
    var _identities$address$c, _identities$address;
    const {
      identities
    } = this.state;
    const customNetworks = (_identities$address$c = (_identities$address = identities[address]) === null || _identities$address === void 0 ? void 0 : _identities$address.customNetworks) !== null && _identities$address$c !== void 0 ? _identities$address$c : [];
    const custom = Object.values(customNetworks).reduce((chains, network) => {
      const networkItem = {
        blockExplorerUrl: network.block_explorer_url,
        chainId: network.chain_id,
        displayName: network.network_name,
        logo: "eth.svg",
        rpcTarget: network.rpc_url,
        ticker: network.symbol,
        tickerName: network.symbol.toUpperCase(),
        isCustom: true,
        id: network.id
      };
      if (Object.keys(SUPPORTED_NETWORKS).includes(networkItem.chainId)) return chains;
      chains.push(networkItem);
      return chains;
    }, []);
    const supported = Object.values(SUPPORTED_NETWORKS).reduce((chains, network) => {
      chains.push(network);
      return chains;
    }, []);
    return [...supported, ...custom];
  }
  getBlockExplorerUrl() {
    const supportedNetworks = this.getChainOptions();
    const network = supportedNetworks.find(x => x.chainId === this.getProviderConfig().chainId);
    if (!network) return "";
    return `${network.blockExplorerUrl}`;
  }
  async calculatePastTx(txs, address) {
    const pastTx = [];
    const pendingTx = [];
    const lowerCaseSelectedAddress = address.toLowerCase();
    const supportedNetworks = this.getChainOptions(address);
    const supportedNetwork = supportedNetworks.find(x => x.chainId === this.getProviderConfig().chainId);
    for (const x of txs) {
      var _x$to;
      if ((supportedNetwork === null || supportedNetwork === void 0 ? void 0 : supportedNetwork.chainId) === x.chain_id && x.to && x.from && (lowerCaseSelectedAddress === x.from.toLowerCase() || lowerCaseSelectedAddress === ((_x$to = x.to) === null || _x$to === void 0 ? void 0 : _x$to.toLowerCase()))) {
        if (x.status !== "confirmed") {
          pendingTx.push(x);
        } else {
          const finalObject = formatPastTx({
            transaction: x,
            lowerCaseSelectedAddress,
            blockExplorerUrl: this.getBlockExplorerUrl()
          });
          pastTx.push(finalObject);
        }
      }
    }
    const pendingTxPromises = pendingTx.map(x => getEthTxStatus(x.transaction_hash, this.provider).catch(error => log.error(error)));
    const resolvedTxStatuses = await Promise.all(pendingTxPromises);
    for (const [index, element] of pendingTx.entries()) {
      const finalObject = formatPastTx({
        transaction: element,
        lowerCaseSelectedAddress,
        blockExplorerUrl: this.getBlockExplorerUrl()
      });
      finalObject.status = resolvedTxStatuses[index] || TransactionStatus.submitted;
      pastTx.push(finalObject);
      if (lowerCaseSelectedAddress === element.from.toLowerCase() && finalObject.status && finalObject.status !== element.status) this.patchPastTx({
        id: element.id,
        status: finalObject.status
      }, address);
    }
    const finalTx = this.cancelTxCalculate(pastTx);
    this.updateState({
      formattedPastTransactions: [...finalTx]
    }, address);
  }
  cancelTxCalculate(pastTx) {
    const nonceMap = {};
    for (const x of pastTx) {
      if (!nonceMap[x.nonce]) nonceMap[x.nonce] = [x];else {
        nonceMap[x.nonce].push(x);
      }
    }
    for (const [, value] of Object.entries(nonceMap)) {
      // has duplicate
      if (value.length > 1) {
        // get latest and mark it as is_cancel
        const latestTxs = value.sort((a, b) => {
          const aDate = new Date(a.date).getTime();
          const bDate = new Date(b.date).getTime();
          return bDate - aDate;
        });
        const latestCancelTx = latestTxs[0];
        latestCancelTx.is_cancel = true;
        latestTxs.slice(1).forEach(x => {
          x.hasCancel = true;
          x.status = latestCancelTx.status === "confirmed" ? TransactionStatus.cancelled : TransactionStatus.cancelling;
          x.cancelDateInitiated = `${formatTime(new Date(latestCancelTx.date).getTime())} - ${formatDate(latestCancelTx.date)}`;
          x.etherscanLink = latestCancelTx.etherscanLink;
          x.cancelGas = latestCancelTx.gas;
          x.cancelGasPrice = latestCancelTx.gasPrice;
        });
      }
    }
    return pastTx;
  }
}

export { PreferencesController };
