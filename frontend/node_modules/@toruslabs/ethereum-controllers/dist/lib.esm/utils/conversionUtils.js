import _objectDestructuringEmpty from '@babel/runtime/helpers/objectDestructuringEmpty';
import _objectSpread from '@babel/runtime/helpers/objectSpread2';
import _objectWithoutProperties from '@babel/runtime/helpers/objectWithoutProperties';
import { stripHexPrefix } from '@ethereumjs/util';
import { BigNumber } from 'bignumber.js';
import BN from 'bn.js';

const _excluded = ["aBase", "bBase"],
  _excluded2 = ["aBase", "bBase"],
  _excluded3 = ["multiplicandBase", "multiplierBase"];

// Big Number Constants
const BIG_NUMBER_WEI_MULTIPLIER = new BigNumber("1000000000000000000");
const BIG_NUMBER_GWEI_MULTIPLIER = new BigNumber("1000000000");
const BIG_NUMBER_ETH_MULTIPLIER = new BigNumber("1");
// Setter Maps
const toBigNumber = {
  hex: n => new BigNumber(stripHexPrefix(n), 16),
  dec: n => new BigNumber(String(n), 10),
  BN: n => new BigNumber(n.toString(16), 16)
};
const toNormalizedDenomination = {
  WEI: bigNumber => bigNumber.div(BIG_NUMBER_WEI_MULTIPLIER),
  GWEI: bigNumber => bigNumber.div(BIG_NUMBER_GWEI_MULTIPLIER),
  ETH: bigNumber => bigNumber.div(BIG_NUMBER_ETH_MULTIPLIER)
};
const toSpecifiedDenomination = {
  WEI: bigNumber => bigNumber.times(BIG_NUMBER_WEI_MULTIPLIER).dp(0, BigNumber.ROUND_HALF_UP),
  GWEI: bigNumber => bigNumber.times(BIG_NUMBER_GWEI_MULTIPLIER).dp(9, BigNumber.ROUND_HALF_UP),
  ETH: bigNumber => bigNumber.times(BIG_NUMBER_ETH_MULTIPLIER).dp(9, BigNumber.ROUND_HALF_UP)
};
const baseChange = {
  hex: n => n.toString(16),
  dec: n => new BigNumber(n).toString(10),
  BN: n => new BN(n.toString(16))
};

// Utility function for checking base types
const isValidBase = base => Number.isInteger(base) && base > 1;

/**
 * Utility method to convert a value between denominations, formats and currencies.
 */
const converter = ({
  value,
  fromNumericBase,
  fromDenomination,
  fromCurrency,
  toNumericBase,
  toDenomination,
  toCurrency,
  numberOfDecimals,
  conversionRate,
  invertConversionRate,
  roundDown
}) => {
  let convertedValue = fromNumericBase ? toBigNumber[fromNumericBase](value) : value;
  if (fromDenomination) {
    convertedValue = toNormalizedDenomination[fromDenomination](convertedValue);
  }
  if (fromCurrency !== toCurrency) {
    if (conversionRate === null || conversionRate === undefined) {
      throw new Error(`Converting from ${fromCurrency} to ${toCurrency} requires a conversionRate, but one was not provided`);
    }
    let rate = toBigNumber.dec(conversionRate);
    if (invertConversionRate) {
      rate = new BigNumber(1).div(conversionRate);
    }
    convertedValue = convertedValue.times(rate);
  }
  if (toDenomination) {
    convertedValue = toSpecifiedDenomination[toDenomination](convertedValue);
  }
  if (numberOfDecimals) {
    convertedValue = convertedValue.dp(numberOfDecimals, BigNumber.ROUND_HALF_DOWN);
  }
  if (roundDown) {
    convertedValue = convertedValue.dp(roundDown, BigNumber.ROUND_DOWN);
  }
  if (toNumericBase) {
    convertedValue = baseChange[toNumericBase](convertedValue);
  }
  return convertedValue;
};
const conversionUtil = (value, {
  fromCurrency = null,
  toCurrency = fromCurrency,
  fromNumericBase,
  toNumericBase,
  fromDenomination,
  toDenomination,
  numberOfDecimals,
  conversionRate,
  invertConversionRate
}) => {
  if (fromCurrency !== toCurrency && !conversionRate) {
    return 0;
  }
  return converter({
    fromCurrency,
    toCurrency,
    fromNumericBase,
    toNumericBase,
    fromDenomination,
    toDenomination,
    numberOfDecimals,
    conversionRate,
    invertConversionRate,
    value
  });
};
const getBigNumber = (value, base) => {
  if (!isValidBase(base)) {
    throw new Error("Must specificy valid base");
  }

  // We don't include 'number' here, because BigNumber will throw if passed
  // a number primitive it considers unsafe.
  if (typeof value === "string" || value instanceof BigNumber) {
    return new BigNumber(value, base);
  }
  return new BigNumber(String(value), base);
};
const addCurrencies = (a, b, options = {}) => {
  const {
      aBase,
      bBase
    } = options,
    conversionOptions = _objectWithoutProperties(options, _excluded);
  if (!isValidBase(aBase) || !isValidBase(bBase)) {
    throw new Error("Must specify valid aBase and bBase");
  }
  const value = getBigNumber(a, aBase).plus(getBigNumber(b, bBase));
  return converter(_objectSpread({
    value
  }, conversionOptions));
};
const subtractCurrencies = (a, b, options = {}) => {
  const {
      aBase,
      bBase
    } = options,
    conversionOptions = _objectWithoutProperties(options, _excluded2);
  if (!isValidBase(aBase) || !isValidBase(bBase)) {
    throw new Error("Must specify valid aBase and bBase");
  }
  const value = getBigNumber(a, aBase).minus(getBigNumber(b, bBase));
  return converter(_objectSpread({
    value
  }, conversionOptions));
};
const multiplyCurrencies = (a, b, options = {}) => {
  const {
      multiplicandBase,
      multiplierBase
    } = options,
    conversionOptions = _objectWithoutProperties(options, _excluded3);
  if (!isValidBase(multiplicandBase) || !isValidBase(multiplierBase)) {
    throw new Error("Must specify valid multiplicandBase and multiplierBase");
  }
  const value = getBigNumber(a, multiplicandBase).times(getBigNumber(b, multiplierBase));
  return converter(_objectSpread({
    value
  }, conversionOptions));
};
const conversionGreaterThan = (_ref, _ref2) => {
  let secondProps = Object.assign({}, (_objectDestructuringEmpty(_ref2), _ref2));
  let firstProps = Object.assign({}, (_objectDestructuringEmpty(_ref), _ref));
  const firstValue = converter(_objectSpread({}, firstProps));
  const secondValue = converter(_objectSpread({}, secondProps));
  return firstValue.gt(secondValue);
};
const conversionLessThan = (_ref3, _ref4) => {
  let secondProps = Object.assign({}, (_objectDestructuringEmpty(_ref4), _ref4));
  let firstProps = Object.assign({}, (_objectDestructuringEmpty(_ref3), _ref3));
  const firstValue = converter(_objectSpread({}, firstProps));
  const secondValue = converter(_objectSpread({}, secondProps));
  return firstValue.lt(secondValue);
};
const conversionMax = (_ref5, _ref6) => {
  let secondProps = Object.assign({}, (_objectDestructuringEmpty(_ref6), _ref6));
  let firstProps = Object.assign({}, (_objectDestructuringEmpty(_ref5), _ref5));
  const firstIsGreater = conversionGreaterThan(_objectSpread({}, firstProps), _objectSpread({}, secondProps));
  return firstIsGreater ? firstProps.value : secondProps.value;
};
const conversionGTE = (_ref7, _ref8) => {
  let secondProps = Object.assign({}, (_objectDestructuringEmpty(_ref8), _ref8));
  let firstProps = Object.assign({}, (_objectDestructuringEmpty(_ref7), _ref7));
  const firstValue = converter(_objectSpread({}, firstProps));
  const secondValue = converter(_objectSpread({}, secondProps));
  return firstValue.isGreaterThanOrEqualTo(secondValue);
};
const conversionLTE = (_ref9, _ref10) => {
  let secondProps = Object.assign({}, (_objectDestructuringEmpty(_ref10), _ref10));
  let firstProps = Object.assign({}, (_objectDestructuringEmpty(_ref9), _ref9));
  const firstValue = converter(_objectSpread({}, firstProps));
  const secondValue = converter(_objectSpread({}, secondProps));
  return firstValue.isLessThanOrEqualTo(secondValue);
};
const toNegative = (n, options = {}) => multiplyCurrencies(n, -1, options);
const decGWEIToHexWEI = decGWEI => {
  return conversionUtil(decGWEI, {
    fromNumericBase: "dec",
    toNumericBase: "hex",
    fromDenomination: "GWEI",
    toDenomination: "WEI"
  });
};
const hexWEIToDecGWEI = decGWEI => {
  return conversionUtil(decGWEI, {
    fromNumericBase: "hex",
    toNumericBase: "dec",
    fromDenomination: "WEI",
    toDenomination: "GWEI"
  });
};

export { addCurrencies, conversionGTE, conversionGreaterThan, conversionLTE, conversionLessThan, conversionMax, conversionUtil, decGWEIToHexWEI, getBigNumber, hexWEIToDecGWEI, multiplyCurrencies, subtractCurrencies, toNegative };
