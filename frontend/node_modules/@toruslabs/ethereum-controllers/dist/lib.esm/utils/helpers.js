import _objectSpread from '@babel/runtime/helpers/objectSpread2';
import { addHexPrefix, stripHexPrefix, isValidAddress, toChecksumAddress } from '@ethereumjs/util';
import { formatSmallNumbers, significantDigits, ACTIVITY_ACTION_RECEIVE, ACTIVITY_ACTION_SEND, addressSlicer, TransactionStatus } from '@toruslabs/base-controllers';
import { BigNumber } from 'bignumber.js';
import log from 'loglevel';
import { determineTransactionType } from '../Transaction/TransactionUtils.js';
import { SUPPORTED_NETWORKS, CONTRACT_TYPE_ERC721, CONTRACT_TYPE_ERC1155, CONTRACT_TYPE_ERC20, METHOD_TYPES, MAINNET_CHAIN_ID, TEST_CHAINS, CONTRACT_TYPE_ETH } from './constants.js';

function hexToBn(hex) {
  return new BigNumber(stripHexPrefix(hex), 16);
}
function BNToHex(bn) {
  return addHexPrefix(bn.toString(16));
}
function getEtherScanHashLink(txHash, chainId) {
  if (!SUPPORTED_NETWORKS[chainId]) return "";
  return `${SUPPORTED_NETWORKS[chainId].blockExplorerUrl}/tx/${txHash}`;
}
const formatPastTx = params => {
  var _transaction$to;
  const {
    transaction,
    lowerCaseSelectedAddress,
    blockExplorerUrl
  } = params;
  let totalAmountString = "";
  if (transaction.type === CONTRACT_TYPE_ERC721 || transaction.type === CONTRACT_TYPE_ERC1155) totalAmountString = transaction.symbol;else if (transaction.type === CONTRACT_TYPE_ERC20) totalAmountString = formatSmallNumbers(Number.parseFloat(transaction.total_amount), transaction.symbol, true);else totalAmountString = formatSmallNumbers(Number.parseFloat(transaction.total_amount), transaction.type_name, true);
  const currencyAmountString = transaction.type === CONTRACT_TYPE_ERC721 || transaction.type === CONTRACT_TYPE_ERC1155 || transaction.isEtherscan ? "" : formatSmallNumbers(Number.parseFloat(transaction.currency_amount), transaction.selected_currency, true);
  const finalObject = {
    id: transaction.created_at.toString(),
    date: new Date(transaction.created_at).toString(),
    from: transaction.from,
    from_aa_address: transaction.from_aa_address,
    slicedFrom: typeof transaction.from === "string" ? addressSlicer(transaction.from) : "",
    to: transaction.to,
    slicedTo: typeof transaction.to === "string" ? addressSlicer(transaction.to) : "",
    action: lowerCaseSelectedAddress === ((_transaction$to = transaction.to) === null || _transaction$to === void 0 ? void 0 : _transaction$to.toLowerCase()) || "" ? ACTIVITY_ACTION_RECEIVE : ACTIVITY_ACTION_SEND,
    totalAmount: transaction.total_amount,
    totalAmountString,
    currencyAmount: transaction.currency_amount,
    currencyAmountString,
    amount: `${totalAmountString} / ${currencyAmountString}`,
    status: transaction.status,
    etherscanLink: blockExplorerUrl ? `${blockExplorerUrl}/tx/${transaction.transaction_hash}` : "",
    chainId: transaction.chain_id,
    ethRate: Number.parseFloat(transaction === null || transaction === void 0 ? void 0 : transaction.total_amount) && Number.parseFloat(transaction === null || transaction === void 0 ? void 0 : transaction.currency_amount) ? `1 ${transaction.symbol} = ${significantDigits(Number.parseFloat(transaction.currency_amount) / Number.parseFloat(transaction.total_amount))}` : "",
    currencyUsed: transaction.selected_currency,
    type: transaction.type,
    type_name: transaction.type_name,
    type_image_link: transaction.type_image_link,
    transaction_hash: transaction.transaction_hash,
    transaction_category: transaction.transaction_category,
    isEtherscan: transaction.isEtherscan,
    input: transaction.input || "",
    token_id: transaction.token_id || "",
    contract_address: transaction.contract_address || "",
    nonce: transaction.nonce || "",
    is_cancel: !!transaction.is_cancel || false,
    gas: transaction.gas || "",
    gasPrice: transaction.gasPrice || ""
  };
  return finalObject;
};

/**
 * Ref - https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactionreceipt
 */
const getEthTxStatus = async (hash, provider) => {
  try {
    const result = await provider.request({
      method: METHOD_TYPES.ETH_GET_TRANSACTION_RECEIPT,
      params: [hash]
    });
    if (result === null) return TransactionStatus.submitted;
    if (result && result.status === "0x1") return TransactionStatus.confirmed;
    if (result && result.status === "0x0") return TransactionStatus.rejected;
    return undefined;
  } catch (err) {
    log.warn("unable to fetch transaction status", err);
    return undefined;
  }
};
function formatDate(inputDate) {
  const monthList = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  const date = new Date(inputDate);
  const day = date.getDate();
  const month = monthList[date.getMonth()];
  const year = date.getFullYear();
  return `${day} ${month} ${year}`;
}
function formatTime(time) {
  return new Date(time).toTimeString().slice(0, 8);
}
function isAddressByChainId(address, _chainId) {
  // TOOD: add rsk network checks.
  return isValidAddress(address);
}
function toChecksumAddressByChainId(address, chainId) {
  // TOOD: add rsk network checks.
  if (!isAddressByChainId(address)) return address;
  return toChecksumAddress(address);
}
const GAS_LIMITS = {
  // maximum gasLimit of a simple send
  SIMPLE: addHexPrefix(21000 .toString(16)),
  // a base estimate for token transfers.
  BASE_TOKEN_ESTIMATE: addHexPrefix(100000 .toString(16))
};
function bnLessThan(a, b) {
  if (a === null || a === undefined || b === null || b === undefined) {
    return null;
  }
  return new BigNumber(a, 10).lt(b, 10);
}
const getIpfsEndpoint = path => `https://infura-ipfs.io/${path}`;
function sanitizeNftMetdataUrl(url) {
  let finalUri = url;
  if (url !== null && url !== void 0 && url.startsWith("ipfs")) {
    const ipfsPath = url.split("ipfs://")[1];
    finalUri = getIpfsEndpoint(ipfsPath);
  }
  return finalUri;
}
function getChainType(chainId) {
  if (chainId === MAINNET_CHAIN_ID) {
    return "mainnet";
  } else if (TEST_CHAINS.includes(chainId)) {
    return "testnet";
  }
  return "custom";
}
const addEtherscanTransactions = async params => {
  const {
    txn,
    lowerCaseSelectedAddress,
    provider,
    chainId,
    blockExplorerUrl
  } = params;
  const transactionPromises = await Promise.all(txn.map(async tx => {
    var _SUPPORTED_NETWORKS$c, _SUPPORTED_NETWORKS$c2;
    const {
      category,
      type
    } = await determineTransactionType(_objectSpread(_objectSpread({}, tx), {}, {
      data: tx.input
    }), provider);
    tx.transaction_category = tx.transaction_category || category;
    tx.type_image_link = ((_SUPPORTED_NETWORKS$c = SUPPORTED_NETWORKS[chainId]) === null || _SUPPORTED_NETWORKS$c === void 0 ? void 0 : _SUPPORTED_NETWORKS$c.logo) || "";
    tx.type_name = (_SUPPORTED_NETWORKS$c2 = SUPPORTED_NETWORKS[chainId]) === null || _SUPPORTED_NETWORKS$c2 === void 0 ? void 0 : _SUPPORTED_NETWORKS$c2.ticker;
    tx.type = type;
    return tx;
  }));
  const finalTxs = transactionPromises.reduce((accumulator, x) => {
    var _SUPPORTED_NETWORKS$c3, _SUPPORTED_NETWORKS$c4;
    let totalAmountString = x.value ? new BigNumber(x.value).div(new BigNumber(10).pow(new BigNumber(x.tokenDecimal || 18))).toString() : "";
    let type = CONTRACT_TYPE_ETH;
    if (x.contractAddress !== "") {
      if (x.tokenID) {
        type = x.tokenValue ? CONTRACT_TYPE_ERC1155 : CONTRACT_TYPE_ERC721;
      } else {
        type = CONTRACT_TYPE_ERC20;
      }
    }
    if (type === CONTRACT_TYPE_ERC1155) {
      totalAmountString = x.tokenValue;
    }
    const etherscanTransaction = {
      type,
      type_image_link: x.type_image_link || "n/a",
      type_name: x.tokenName || ((_SUPPORTED_NETWORKS$c3 = SUPPORTED_NETWORKS[chainId]) === null || _SUPPORTED_NETWORKS$c3 === void 0 ? void 0 : _SUPPORTED_NETWORKS$c3.ticker) || "n/a",
      symbol: x.tokenSymbol || ((_SUPPORTED_NETWORKS$c4 = SUPPORTED_NETWORKS[chainId]) === null || _SUPPORTED_NETWORKS$c4 === void 0 ? void 0 : _SUPPORTED_NETWORKS$c4.ticker),
      token_id: x.tokenID || "",
      total_amount: totalAmountString,
      created_at: new Date(Number(x.timeStamp) * 1000),
      from: x.from,
      to: x.to,
      transaction_hash: x.hash,
      status: x.txreceipt_status && x.txreceipt_status === "0" ? TransactionStatus.failed : TransactionStatus.confirmed,
      isEtherscan: true,
      input: x.input,
      contract_address: x.contractAddress,
      transaction_category: x.transaction_category,
      gas: `0x${new BigNumber(x.gasUsed || 0, 10).toString(16)}`,
      gasPrice: `0x${new BigNumber(x.gasPrice || 0, 10).toString(16)}`,
      chain_id: chainId,
      currency_amount: "",
      nonce: x.nonce,
      from_aa_address: "",
      is_cancel: false,
      selected_currency: ""
    };
    accumulator.push(formatPastTx({
      transaction: etherscanTransaction,
      lowerCaseSelectedAddress,
      blockExplorerUrl
    }));
    return accumulator;
  }, []);
  return finalTxs;
};

export { BNToHex, GAS_LIMITS, addEtherscanTransactions, bnLessThan, formatDate, formatPastTx, formatTime, getChainType, getEthTxStatus, getEtherScanHashLink, getIpfsEndpoint, hexToBn, isAddressByChainId, sanitizeNftMetdataUrl, toChecksumAddressByChainId };
