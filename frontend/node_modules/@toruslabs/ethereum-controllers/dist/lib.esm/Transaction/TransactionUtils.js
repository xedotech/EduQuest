import { addHexPrefix, isHexString, isValidAddress } from '@ethereumjs/util';
import { randomId, TransactionStatus, TRANSACTION_TYPES } from '@toruslabs/base-controllers';
import { rpcErrors } from '@web3auth/auth';
import { Interface } from 'ethers';
import log from 'loglevel';
import { erc20Abi, erc721Abi, erc1155Abi } from '../utils/abis.js';
import { CONTRACT_TYPE_ERC20, CONTRACT_TYPE_ERC721, CONTRACT_TYPE_ERC1155, METHOD_TYPES, CONTRACT_TYPE_ETH, TRANSACTION_ENVELOPE_TYPES } from '../utils/constants.js';

const erc20Interface = new Interface(erc20Abi);
const erc721Interface = new Interface(erc721Abi);
const erc1155Interface = new Interface(erc1155Abi);

// functions that handle normalizing of that key in txParams

const normalizers = {
  from: (from, LowerCase = true) => LowerCase ? addHexPrefix(from).toLowerCase() : addHexPrefix(from),
  to: (to, LowerCase = true) => LowerCase ? addHexPrefix(to).toLowerCase() : addHexPrefix(to),
  nonce: nonce => addHexPrefix(nonce),
  customNonceValue: nonce => addHexPrefix(nonce),
  value: value => addHexPrefix(value),
  data: data => addHexPrefix(data),
  gas: gas => addHexPrefix(gas),
  gasPrice: gasPrice => addHexPrefix(gasPrice),
  type: addHexPrefix,
  maxFeePerGas: addHexPrefix,
  maxPriorityFeePerGas: addHexPrefix,
  callGasLimit: addHexPrefix,
  preVerificationGas: addHexPrefix,
  verificationGasLimit: addHexPrefix,
  paymasterVerificationGasLimit: addHexPrefix,
  paymasterPostOpGasLimit: addHexPrefix
};

/**
 * normalizes txParams
 */
function normalizeTxParameters(txParameters, lowerCase = true) {
  // apply only keys in the normalizers
  const normalizedTxParameters = {
    id: txParameters.id || randomId(),
    from: txParameters.from
  };
  for (const key in normalizers) {
    const currentKey = key;
    if (txParameters[currentKey])
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      normalizedTxParameters[currentKey] = normalizers[currentKey](txParameters[currentKey], lowerCase);
  }
  return normalizedTxParameters;
}
function transactionMatchesNetwork(transaction, chainId) {
  if (typeof transaction.chainId !== "undefined") {
    return transaction.chainId === chainId;
  }
  return false;
}

/**
 * Determines if the maxFeePerGas and maxPriorityFeePerGas fields are supplied
 * and valid inputs. This will return false for non hex string inputs.
 *  the transaction to check
 * @returns true if transaction uses valid EIP1559 fields
 */
function isEIP1559Transaction(transaction) {
  var _transaction$transact, _transaction$transact2;
  return isHexString(addHexPrefix(transaction === null || transaction === void 0 || (_transaction$transact = transaction.transaction) === null || _transaction$transact === void 0 ? void 0 : _transaction$transact.maxFeePerGas)) && isHexString(addHexPrefix(transaction === null || transaction === void 0 || (_transaction$transact2 = transaction.transaction) === null || _transaction$transact2 === void 0 ? void 0 : _transaction$transact2.maxPriorityFeePerGas));
}

/**
 * Determine if the maxFeePerGas and maxPriorityFeePerGas fields are not
 * supplied and that the gasPrice field is valid if it is provided. This will
 * return false if gasPrice is a non hex string.
 * transaction -
 *  the transaction to check
 * @returns true if transaction uses valid Legacy fields OR lacks
 *  EIP1559 fields
 */
function isLegacyTransaction(transaction) {
  return typeof transaction.transaction.maxFeePerGas === "undefined" && typeof transaction.transaction.maxPriorityFeePerGas === "undefined" && (typeof transaction.transaction.gasPrice === "undefined" || isHexString(addHexPrefix(transaction.transaction.gasPrice)));
}

/**
 * Given two fields, ensure that the second field is not included in txParams,
 * and if it is throw an invalidParams error.
 */
function ensureMutuallyExclusiveFieldsNotProvided(txParams, fieldBeingValidated, mutuallyExclusiveField) {
  if (typeof txParams[mutuallyExclusiveField] !== "undefined") {
    throw rpcErrors.invalidParams(`Invalid transaction params: specified ${fieldBeingValidated} but also included ${mutuallyExclusiveField}, these cannot be mixed`);
  }
}

/**
 * Ensures that the provided value for field is a string, throws an
 * invalidParams error if field is not a string.
 */
function ensureFieldIsString(txParams, field) {
  if (typeof txParams[field] !== "string") {
    throw rpcErrors.invalidParams(`Invalid transaction params: ${field} is not a string. got: (${txParams[field]})`);
  }
}

/**
 * Ensures that the provided txParams has the proper 'type' specified for the
 * given field, if it is provided. If types do not match throws an
 * invalidParams error.
 */
function ensureProperTransactionEnvelopeTypeProvided(txParams, field) {
  switch (field) {
    case "maxFeePerGas":
    case "maxPriorityFeePerGas":
      if (txParams.type && txParams.type !== TRANSACTION_ENVELOPE_TYPES.FEE_MARKET) {
        throw rpcErrors.invalidParams(`Invalid transaction envelope type: specified type "${txParams.type}" but ` + `including maxFeePerGas and maxPriorityFeePerGas requires type: "${TRANSACTION_ENVELOPE_TYPES.FEE_MARKET}"`);
      }
      break;
    case "gasPrice":
    default:
      if (txParams.type && txParams.type === TRANSACTION_ENVELOPE_TYPES.FEE_MARKET) {
        throw rpcErrors.invalidParams(`Invalid transaction envelope type: specified type "${txParams.type}" but ` + "included a gasPrice instead of maxFeePerGas and maxPriorityFeePerGas");
      }
  }
}

/**
 * validates the from field in  txParams
 */
function validateFrom(txParams) {
  if (!(typeof txParams.from === "string")) {
    throw rpcErrors.invalidParams(`Invalid "from" address "${txParams.from}": not a string.`);
  }
  if (!isValidAddress(txParams.from)) {
    throw rpcErrors.invalidParams('Invalid "from" address.');
  }
}

/**
 * validates the to field in  txParams
 */
function validateRecipient(txParameters) {
  if (txParameters.to === "0x" || txParameters.to === null) {
    if (txParameters.data) {
      delete txParameters.to;
    } else {
      throw rpcErrors.invalidParams('Invalid "to" address.');
    }
  } else if (txParameters.to !== undefined && !isValidAddress(txParameters.to)) {
    throw rpcErrors.invalidParams('Invalid "to" address.');
  }
  return txParameters;
}

/**
 * Validates the given tx parameters
 * @throws if the tx params contains invalid fields
 */
function validateTxParameters(txParams, eip1559Compatibility = true) {
  if (!txParams || typeof txParams !== "object" || Array.isArray(txParams)) {
    throw rpcErrors.invalidParams("Invalid transaction params: must be an object.");
  }
  if (!txParams.to && !txParams.data) {
    throw rpcErrors.invalidParams('Invalid transaction params: must specify "data" for contract deployments, or "to" (and optionally "data") for all other types of transactions.');
  }
  if (isEIP1559Transaction({
    transaction: txParams
  }) && !eip1559Compatibility) {
    throw rpcErrors.invalidParams("Invalid transaction params: params specify an EIP-1559 transaction but the current network does not support EIP-1559");
  }
  Object.entries(txParams).forEach(([key, value]) => {
    // validate types
    switch (key) {
      case "from":
        validateFrom(txParams);
        break;
      case "to":
        validateRecipient(txParams);
        break;
      case "gasPrice":
        ensureProperTransactionEnvelopeTypeProvided(txParams, "gasPrice");
        ensureMutuallyExclusiveFieldsNotProvided(txParams, "gasPrice", "maxFeePerGas");
        ensureMutuallyExclusiveFieldsNotProvided(txParams, "gasPrice", "maxPriorityFeePerGas");
        ensureFieldIsString(txParams, "gasPrice");
        break;
      case "maxFeePerGas":
        ensureProperTransactionEnvelopeTypeProvided(txParams, "maxFeePerGas");
        ensureMutuallyExclusiveFieldsNotProvided(txParams, "maxFeePerGas", "gasPrice");
        ensureFieldIsString(txParams, "maxFeePerGas");
        break;
      case "maxPriorityFeePerGas":
        ensureProperTransactionEnvelopeTypeProvided(txParams, "maxPriorityFeePerGas");
        ensureMutuallyExclusiveFieldsNotProvided(txParams, "maxPriorityFeePerGas", "gasPrice");
        ensureFieldIsString(txParams, "maxPriorityFeePerGas");
        break;
      case "value":
        ensureFieldIsString(txParams, "value");
        if (value.toString().includes("-")) {
          throw rpcErrors.invalidParams(`Invalid transaction value "${value}": not a positive number.`);
        }
        if (value.toString().includes(".")) {
          throw rpcErrors.invalidParams(`Invalid transaction value of "${value}": number must be in wei.`);
        }
        break;
      case "chainId":
        if (typeof value !== "number" && typeof value !== "string") {
          throw rpcErrors.invalidParams(`Invalid transaction params: ${key} is not a Number or hex string. got: (${value})`);
        }
        break;
      default:
        ensureFieldIsString(txParams, key);
    }
  });
}
function normalizeAndValidateTxParams(txParams, lowerCase = true) {
  const normalizedTxParams = normalizeTxParameters(txParams, lowerCase);
  validateTxParameters(normalizedTxParams);
  return normalizedTxParams;
}

/**
 * @returns an array of states that can be considered final
 */
function getFinalStates() {
  return [TransactionStatus.rejected,
  // the user has responded no!
  TransactionStatus.confirmed,
  // the tx has been included in a block.
  TransactionStatus.failed,
  // the tx failed for some reason, included on tx data.
  TransactionStatus.dropped // the tx nonce was already used
  ];
}
function parseStandardTokenTransactionData(data) {
  try {
    const txDesc = erc20Interface.parseTransaction({
      data
    });
    if (txDesc) return {
      name: txDesc.name,
      methodParams: txDesc.args.toArray(),
      type: CONTRACT_TYPE_ERC20
    };
  } catch {
    // ignore and next try to parse with erc721 ABI
  }
  try {
    const txDesc = erc721Interface.parseTransaction({
      data
    });
    if (txDesc) return {
      name: txDesc.name,
      methodParams: txDesc.args.toArray(),
      type: CONTRACT_TYPE_ERC721
    };
  } catch {
    // ignore and next try to parse with erc1155 ABI
  }
  try {
    const txDesc = erc1155Interface.parseTransaction({
      data
    });
    if (txDesc) return {
      name: txDesc.name,
      methodParams: txDesc.args.toArray(),
      type: CONTRACT_TYPE_ERC1155
    };
  } catch {
    // ignore and return undefined
  }
  return undefined;
}
const readAddressAsContract = async (provider, address) => {
  let contractCode;
  try {
    contractCode = await provider.request({
      method: METHOD_TYPES.ETH_GET_CODE,
      params: [address, "latest"]
    });
  } catch {
    contractCode = null;
  }
  const isContractAddress = contractCode ? contractCode !== "0x" && contractCode !== "0x0" : false;
  return {
    contractCode,
    isContractAddress
  };
};
async function determineTransactionType(txParams, provider) {
  const {
    data,
    to
  } = txParams;
  let name = "";
  let methodParams = [];
  let type = "";
  try {
    ({
      name,
      methodParams,
      type
    } = data && parseStandardTokenTransactionData(data) || {});
  } catch (error) {
    log.debug("Failed to parse transaction data", error);
  }
  let result;
  let contractCode = "";
  if (data && !to) {
    result = TRANSACTION_TYPES.DEPLOY_CONTRACT;
  } else {
    const {
      contractCode: resultCode,
      isContractAddress
    } = await readAddressAsContract(provider, to);
    contractCode = resultCode;
    if (isContractAddress) {
      const valueExists = txParams.value && Number(txParams.value) !== 0;
      const tokenMethodName = [TRANSACTION_TYPES.TOKEN_METHOD_APPROVE, TRANSACTION_TYPES.TOKEN_METHOD_TRANSFER, TRANSACTION_TYPES.TOKEN_METHOD_TRANSFER_FROM, TRANSACTION_TYPES.COLLECTIBLE_METHOD_SAFE_TRANSFER_FROM, TRANSACTION_TYPES.SET_APPROVAL_FOR_ALL].find(x => {
        var _name;
        return x.toLowerCase() === ((_name = name) === null || _name === void 0 ? void 0 : _name.toLowerCase());
      });
      result = data && tokenMethodName && !valueExists ? tokenMethodName : TRANSACTION_TYPES.CONTRACT_INTERACTION;
    } else {
      result = TRANSACTION_TYPES.SENT_ETHER;
    }
  }
  return {
    type: type || CONTRACT_TYPE_ETH,
    category: result,
    methodParams,
    getCodeResponse: contractCode
  };
}

export { determineTransactionType, ensureFieldIsString, ensureMutuallyExclusiveFieldsNotProvided, getFinalStates, isEIP1559Transaction, isLegacyTransaction, normalizeAndValidateTxParams, normalizeTxParameters, parseStandardTokenTransactionData, readAddressAsContract, transactionMatchesNetwork, validateFrom, validateRecipient, validateTxParameters };
