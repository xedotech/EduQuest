import _objectSpread from '@babel/runtime/helpers/objectSpread2';
import _defineProperty from '@babel/runtime/helpers/defineProperty';
import { addHexPrefix, stripHexPrefix } from '@ethereumjs/util';
import { TRANSACTION_TYPES, TX_EVENTS, TransactionStatus } from '@toruslabs/base-controllers';
import { providerErrors, rpcErrors } from '@web3auth/auth';
import { BigNumber } from 'bignumber.js';
import { Transaction, keccak256 } from 'ethers';
import log from 'loglevel';
import { METHOD_TYPES, TRANSACTION_ENVELOPE_TYPES, GAS_ESTIMATE_TYPES, CHAIN_ID_TO_GAS_LIMIT_BUFFER_MAP } from '../utils/constants.js';
import { decGWEIToHexWEI } from '../utils/conversionUtils.js';
import { bnLessThan, getChainType, GAS_LIMITS } from '../utils/helpers.js';
import { NonceTracker } from './NonceTracker.js';
import { PendingTransactionTracker } from './PendingTransactionTracker.js';
import { TransactionGasUtil } from './TransactionGasUtil.js';
import { TransactionStateManager } from './TransactionStateManager.js';
import { isEIP1559Transaction, normalizeTxParameters, validateTxParameters, determineTransactionType } from './TransactionUtils.js';

class TransactionController extends TransactionStateManager {
  constructor({
    config,
    state,
    provider,
    blockTracker,
    signEthTx,
    getCurrentChainId,
    getCurrentNetworkEIP1559Compatibility,
    getCurrentAccountEIP1559Compatibility,
    getSelectedAddress,
    getEIP1559GasFeeEstimates
  }) {
    super({
      config,
      state,
      getCurrentChainId
    });
    _defineProperty(this, "getSelectedAddress", void 0);
    _defineProperty(this, "getEIP1559GasFeeEstimates", void 0);
    _defineProperty(this, "nonceTracker", void 0);
    _defineProperty(this, "pendingTxTracker", void 0);
    _defineProperty(this, "txGasUtil", void 0);
    _defineProperty(this, "_getCurrentNetworkEIP1559Compatibility", void 0);
    _defineProperty(this, "_getCurrentAccountEIP1559Compatibility", void 0);
    _defineProperty(this, "signEthTx", void 0);
    _defineProperty(this, "provider", void 0);
    _defineProperty(this, "blockTracker", void 0);
    _defineProperty(this, "inProcessOfSigning", new Set());
    _defineProperty(this, "getUnapprovedTxCount", () => Object.keys(this.getUnapprovedTxList()).length);
    _defineProperty(this, "getPendingTxCount", account => this.getPendingTransactions(account).length);
    this.blockTracker = blockTracker;
    this._getCurrentNetworkEIP1559Compatibility = getCurrentNetworkEIP1559Compatibility;
    this._getCurrentAccountEIP1559Compatibility = getCurrentAccountEIP1559Compatibility;
    this.getSelectedAddress = getSelectedAddress;
    this.getEIP1559GasFeeEstimates = getEIP1559GasFeeEstimates;
    this.signEthTx = signEthTx;
    this.provider = provider;
    this.txGasUtil = new TransactionGasUtil(this.provider, this.blockTracker);
    this.nonceTracker = new NonceTracker({
      provider,
      blockTracker,
      getConfirmedTransactions: this.getConfirmedTransactions.bind(this),
      getPendingTransactions: this.getSubmittedTransactions.bind(this) // nonce tracker should only care about submitted transactions
    });
    this.pendingTxTracker = new PendingTransactionTracker({
      provider,
      nonceTracker: this.nonceTracker,
      getPendingTransactions: this.getPendingTransactions.bind(this),
      // pending tx tracker should only care about submitted and approved transactions
      getConfirmedTransactions: this.getConfirmedTransactions.bind(this),
      approveTransaction: this.approveTransaction.bind(this),
      publishTransaction: rawTx => this.provider.request({
        method: METHOD_TYPES.ETH_SEND_RAW_TRANSACTION,
        params: [rawTx]
      })
    });
    this._setupListeners();
  }
  addTransactionUnapproved(txMeta) {
    this.addTransactionToState(txMeta);
    this.emit(`${txMeta.id}:unapproved`, txMeta);
  }
  async addNewUnapprovedTransaction(txParams, req) {
    const txMeta = await this.createTransaction(txParams, req);
    return this.processApproval(txMeta);
  }
  async processApproval(txMeta) {
    return new Promise((resolve, reject) => {
      const handleFinished = msg => {
        if (msg.status === TransactionStatus.rejected) {
          return reject(providerErrors.userRejectedRequest(`Transaction Signature: User denied message signature`));
        }
        if (msg.status === TransactionStatus.failed) {
          return reject(rpcErrors.internal(`Transaction Signature: failed to sign message ${msg.error}`));
        }
        if (msg.status === TransactionStatus.signed && msg.isSignOnly) {
          return resolve(msg.rawTransaction);
        }
        if (msg.status === TransactionStatus.submitted) {
          return resolve(msg.transactionHash);
        }
        return reject(rpcErrors.internal(`Transaction Signature: Unknown problem: ${JSON.stringify(txMeta.transaction)}`));
      };
      this.once(`${txMeta.id}:finished`, handleFinished);
    });
  }
  async approveTransaction(transactionID) {
    const txMeta = this.getTransaction(transactionID);
    if (this.inProcessOfSigning.has(transactionID)) {
      return;
    }
    this.inProcessOfSigning.add(transactionID);
    let nonceLock;
    try {
      this.setTxStatusApproved(transactionID);
      const fromAddress = txMeta.transaction.from;
      const {
        customNonceValue
      } = txMeta.transaction;
      const customNonceValueNumber = Number(customNonceValue);
      nonceLock = await this.nonceTracker.getNonceLock(fromAddress);
      // add nonce to txParams
      // if txMeta has previousGasParams then it is a retry at same nonce with
      // higher gas settings and therefor the nonce should not be recalculated
      const nonce = nonceLock.nextNonce;
      const customOrNonce = customNonceValueNumber === 0 ? customNonceValue : customNonceValue || nonce;
      txMeta.transaction.nonce = addHexPrefix(customOrNonce.toString(16));
      // add nonce debugging information to txMeta
      txMeta.nonceDetails = nonceLock.nonceDetails;
      this.updateTransactionInState(txMeta, "transactions#approveTransaction");
      // sign transaction
      await this.signTransaction(transactionID, txMeta.isSignOnly);
      // publish if not signOnly
      if (!txMeta.isSignOnly) {
        await this.publishTransaction(transactionID);
      }
      nonceLock.releaseLock();
    } catch (err) {
      try {
        this.setTxStatusFailed(transactionID, err);
      } catch (err2) {
        log.error(err2);
      }
      // must set transaction to submitted/failed before releasing lock
      if (nonceLock) {
        nonceLock.releaseLock();
      }
      // continue with error chain
      throw err;
    } finally {
      this.inProcessOfSigning.delete(transactionID);
    }
  }
  async signTransaction(txId, isSignOnly) {
    const txMeta = this.getTransaction(txId);
    const chainId = this.getCurrentChainId();
    const type = isEIP1559Transaction(txMeta) ? TRANSACTION_ENVELOPE_TYPES.FEE_MARKET : TRANSACTION_ENVELOPE_TYPES.LEGACY;
    const txParams = {
      type: Number.parseInt(type, 16),
      chainId,
      gasLimit: txMeta.transaction.gas,
      accessList: txMeta.transaction.accessList,
      data: txMeta.transaction.data,
      gasPrice: txMeta.transaction.gasPrice,
      maxFeePerGas: txMeta.transaction.maxFeePerGas,
      maxPriorityFeePerGas: txMeta.transaction.maxPriorityFeePerGas,
      nonce: Number.parseInt(txMeta.transaction.nonce, 16),
      to: txMeta.transaction.to,
      value: txMeta.transaction.value
    };
    const fromAddress = txMeta.transaction.from;
    const tx = Transaction.from(txParams);
    const signedEthTx = await this.signEthTx(tx, fromAddress);
    txMeta.r = signedEthTx.signature.r;
    txMeta.s = signedEthTx.signature.s;
    txMeta.v = addHexPrefix(signedEthTx.signature.v.toString(16));
    const rawTx = signedEthTx.serialized;
    txMeta.rawTransaction = rawTx;
    this.updateTransactionInState(txMeta, "transactions#signTransaction: add r, s, v values and rawTx");
    this.setTxStatusSigned(txId, isSignOnly);
    return rawTx;
  }
  async publishTransaction(txId) {
    const txMeta = this.getTransaction(txId);
    const rawTx = txMeta.rawTransaction;
    let txHash;
    try {
      txHash = await this.provider.request({
        method: METHOD_TYPES.ETH_SEND_RAW_TRANSACTION,
        params: [rawTx]
      });
    } catch (error) {
      if (error.message.toLowerCase().includes("known transaction")) {
        txHash = keccak256(addHexPrefix(rawTx));
        txHash = addHexPrefix(txHash);
      } else {
        throw error;
      }
    }
    this.setTxHash(txId, txHash);
    this.setTxStatusSubmitted(txId);
  }
  async confirmTransaction(params) {
    const {
      txId,
      txReceipt
    } = params;
    log.info(params, "confirm params");
    const txMeta = this.getTransaction(txId);
    if (!txMeta) return;
    try {
      txMeta.txReceipt = _objectSpread({}, txReceipt);
      this.setTxStatusConfirmed(txId);
      this.markNonceDuplicatesDropped(txId);
      this.updateTransactionInState(txMeta, "transactions#confirmTransaction - add txReceipt");
    } catch (error) {
      log.error(error);
    }
  }
  cancelTransaction(transactionID) {
    throw new Error(`Method not implemented. ${transactionID}`);
  }
  async getEIP1559Compatibility(fromAddress) {
    const currentNetworkIsCompatible = await this._getCurrentNetworkEIP1559Compatibility();
    const fromAccountIsCompatible = await this._getCurrentAccountEIP1559Compatibility(fromAddress);
    return currentNetworkIsCompatible && fromAccountIsCompatible;
  }
  async addTransactionGasDefaults(txMeta) {
    // for user operation, if the dapp doesn't provide gas and fee, let bundler estimate them
    // bundlers unfortunately have strict rules on fee prechecks â€“ we will need to set a generous buffer
    if (txMeta.isUserOperation) return txMeta;
    let updateTxMeta = txMeta;
    try {
      updateTxMeta = await this.addTxGasDefaults(txMeta);
    } catch (error) {
      log.warn(error);
      updateTxMeta = this.getTransaction(txMeta.id);
      updateTxMeta.loadingDefaults = false;
      this.updateTransactionInState(txMeta, "Failed to calculate gas defaults.");
      throw error;
    }
    updateTxMeta.loadingDefaults = false;
    this.updateTransactionInState(updateTxMeta, "Added new unapproved transaction.");
    return updateTxMeta;
  }
  async addTxGasDefaults(txMeta) {
    const eip1559Compatibility = txMeta.transaction.type !== TRANSACTION_ENVELOPE_TYPES.LEGACY && (await this.getEIP1559Compatibility());
    const {
      gasPrice: defaultGasPrice,
      maxFeePerGas: defaultMaxFeePerGas,
      maxPriorityFeePerGas: defaultMaxPriorityFeePerGas
    } = await this.getDefaultGasFees(txMeta, eip1559Compatibility);
    const {
      gasLimit: defaultGasLimit,
      simulationFails
    } = await this.getDefaultGasLimit(txMeta);
    txMeta = this.getTransaction(txMeta.id);
    if (simulationFails) {
      txMeta.simulationFails = simulationFails;
    }
    if (eip1559Compatibility) {
      // If the dapp has suggested a gas price, but no maxFeePerGas or maxPriorityFeePerGas
      //  then we set maxFeePerGas and maxPriorityFeePerGas to the suggested gasPrice.
      if (txMeta.transaction.gasPrice && !txMeta.transaction.maxFeePerGas && !txMeta.transaction.maxPriorityFeePerGas) {
        txMeta.transaction.maxFeePerGas = txMeta.transaction.gasPrice;
        // If the dapp has suggested a gas price, but no maxFeePerGas or maxPriorityFeePerGas
        // then we set maxFeePerGas to the suggested gasPrice.

        txMeta.transaction.maxPriorityFeePerGas = bnLessThan(typeof defaultMaxPriorityFeePerGas === "string" ? stripHexPrefix(defaultMaxPriorityFeePerGas) : defaultMaxPriorityFeePerGas, typeof txMeta.transaction.gasPrice === "string" ? stripHexPrefix(txMeta.transaction.gasPrice) : txMeta.transaction.gasPrice) ? defaultMaxPriorityFeePerGas : txMeta.transaction.gasPrice;
      } else {
        if (defaultMaxFeePerGas && !txMeta.transaction.maxFeePerGas) {
          // If the dapp has not set the gasPrice or the maxFeePerGas, then we set maxFeePerGas
          // with the one returned by the gasFeeController, if that is available.
          txMeta.transaction.maxFeePerGas = defaultMaxFeePerGas;
        }
        if (defaultMaxPriorityFeePerGas && !txMeta.transaction.maxPriorityFeePerGas) {
          // If the dapp has not set the gasPrice or the maxPriorityFeePerGas, then we set maxPriorityFeePerGas
          // with the one returned by the gasFeeController, if that is available.
          txMeta.transaction.maxPriorityFeePerGas = defaultMaxPriorityFeePerGas;
        }
        if (defaultGasPrice && !txMeta.transaction.maxFeePerGas) {
          // If the dapp has not set the gasPrice or the maxFeePerGas, and no maxFeePerGas is available
          // from the gasFeeController, then we set maxFeePerGas to the defaultGasPrice, assuming it is
          // available.
          txMeta.transaction.maxFeePerGas = defaultGasPrice;
        }
        if (txMeta.transaction.maxFeePerGas && !txMeta.transaction.maxPriorityFeePerGas) {
          // If the dapp has not set the gasPrice or the maxPriorityFeePerGas, and no maxPriorityFeePerGas is
          // available from the gasFeeController, then we set maxPriorityFeePerGas to
          // txMeta.transaction.maxFeePerGas, which will either be the gasPrice from the controller, the maxFeePerGas
          // set by the dapp, or the maxFeePerGas from the controller.
          txMeta.transaction.maxPriorityFeePerGas = txMeta.transaction.maxFeePerGas;
        }
      }

      // We remove the gasPrice param entirely when on an eip1559 compatible network

      delete txMeta.transaction.gasPrice;
    } else {
      // We ensure that maxFeePerGas and maxPriorityFeePerGas are not in the transaction params
      // when not on a EIP1559 compatible network

      delete txMeta.transaction.maxPriorityFeePerGas;
      delete txMeta.transaction.maxFeePerGas;
    }

    // If we have gotten to this point, and none of gasPrice, maxPriorityFeePerGas or maxFeePerGas are
    // set on transaction, it means that either we are on a non-EIP1559 network and the dapp didn't suggest
    // a gas price, or we are on an EIP1559 network, and none of gasPrice, maxPriorityFeePerGas or maxFeePerGas
    // were available from either the dapp or the network.
    if (defaultGasPrice && !txMeta.transaction.gasPrice && !txMeta.transaction.maxPriorityFeePerGas && !txMeta.transaction.maxFeePerGas) {
      txMeta.transaction.gasPrice = defaultGasPrice;
    }
    if (defaultGasLimit && !txMeta.transaction.gas) {
      txMeta.transaction.gas = defaultGasLimit;
    }
    return txMeta;
  }
  setTxHash(txId, txHash) {
    // Add the tx hash to the persisted meta-tx object
    const txMeta = this.getTransaction(txId);
    txMeta.transactionHash = txHash;
    this.updateTransactionInState(txMeta, "transactions#setTxHash");
  }
  async getDefaultGasFees(txMeta, eip1559Compatibility) {
    if (!eip1559Compatibility && txMeta.transaction.gasPrice || eip1559Compatibility && txMeta.transaction.maxFeePerGas && txMeta.transaction.maxPriorityFeePerGas) {
      return {};
    }
    try {
      const {
        gasFeeEstimates,
        gasEstimateType
      } = await this.getEIP1559GasFeeEstimates();
      if (eip1559Compatibility && gasEstimateType === GAS_ESTIMATE_TYPES.FEE_MARKET) {
        // this is in dec gwei
        const {
          medium: {
            suggestedMaxPriorityFeePerGas,
            suggestedMaxFeePerGas
          } = {}
        } = gasFeeEstimates;
        if (suggestedMaxPriorityFeePerGas && suggestedMaxFeePerGas) {
          return {
            // send to controller in hex wei
            maxFeePerGas: addHexPrefix(decGWEIToHexWEI(new BigNumber(suggestedMaxFeePerGas)).toString(16)),
            maxPriorityFeePerGas: addHexPrefix(decGWEIToHexWEI(new BigNumber(suggestedMaxPriorityFeePerGas)).toString(16))
          };
        }
      } else if (gasEstimateType === GAS_ESTIMATE_TYPES.LEGACY) {
        const {
          medium
        } = gasFeeEstimates;
        // The LEGACY type includes low, medium and high estimates of
        // gas price values.
        return {
          gasPrice: addHexPrefix(decGWEIToHexWEI(new BigNumber(medium)).toString(16))
        };
      } else if (gasEstimateType === GAS_ESTIMATE_TYPES.ETH_GASPRICE) {
        const {
          gasPrice
        } = gasFeeEstimates;
        // The ETH_GASPRICE type just includes a single gas price property,
        // which we can assume was retrieved from eth_gasPrice
        return {
          gasPrice: addHexPrefix(decGWEIToHexWEI(new BigNumber(gasPrice)).toString(16))
        };
      }
    } catch (error) {
      log.error(error);
    }
    const gasPrice = await this.provider.request({
      method: METHOD_TYPES.ETH_GET_GAS_PRICE
    });
    return {
      gasPrice: gasPrice && addHexPrefix(gasPrice)
    };
  }
  async getDefaultGasLimit(txMeta) {
    const chainId = this.getCurrentChainId();
    const customNetworkGasBuffer = CHAIN_ID_TO_GAS_LIMIT_BUFFER_MAP[chainId];
    const chainType = getChainType(chainId);
    if (txMeta.transaction.gas) {
      return {};
    }
    if (txMeta.transaction.to && txMeta.transactionCategory === TRANSACTION_TYPES.SENT_ETHER && chainType !== "custom" && !txMeta.transaction.data) {
      // This is a standard ether simple send, gas requirement is exactly 21k
      return {
        gasLimit: GAS_LIMITS.SIMPLE
      };
    }
    const {
      blockGasLimit,
      estimatedGasHex,
      simulationFails
    } = await this.txGasUtil.analyzeGasUsage(txMeta);

    // add additional gas buffer to our estimation for safety
    const gasLimit = this.txGasUtil.addGasBuffer(addHexPrefix(estimatedGasHex), blockGasLimit, customNetworkGasBuffer);
    return {
      gasLimit,
      simulationFails
    };
  }
  async createTransaction(txParameters, req) {
    const normalizedTxParameters = normalizeTxParameters(txParameters);
    const eip1559Compatibility = await this.getEIP1559Compatibility(txParameters.from);
    validateTxParameters(normalizedTxParameters, eip1559Compatibility);
    let txMeta = this.generateTxMeta({
      transaction: normalizedTxParameters,
      origin: req.origin
    });
    const {
      type,
      category,
      methodParams
    } = await determineTransactionType(txParameters, this.provider);
    txMeta.contractType = type;
    txMeta.transactionCategory = category;
    txMeta.methodParams = methodParams;
    txMeta.isUserOperation = req.isUserOperation;
    txMeta.isSignOnly = req.isSignOnly;
    txMeta.transaction.value = txMeta.transaction.value ? addHexPrefix(txMeta.transaction.value) : "0x0";
    this.emit(`${txMeta.id}:unapproved`, txMeta);
    txMeta = this.addTransactionToState(txMeta);
    txMeta = await this.addTransactionGasDefaults(txMeta);
    this.emit(TX_EVENTS.TX_UNAPPROVED, {
      txMeta,
      req
    });
    return txMeta;
  }
  _setupListeners() {
    this.setupBlockTrackerListener();
    this.pendingTxTracker.on(TX_EVENTS.TX_WARNING, data => {
      this.updateTransactionInState(data.txMeta);
    });
    this.pendingTxTracker.on(TX_EVENTS.TX_DROPPED, data => this.setTxStatusDropped(data.txId));
    this.pendingTxTracker.on(TX_EVENTS.TX_BLOCK_UPDATE, ({
      txMeta,
      latestBlockNumber
    }) => {
      if (!txMeta.firstRetryBlockNumber) {
        txMeta.firstRetryBlockNumber = latestBlockNumber;
        this.updateTransactionInState(txMeta);
      }
    });
    this.pendingTxTracker.on(TX_EVENTS.TX_RETRY, data => {
      if (!("retryCount" in data.txMeta)) {
        data.txMeta.retryCount = 0;
      }
      data.txMeta.retryCount += 1;
      this.updateTransactionInState(data.txMeta);
    });
    this.pendingTxTracker.on(TX_EVENTS.TX_FAILED, data => {
      this.setTxStatusFailed(data.txId, data.error);
    });
    this.pendingTxTracker.on(TX_EVENTS.TX_CONFIRMED, data => this.confirmTransaction(data));
  }
  setupBlockTrackerListener() {
    let listenersAreActive = false;
    const latestBlockHandler = this.onLatestBlock.bind(this);
    this.on(TX_EVENTS.TX_STATUS_UPDATE, () => {
      const pendingTxs = this.getPendingTransactions();
      if (!listenersAreActive && pendingTxs.length > 0) {
        this.blockTracker.on("latest", latestBlockHandler);
        listenersAreActive = true;
      } else if (listenersAreActive && !pendingTxs.length) {
        this.blockTracker.removeListener("latest", latestBlockHandler);
        listenersAreActive = false;
      }
    });
  }
  async onLatestBlock(blockNumber) {
    try {
      await this.pendingTxTracker.updatePendingTxs();
    } catch (error) {
      log.error(error);
    }
    try {
      await this.pendingTxTracker.resubmitPendingTxs(blockNumber);
    } catch (error) {
      log.error(error);
    }
  }
  markNonceDuplicatesDropped(txId) {
    const txMeta = this.getTransaction(txId);
    const {
      nonce,
      from
    } = txMeta.transaction;
    const sameNonceTxs = this.getTransactions({
      searchCriteria: {
        from,
        nonce
      }
    });
    if (!sameNonceTxs.length) return;
    sameNonceTxs.forEach(tx => {
      if (tx.id === txId) return;
      this.updateTransactionInState(txMeta, "transactions/pending-tx-tracker#event: tx:confirmed reference to confirmed txHash with same nonce");
      if (tx.status !== TransactionStatus.failed) this.setTxStatusDropped(tx.id);
    });
  }
}

export { TransactionController };
