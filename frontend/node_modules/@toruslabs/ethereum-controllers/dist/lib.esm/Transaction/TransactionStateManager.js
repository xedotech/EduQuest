import _objectSpread from '@babel/runtime/helpers/objectSpread2';
import { BaseTransactionStateManager, TransactionStatus, randomId, omitBy, transactionMatchesNetwork, mapValues, keyBy, sortBy, pickBy, TX_EVENTS } from '@toruslabs/base-controllers';
import { snapshotFromTxMeta, replayHistory, generateHistoryEntry } from './TransactionStateHistoryHelper.js';
import { normalizeAndValidateTxParams, getFinalStates } from './TransactionUtils.js';

class TransactionStateManager extends BaseTransactionStateManager {
  constructor({
    config,
    state,
    getCurrentChainId
  }) {
    super({
      config,
      state,
      getCurrentChainId
    });
  }
  generateTxMeta(opts = {}) {
    var _opts$transaction;
    const chainId = this.getCurrentChainId();
    if (chainId === "loading") throw new Error("Torus is having trouble connecting to the network");
    let dappSuggestedGasFees = null;

    // If we are dealing with a transaction suggested by a dapp and not
    // an internally created transaction, we need to keep record of
    // the originally submitted gasParams.
    if (opts.transaction && typeof opts.origin === "string" && opts.origin !== "torus") {
      if (typeof opts.transaction.gasPrice !== "undefined") {
        dappSuggestedGasFees = {
          gasPrice: opts.transaction.gasPrice
        };
      } else if (typeof opts.transaction.maxFeePerGas !== "undefined" || typeof opts.transaction.maxPriorityFeePerGas !== "undefined") {
        dappSuggestedGasFees = {
          maxPriorityFeePerGas: opts.transaction.maxPriorityFeePerGas,
          maxFeePerGas: opts.transaction.maxFeePerGas
        };
      }
      if (typeof opts.transaction.gas !== "undefined") {
        dappSuggestedGasFees = _objectSpread(_objectSpread({}, dappSuggestedGasFees), {}, {
          gas: opts.transaction.gas
        });
      }
    }
    return _objectSpread({
      id: ((_opts$transaction = opts.transaction) === null || _opts$transaction === void 0 ? void 0 : _opts$transaction.id) || randomId(),
      time: Date.now(),
      status: TransactionStatus.unapproved,
      loadingDefaults: true,
      chainId,
      dappSuggestedGasFees
    }, opts);
  }
  addTransactionToState(txMeta) {
    if (txMeta.transaction) {
      txMeta.transaction = normalizeAndValidateTxParams(txMeta.transaction, false);
    }
    this.once(`${txMeta.id}:signed`, () => {
      this.removeAllListeners(`${txMeta.id}:rejected`);
    });
    this.once(`${txMeta.id}:rejected`, () => {
      this.removeAllListeners(`${txMeta.id}:signed`);
    });
    // initialize history
    txMeta.history = [];
    // capture initial snapshot of txMeta for history
    const snapshot = snapshotFromTxMeta(txMeta);
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    txMeta.history.push(snapshot);
    const transactions = this.getTransactions({
      filterToCurrentNetwork: false
    });
    const {
      txHistoryLimit
    } = this.config;

    // checks if the length of the tx history is longer then desired persistence
    // limit and then if it is removes the oldest confirmed or rejected tx.
    // Pending or unapproved transactions will not be removed by this
    // operation. For safety of presenting a fully functional transaction UI
    // representation, this function will not break apart transactions with the
    // same nonce, per network. Not accounting for transactions of the same
    // nonce and network combo can result in confusing or broken experiences
    // in the UI.
    //
    // we will send UI only collected groups of transactions *per page* so at
    // some point in the future, this persistence limit can be adjusted. When
    // we do that I think we should figure out a better storage solution for
    // transaction history entries.
    const nonceNetworkSet = new Set();
    const txsToDelete = transactions.reverse().filter(tx => {
      const {
        nonce
      } = tx.transaction;
      const {
        chainId,
        status
      } = tx;
      const key = `${nonce}-${chainId}`;
      if (nonceNetworkSet.has(key)) {
        return false;
      }
      if (nonceNetworkSet.size < txHistoryLimit - 1 || getFinalStates().includes(status) === false) {
        nonceNetworkSet.add(key);
        return false;
      }
      return true;
    }).map(tx => tx.id);
    this._deleteTransactions(txsToDelete);
    this._addTransactionsToState([txMeta]);
    return txMeta;
  }

  /**
    Removes transaction from the given address for the current network
    from the txList
  */
  wipeTransactions(address) {
    const {
      transactions
    } = this.state;
    const chainId = this.getCurrentChainId();
    this.update({
      transactions: omitBy(transactions, txMeta => {
        const transactionMatch = transactionMatchesNetwork(txMeta, chainId);
        return txMeta.transaction.from === address && transactionMatch;
      })
    });
  }
  getTransactions({
    searchCriteria = {},
    initialList = undefined,
    filterToCurrentNetwork = true,
    limit = undefined
  } = {}) {
    const chainId = this.getCurrentChainId();
    // searchCriteria is an object that might have values that aren't predicate
    // methods. When providing any other value type (string, number, etc), we
    // consider this shorthand for "check the value at key for strict equality
    // with the provided value". To conform this object to be only methods, we
    // mapValues (lodash) such that every value on the object is a method that
    // returns a boolean.
    const predicateMethods = mapValues(searchCriteria, predicate => typeof predicate === "function" ? predicate : v => v === predicate);

    // If an initial list is provided we need to change it back into an object
    // first, so that it matches the shape of our state. This is done by the
    // lodash keyBy method. This is the edge case for this method, typically
    // initialList will be undefined.
    const transactionsToFilter = initialList ? keyBy(initialList, "id") : this.state.transactions;

    // Combine sortBy and pickBy to transform our state object into an array of
    // matching transactions that are sorted by time.
    const filteredTransactions = sortBy(Object.values(pickBy(transactionsToFilter, txMeta => {
      // default matchesCriteria to the value of transactionMatchesNetwork
      // when filterToCurrentNetwork is true.
      const transactionMatches = transactionMatchesNetwork(txMeta, chainId);
      if (filterToCurrentNetwork && !transactionMatches) {
        return false;
      }
      // iterate over the predicateMethods keys to check if the transaction
      // matches the searchCriteria
      for (const [key, predicate] of Object.entries(predicateMethods)) {
        // We return false early as soon as we know that one of the specified
        // search criteria do not match the transaction. This prevents
        // needlessly checking all criteria when we already know the criteria
        // are not fully satisfied. We check both txParams and the base
        // object as predicate keys can be either.
        if (key in txMeta.transaction) {
          if (predicate(txMeta.transaction[key]) === false) {
            return false;
          }
        } else if (predicate(txMeta[key]) === false) {
          return false;
        }
      }
      return true;
    })), "time");
    if (limit !== undefined) {
      // We need to have all transactions of a given nonce in order to display
      // necessary details in the UI. We use the size of this set to determine
      // whether we have reached the limit provided, thus ensuring that all
      // transactions of nonces we include will be sent to the UI.
      const nonces = new Set();
      const txs = [];
      // By default, the transaction list we filter from is sorted by time ASC.
      // To ensure that filtered results prefers the newest transactions we
      // iterate from right to left, inserting transactions into front of a new
      // array. The original order is preserved, but we ensure that newest txs
      // are preferred.
      for (let i = filteredTransactions.length - 1; i > -1; i -= 1) {
        const txMeta = filteredTransactions[i];
        const {
          nonce
        } = txMeta.transaction;
        if (!nonces.has(nonce)) {
          if (nonces.size < limit) {
            nonces.add(nonce);
          } else {
            continue;
          }
        }
        // Push transaction into the beginning of our array to ensure the
        // original order is preserved.
        txs.unshift(txMeta);
      }
      return txs;
    }
    return filteredTransactions;
  }
  getApprovedTransactions(address) {
    const searchCriteria = {
      status: TransactionStatus.approved
    };
    if (address) {
      searchCriteria.from = address;
    }
    return this.getTransactions({
      searchCriteria
    });
  }
  getSubmittedTransactions(address) {
    const searchCriteria = {
      status: TransactionStatus.submitted
    };
    if (address) {
      searchCriteria.from = address;
    }
    return this.getTransactions({
      searchCriteria
    });
  }
  getPendingTransactions(address) {
    const submitted = this.getSubmittedTransactions(address);
    const approved = this.getApprovedTransactions(address);
    return [...submitted, ...approved];
  }
  getConfirmedTransactions(address) {
    const searchCriteria = {
      status: TransactionStatus.confirmed
    };
    if (address) {
      searchCriteria.from = address;
    }
    return this.getTransactions({
      searchCriteria
    });
  }
  getUnapprovedTxList() {
    const chainId = this.getCurrentChainId();
    return pickBy(this.state.transactions, transaction => {
      const transactionMatches = transactionMatchesNetwork(transaction, chainId);
      return transaction.status === TransactionStatus.unapproved && transactionMatches;
    });
  }
  updateTransactionInState(txMeta, note) {
    // validate txParams
    if (txMeta.transaction) {
      txMeta.transaction = normalizeAndValidateTxParams(txMeta.transaction, false);
    }

    // create txMeta snapshot for history
    const currentState = snapshotFromTxMeta(txMeta);
    // recover previous tx state obj
    const previousState = replayHistory(txMeta.history);
    // generate history entry and add to history
    const entry = generateHistoryEntry(previousState, currentState, note);
    if (entry.length > 0) {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      txMeta.history.push(entry);
    }

    // commit txMeta to state
    this.updateTransaction(txMeta);
  }
  _setTransactionStatus(txId, status, isFinalStep) {
    const txMeta = this.getTransaction(txId);
    if (!txMeta) {
      return;
    }
    txMeta.status = status;
    this.updateTransactionInState(txMeta);
    this.emit(TX_EVENTS.TX_STATUS_UPDATE, {
      txId,
      status
    });
    if (this.isFinalState(status) || isFinalStep) {
      this.emit(`${txMeta.id}:finished`, txMeta);
    } else {
      this.emit(`${txMeta.id}:${status}`, txId);
    }
  }
}

export { TransactionStateManager };
