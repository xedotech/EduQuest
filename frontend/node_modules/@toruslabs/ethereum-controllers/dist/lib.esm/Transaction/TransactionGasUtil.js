import _defineProperty from '@babel/runtime/helpers/defineProperty';
import { stripHexPrefix, addHexPrefix } from '@ethereumjs/util';
import { cloneDeep } from '@toruslabs/base-controllers';
import { BN } from 'bn.js';
import log from 'loglevel';

class TransactionGasUtil {
  constructor(provider, blockTracker) {
    _defineProperty(this, "provider", void 0);
    _defineProperty(this, "blockTracker", void 0);
    this.provider = provider;
    this.blockTracker = blockTracker;
  }
  async analyzeGasUsage(txMeta) {
    const block = await this.blockTracker.getLatestBlock();
    // fallback to block gasLimit
    const blockGasLimitBN = new BN(stripHexPrefix(block.gasLimit), 16);
    const saferGasLimitBN = blockGasLimitBN.mul(new BN(19)).div(new BN(20));
    let estimatedGasHex = addHexPrefix(saferGasLimitBN.toString("hex"));
    let simulationFails;
    try {
      estimatedGasHex = await this.estimateTxGas(txMeta);
    } catch (error) {
      log.warn(error);
      simulationFails = {
        reason: error.message,
        errorKey: error.errorKey,
        debug: {
          blockNumber: block.idempotencyKey,
          blockGasLimit: block.gasLimit
        }
      };
    }
    return {
      blockGasLimit: block.gasLimit,
      estimatedGasHex,
      simulationFails
    };
  }

  /**
    Adds a gas buffer with out exceeding the block gas limit
  */
  addGasBuffer(initialGasLimitHex, blockGasLimitHex, multiplier = 1.5) {
    const initialGasLimitBn = new BN(stripHexPrefix(initialGasLimitHex), 16);
    const blockGasLimitBn = new BN(stripHexPrefix(blockGasLimitHex), 16);
    const upperGasLimitBn = blockGasLimitBn.muln(0.9);
    const bufferedGasLimitBn = initialGasLimitBn.muln(multiplier);

    // if initialGasLimit is above blockGasLimit, dont modify it
    if (initialGasLimitBn.gt(upperGasLimitBn)) return addHexPrefix(initialGasLimitBn.toString("hex"));
    // if bufferedGasLimit is below blockGasLimit, use bufferedGasLimit
    if (bufferedGasLimitBn.lt(upperGasLimitBn)) return addHexPrefix(bufferedGasLimitBn.toString("hex"));
    // otherwise use blockGasLimit
    return addHexPrefix(upperGasLimitBn.toString("hex"));
  }

  /**
    Estimates the tx's gas usage
  */
  async estimateTxGas(txMeta) {
    const txParams = cloneDeep(txMeta.transaction);

    // `eth_estimateGas` can fail if the user has insufficient balance for the
    // value being sent, or for the gas cost. We don't want to check their
    // balance here, we just want the gas estimate. The gas price is removed
    // to skip those balance checks. We check balance elsewhere. We also delete
    // maxFeePerGas and maxPriorityFeePerGas to support EIP-1559 txs.
    delete txParams.gasPrice;
    delete txParams.maxFeePerGas;
    delete txParams.maxPriorityFeePerGas;
    return this.provider.request({
      method: "eth_estimateGas",
      params: [txParams]
    });
  }
}

export { TransactionGasUtil };
