import _objectSpread from '@babel/runtime/helpers/objectSpread2';
import _defineProperty from '@babel/runtime/helpers/defineProperty';
import { BaseController } from '@toruslabs/base-controllers';
import { Mutex } from 'async-mutex';
import { BrowserProvider, toQuantity, Contract } from 'ethers';
import log from 'loglevel';
import { singleBalanceCheckerAbi } from '../utils/abis.js';
import { SINGLE_CALL_BALANCES_ADDRESSES } from '../utils/contractAddresses.js';

const ZERO_ADDRESS = "0x0000000000000000000000000000000000000000";

/**
 * Tracks accounts based on blocks.
 * If block tracker provides latest block, we query accounts from it.
 * Preferences state changes also retrigger accounts update.
 * Network state changes also retrigger accounts update.
 */
class AccountTrackerController extends BaseController {
  constructor({
    config,
    state,
    provider,
    blockTracker,
    getIdentities,
    onPreferencesStateChange,
    getCurrentChainId
  }) {
    super({
      config,
      state
    });
    _defineProperty(this, "provider", void 0);
    _defineProperty(this, "blockTracker", void 0);
    _defineProperty(this, "mutex", new Mutex());
    _defineProperty(this, "ethersProvider", void 0);
    _defineProperty(this, "getIdentities", void 0);
    _defineProperty(this, "getCurrentChainId", void 0);
    this.defaultState = {
      accounts: {}
    };
    this.initialize();
    this.provider = provider;
    this.blockTracker = blockTracker;
    this.ethersProvider = new BrowserProvider(this.provider, "any");
    this.getIdentities = getIdentities;
    this.getCurrentChainId = getCurrentChainId;
    onPreferencesStateChange(() => {
      const refreshNeeded = this.syncAccounts();
      if (refreshNeeded) {
        log.info("onPreferencesStateChange called");
        this.refresh();
      }
    });
    this.blockTrackerListener = this.blockTrackerListener.bind(this);
  }
  blockTrackerListener() {
    this.refresh();
  }
  startPolling() {
    this.stopPolling();
    // Initiate block tracker internal tracking.
    if (Object.keys(this.state.accounts).length > 0) {
      // Adding this listener on block tracker triggers it to start polling.
      this.blockTracker.on("latest", this.blockTrackerListener);
    }
  }
  stopPolling() {
    this.blockTracker.removeListener("latest", this.blockTrackerListener);
  }
  syncAccounts() {
    const {
      accounts
    } = this.state;
    const addresses = Object.keys(this.getIdentities());
    const existing = Object.keys(accounts);
    const newAddresses = addresses.filter(address => existing.indexOf(address) === -1);
    const oldAddresses = existing.filter(address => addresses.indexOf(address) === -1);
    let isUpdated = false;
    newAddresses.forEach(address => {
      isUpdated = true;
      accounts[address] = {
        balance: "0x0"
      };
    });
    oldAddresses.forEach(address => {
      isUpdated = true;
      delete accounts[address];
    });
    this.update({
      accounts: _objectSpread({}, accounts)
    });
    return isUpdated;
  }
  async refresh() {
    const releaseLock = await this.mutex.acquire();
    try {
      this._updateAccounts();
    } catch {
      // do nothing
    } finally {
      releaseLock();
    }
  }
  async _updateAccounts() {
    const {
      accounts
    } = this.state;
    const addresses = Object.keys(accounts);
    const chainId = this.getCurrentChainId();
    if (chainId === "loading") return;
    if (addresses.length > 0) {
      if (SINGLE_CALL_BALANCES_ADDRESSES[chainId]) {
        await this._updateAccountsViaBalanceChecker(addresses, SINGLE_CALL_BALANCES_ADDRESSES[chainId]);
        return;
      }
      log.info("falling back to ethQuery.getBalance");
      await Promise.all(addresses.map(x => this._updateAccount(x)));
    }
  }
  async _updateAccount(address) {
    const balance = await this.provider.request({
      method: "eth_getBalance",
      params: [address, "latest"]
    });
    const {
      accounts
    } = this.state;
    if (!accounts[address]) return;
    accounts[address] = {
      balance: toQuantity(balance)
    };
    this.update({
      accounts
    });
  }
  async _updateAccountsViaBalanceChecker(addresses, deployedContractAddress) {
    const ethContract = new Contract(deployedContractAddress, singleBalanceCheckerAbi, this.ethersProvider);
    try {
      const result = await ethContract.balances(addresses, [ZERO_ADDRESS]);
      const {
        accounts
      } = this.state;
      addresses.forEach((address, index) => {
        const balance = toQuantity(result[index]);
        if (!accounts[address]) return;
        accounts[address] = {
          balance
        };
      });
      return this.update({
        accounts
      });
    } catch (error) {
      log.warn("Torus - Account Tracker single call balance fetch failed", error);
      return Promise.all(addresses.map(x => this._updateAccount(x)));
    }
  }
}

export { AccountTrackerController };
