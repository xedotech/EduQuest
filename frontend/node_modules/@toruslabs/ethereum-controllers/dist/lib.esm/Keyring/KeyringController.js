import { addHexPrefix, bytesToHex, privateToPublic, toChecksumAddress, privateToAddress, stripHexPrefix, ecsign, bigIntToBytes, isHexString } from '@ethereumjs/util';
import { BaseKeyringController, concatSig } from '@toruslabs/base-controllers';
import { SigningKey, hashMessage, TypedDataEncoder } from 'ethers';

class KeyringController extends BaseKeyringController {
  constructor({
    config,
    state
  }) {
    super({
      config,
      state
    });
    this.defaultState = {
      wallets: []
    };
    this.initialize();
  }
  async signTransaction(tx, address) {
    const wallet = this._getWalletForAccount(address);
    const privKey = new SigningKey(addHexPrefix(wallet.privateKey));
    const localTx = tx;
    localTx.signature = privKey.sign(localTx.unsignedHash);
    return localTx;
  }
  getAccounts() {
    return this.state.wallets.map(w => w.publicKey);
  }
  importAccount(accountPrivateKey) {
    const hexPrivateKey = accountPrivateKey.padStart(64, "0");
    const bufferPrivKey = Buffer.from(hexPrivateKey, "hex");
    const publicKey = bytesToHex(privateToPublic(bufferPrivKey));
    const address = toChecksumAddress(bytesToHex(privateToAddress(bufferPrivKey)));
    const existingWallet = this.state.wallets.find(w => w.address === address);
    if (existingWallet) return existingWallet.address;
    this.update({
      wallets: [...this.state.wallets, {
        publicKey,
        privateKey: accountPrivateKey,
        address
      }]
    });
    return address;
  }
  removeAccount(address) {
    const newWallets = [...this.state.wallets];
    const idx = newWallets.findIndex(w => w.address === address);
    if (idx !== -1) {
      newWallets.splice(idx, 1);
      this.update({
        wallets: newWallets
      });
    }
  }
  getBufferPrivateKey(privateKey) {
    const stripped = stripHexPrefix(privateKey);
    return Buffer.from(stripped, "hex");
  }

  // For eth_sign, we need to sign arbitrary data:
  async signMessage(data, address) {
    const wallet = this._getWalletForAccount(address);
    const privKey = this.getBufferPrivateKey(wallet.privateKey);
    const messageSig = ecsign(Buffer.from(stripHexPrefix(data), "hex"), privKey);
    const sig = concatSig(Buffer.from(bigIntToBytes(messageSig.v)), Buffer.from(messageSig.r), Buffer.from(messageSig.s));
    return sig;
  }
  async signPersonalMessage(data, address) {
    const wallet = this._getWalletForAccount(address);
    const privKey = new SigningKey(addHexPrefix(wallet.privateKey));
    // we need to check if the data is hex or not
    // For historical reasons, you must submit the message to sign in hex-encoded UTF-8.
    // https://docs.metamask.io/wallet/how-to/sign-data/#use-personal_sign
    const message = isHexString(data) ? Buffer.from(stripHexPrefix(data), "hex") : Buffer.from(data);
    const signature = privKey.sign(hashMessage(message)).serialized;
    return signature;
  }

  // personal_signTypedData, signs data along with the schema
  async signTypedData(typedData, address) {
    const wallet = this._getWalletForAccount(address);
    const privKey = new SigningKey(addHexPrefix(wallet.privateKey));
    delete typedData.types.EIP712Domain;
    const signature = privKey.sign(TypedDataEncoder.hash(typedData.domain, typedData.types, typedData.message)).serialized;
    return signature;
  }
  _getWalletForAccount(account) {
    const address = account.toLowerCase();
    const wallet = this.state.wallets.find(w => w.address.toLowerCase() === address);
    if (!wallet) throw new Error("Torus Keyring - Unable to find matching address.");
    return wallet;
  }
}

export { KeyringController };
