import _objectSpread from '@babel/runtime/helpers/objectSpread2';
import _defineProperty from '@babel/runtime/helpers/defineProperty';
import { BaseCurrencyController, PollingManager } from '@toruslabs/base-controllers';
import { get } from '@toruslabs/http-helpers';
import log from 'loglevel';

class CurrencyController extends BaseCurrencyController {
  constructor({
    config,
    state,
    idleTimeTracker,
    onNetworkChanged
  }) {
    super({
      config,
      state
    });
    _defineProperty(this, "pollingManager", void 0);
    this.defaultState = _objectSpread(_objectSpread({}, this.defaultState), {}, {
      commonDenomination: "USD",
      commonDenominatorPrice: 0
    });
    this.initialize();
    onNetworkChanged(networkState => {
      // to be called as (listener) => this.networkController.on('networkDidChange', listener);
      if (networkState.providerConfig.ticker.toUpperCase() !== this.state.nativeCurrency.toUpperCase()) {
        this.setNativeCurrency(networkState.providerConfig.ticker);
        this.updateConversionRate();
      }
    });
    this.pollingManager = new PollingManager(idleTimeTracker, this.config.pollInterval);
  }
  setCommonDenomination(commonDenomination) {
    this.update({
      commonDenomination
    });
  }
  getCommonDenomination() {
    return this.state.commonDenomination;
  }
  setCommonDenominatorPrice(commonDenominatorPrice) {
    this.update({
      commonDenominatorPrice
    });
  }
  getCommonDenominatorPrice() {
    return this.state.commonDenominatorPrice;
  }

  /**
   * Creates a new poll, using setInterval, to periodically call updateConversionRate. The id of the interval is
   * stored at the controller's conversionInterval property. If it is called and such an id already exists, the
   * previous interval is clear and a new one is created.
   */
  async scheduleConversionInterval() {
    this.pollingManager.start(this.updateConversionRate.bind(this));
  }

  /**
   * Updates the conversionRate and conversionDate properties associated with the currentCurrency. Updated info is
   * fetched from an external API
   */
  async updateConversionRate() {
    const currentCurrency = this.getCurrentCurrency();
    const nativeCurrency = this.getNativeCurrency();
    const commonDenomination = this.getCommonDenomination();
    const conversionRate = await this.retrieveConversionRate(nativeCurrency, currentCurrency, commonDenomination);
    const currentCurrencyRate = Number.parseFloat(conversionRate[currentCurrency.toUpperCase()]);
    const commonDenominationRate = Number.parseFloat(conversionRate[commonDenomination.toUpperCase()]);
    // set conversion rate
    if (currentCurrencyRate || commonDenominationRate) {
      // ETC
      this.setConversionRate(currentCurrencyRate);
      this.setConversionDate(Math.floor(Date.now() / 1000).toString());
      if (currentCurrency.toUpperCase() === commonDenomination.toUpperCase()) {
        this.setCommonDenominatorPrice(currentCurrencyRate);
      } else {
        this.setCommonDenominatorPrice(commonDenominationRate);
      }
    } else {
      this.setConversionRate(0);
      this.setConversionDate("N/A");
    }
  }
  async retrieveConversionRate(fromCurrency, toCurrency, commonDenomination) {
    try {
      let apiUrl = `${this.config.api}/currency?fsym=${fromCurrency.toUpperCase()}&tsyms=${toCurrency.toUpperCase()}`;
      if (commonDenomination && commonDenomination.toUpperCase() !== toCurrency.toUpperCase()) {
        apiUrl += `,${commonDenomination.toUpperCase()}`;
      }
      const parsedResponse = await get(apiUrl);
      return parsedResponse;
    } catch (error) {
      log.error(error, `CurrencyController - updateCommonDenominatorPrice: Failed to query rate for currency: ${fromCurrency}/ ${toCurrency}`);
    }
    return {
      [toCurrency.toUpperCase()]: "0",
      [commonDenomination.toUpperCase()]: "0"
    };
  }
}

export { CurrencyController };
