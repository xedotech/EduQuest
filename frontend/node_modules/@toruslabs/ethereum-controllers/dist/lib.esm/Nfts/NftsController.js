import _objectSpread from '@babel/runtime/helpers/objectSpread2';
import _defineProperty from '@babel/runtime/helpers/defineProperty';
import { BaseController, PollingManager } from '@toruslabs/base-controllers';
import deepmerge from 'deepmerge';
import { BrowserProvider } from 'ethers';
import log from 'loglevel';
import { MM_NFT_API_SUPPORTED_CHAINS } from '../utils/constants.js';
import { NftHandler } from './NftHandler.js';

const DEFAULT_INTERVAL = 180 * 1000;
class NftsController extends BaseController {
  constructor({
    config,
    state,
    provider,
    getCustomNfts,
    getSimpleHashNfts,
    onPreferencesStateChange,
    onNetworkStateChange,
    idleTimeTracker
  }) {
    super({
      config,
      state
    });
    _defineProperty(this, "name", "NftsController");
    _defineProperty(this, "provider", void 0);
    _defineProperty(this, "ethersProvider", void 0);
    _defineProperty(this, "getCustomNfts", void 0);
    _defineProperty(this, "getSimpleHashNfts", void 0);
    _defineProperty(this, "pollingManager", void 0);
    this.provider = provider;
    this.ethersProvider = new BrowserProvider(this.provider, "any");
    this.getCustomNfts = getCustomNfts;
    this.getSimpleHashNfts = getSimpleHashNfts;
    this.defaultConfig = {
      interval: DEFAULT_INTERVAL,
      selectedAddress: "",
      chainId: ""
    };
    this.defaultState = {
      nfts: {}
    };
    this.initialize();
    onPreferencesStateChange(preferencesState => {
      if (preferencesState.selectedAddress !== this.config.selectedAddress) {
        this.configure({
          selectedAddress: preferencesState.selectedAddress
        });
        this.restartNftDetection();
      }
    });
    onNetworkStateChange(networkState => {
      const {
        chainId
      } = networkState.providerConfig;
      if (chainId !== this.config.chainId) {
        this.configure({
          chainId
        });
        this.restartNftDetection();
      }
    });
    this.pollingManager = new PollingManager(idleTimeTracker, this.config.interval);
  }
  get userSelectedAddress() {
    return this.config.selectedAddress;
  }
  get userNfts() {
    var _this$state$nfts$this;
    if (!this.userSelectedAddress) return [];
    return (_this$state$nfts$this = this.state.nfts[this.userSelectedAddress]) !== null && _this$state$nfts$this !== void 0 ? _this$state$nfts$this : [];
  }
  startNftDetection(selectedAddress) {
    this.configure({
      selectedAddress
    });
    this.restartNftDetection();
  }

  /**
   * Restart nft detection polling period and call detectNewNfts
   * in case of address change or user session initialization.
   *
   */
  restartNftDetection() {
    if (!this.userSelectedAddress) {
      return;
    }
    this.pollingManager.start(() => {
      this.detectNewNfts();
      this.refreshNftBalances();
    });
  }
  detectNewNfts() {
    const userAddress = this.userSelectedAddress;
    if (!userAddress) return;
    const currentChainId = this.config.chainId;
    const nftsToDetect = []; // object[]
    if (!currentChainId) {
      this.update({
        nfts: {
          [userAddress]: [...nftsToDetect]
        }
      });
      return;
    }
    if (this.getCustomNfts) {
      const customNfts = this.getCustomNfts(userAddress);
      const reducedNfts = customNfts.reduce((acc, x) => {
        // first aggregate by contract address
        if (x.network === currentChainId) {
          const newAsset = {
            description: "",
            image: "",
            name: "",
            tokenBalance: "",
            tokenId: x.nft_id,
            customNftId: x.id.toString()
          };
          if (acc[x.nft_address]) {
            acc[x.nft_address].assets.push(newAsset);
          } else {
            const objToPush = {
              assets: [newAsset],
              chainId: x.network,
              contractAddress: x.nft_address,
              contractName: "",
              contractSymbol: "",
              contractImage: "",
              nftStandard: x.nft_contract_standard,
              contractDescription: ""
            };
            acc[x.nft_address] = objToPush;
          }
        }
        return acc;
      }, {});
      nftsToDetect.push(...Object.values(reducedNfts));
    }
    this.update({
      nfts: {
        [userAddress]: [...nftsToDetect]
      }
    });
  }
  async refreshNftBalances(skipCache) {
    const userAddress = this.userSelectedAddress;
    if (userAddress === "") return;
    const oldNfts = [...this.userNfts];
    const nonZeroNfts = [];
    try {
      const currentChainId = this.config.chainId;
      if (MM_NFT_API_SUPPORTED_CHAINS.includes(currentChainId)) {
        const simpleHashBalances = await this.getSimpleHashNfts(userAddress, currentChainId, skipCache);
        nonZeroNfts.push(...simpleHashBalances);
        this.update({
          nfts: {
            [userAddress]: nonZeroNfts
          }
        });
      }
      if (oldNfts.length > 0) {
        this.getNftBalancesUsingHandler(oldNfts);
      }
    } catch (error) {
      log.error(error, "unable to fetch nft balances");
    }
  }
  async getNftBalancesUsingHandler(customNfts) {
    if (!this.userSelectedAddress) return;
    const userAddress = this.userSelectedAddress;
    const currentNetworkNfts = customNfts;
    const promiseSettledResult = await Promise.allSettled(currentNetworkNfts.map(async x => {
      try {
        const tokenInstance = new NftHandler(_objectSpread(_objectSpread({}, x), {}, {
          provider: this.ethersProvider
        }));
        const contractData = await tokenInstance.getContractMetadata();
        const assetData = await Promise.allSettled(x.assets.map(y => tokenInstance.getNftMetadata(userAddress, y)));
        return _objectSpread(_objectSpread({}, contractData), {}, {
          assets: assetData.filter(z => z.status === "fulfilled").map(z => z.value)
        });
      } catch (error) {
        log.warn("Invalid contract address while fetching", error);
        return undefined;
      }
    }));
    const nonZeroTokens = promiseSettledResult.filter(x => x.status === "fulfilled" && x.value).map(x => x.value);
    this.update({
      nfts: {
        [userAddress]: deepmerge(this.userNfts, nonZeroTokens)
      }
    });
  }
}

export { NftsController };
