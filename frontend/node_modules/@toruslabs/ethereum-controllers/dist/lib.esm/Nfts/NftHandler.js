import _objectSpread from '@babel/runtime/helpers/objectSpread2';
import _defineProperty from '@babel/runtime/helpers/defineProperty';
import { get } from '@toruslabs/http-helpers';
import { Contract } from 'ethers';
import log from 'loglevel';
import { erc721Abi, erc1155Abi } from '../utils/abis.js';
import { CONTRACT_TYPE_ERC721, CONTRACT_TYPE_ERC1155, OLD_ERC721_LIST, ERC721_INTERFACE_ID, ERC1155_INTERFACE_ID } from '../utils/constants.js';
import { sanitizeNftMetdataUrl } from '../utils/helpers.js';

class NftHandler {
  constructor({
    chainId,
    contractAddress,
    contractImage,
    contractName,
    contractSymbol,
    nftStandard,
    provider,
    contractDescription,
    contractFallbackLogo,
    contractSupply
  }) {
    _defineProperty(this, "contractAddress", void 0);
    _defineProperty(this, "contractName", void 0);
    _defineProperty(this, "contractSymbol", void 0);
    _defineProperty(this, "contractImage", void 0);
    _defineProperty(this, "contractSupply", void 0);
    _defineProperty(this, "contractFallbackLogo", void 0);
    _defineProperty(this, "nftStandard", void 0);
    _defineProperty(this, "contractDescription", void 0);
    _defineProperty(this, "chainId", void 0);
    _defineProperty(this, "provider", void 0);
    _defineProperty(this, "isSpecial", void 0);
    this.chainId = chainId;
    this.contractAddress = contractAddress;
    this.contractImage = contractImage;
    this.contractName = contractName;
    this.contractSymbol = contractSymbol;
    this.nftStandard = nftStandard;
    this.provider = provider;
    this.contractDescription = contractDescription;
    this.contractFallbackLogo = contractFallbackLogo;
    this.contractSupply = contractSupply;
  }
  async getNftMetadata(userAddress, tokenInfo) {
    const returnNftItem = _objectSpread({
      description: "",
      image: "",
      name: "",
      tokenBalance: "",
      tokenId: "",
      decimals: "1"
    }, tokenInfo);
    const [tokenURI, balance] = await Promise.all([this.getCollectibleTokenURI(returnNftItem.tokenId, this.nftStandard), !returnNftItem.tokenBalance ? this.fetchNftBalance(userAddress, returnNftItem.tokenId) : Promise.resolve("0")]);
    returnNftItem.tokenBalance = returnNftItem.tokenBalance || balance;
    // some people put full json object in uri
    try {
      const object = JSON.parse(tokenURI);
      returnNftItem.image = returnNftItem.image || sanitizeNftMetdataUrl(object.image);
      returnNftItem.name = returnNftItem.name || object.name;
      returnNftItem.description = returnNftItem.description || object.description;
      returnNftItem.decimals = returnNftItem.decimals || object.decimals;
    } catch (error) {
      log.warn("Token uri is not a valid json object", error);
    }
    const finalTokenMetaUri = sanitizeNftMetdataUrl(tokenURI);
    try {
      if (!returnNftItem.description || !returnNftItem.image || !returnNftItem.name) {
        // this call might fail, if metadata url available in smart contract is not reachable
        const object = await get(finalTokenMetaUri);
        returnNftItem.image = returnNftItem.image || sanitizeNftMetdataUrl(object.image);
        returnNftItem.name = returnNftItem.name || object.name;
        returnNftItem.description = returnNftItem.description || object.description;
        returnNftItem.decimals = returnNftItem.decimals || object.decimals;
      }
    } catch (error) {
      log.error("Failed to fetch nft metadata", error);
    }
    return returnNftItem;
  }
  async getContractMetadata() {
    const returnNft = {
      chainId: this.chainId,
      contractAddress: this.contractAddress,
      contractName: this.contractName,
      contractSymbol: this.contractSymbol,
      nftStandard: this.nftStandard,
      contractImage: this.contractImage,
      contractDescription: this.contractDescription,
      contractFallbackLogo: this.contractFallbackLogo,
      contractSupply: this.contractSupply
    };
    if (!this.nftStandard) {
      const {
        standard,
        isSpecial
      } = await this.checkNftStandard();
      returnNft.nftStandard = standard;
      this.nftStandard = standard;
      this.isSpecial = isSpecial;
    }
    if (!this.contractName || !this.contractSymbol || !this.contractDescription) {
      const abi = this.nftStandard === CONTRACT_TYPE_ERC721 ? erc721Abi : erc1155Abi;
      const contract = new Contract(this.contractAddress, abi, this.provider);
      const [name, symbol] = await Promise.all([contract.name(), contract.symbol()]);
      returnNft.contractName = name;
      returnNft.contractSymbol = symbol;
      if (!this.contractName) this.contractName = name;
      if (!this.contractSymbol) this.contractSymbol = symbol;
    }
    return returnNft;
  }
  async fetchNftBalance(userAddress, tokenId) {
    const {
      standard
    } = await this.checkNftStandard();
    const abi = standard === CONTRACT_TYPE_ERC721 ? erc721Abi : erc1155Abi;
    const contract = new Contract(this.contractAddress, abi, this.provider);
    if (standard === CONTRACT_TYPE_ERC1155) {
      const balance = await contract.balanceOf(userAddress, tokenId);
      return balance;
    }
    let owner = "";
    try {
      owner = await contract.ownerOf(tokenId);
    } catch {
      throw new Error("Token id doesn't exists");
    }
    if (owner.toLowerCase() === userAddress.toLowerCase()) {
      return "1";
    }
    return "0";
  }
  async checkNftStandard() {
    // For Cryptokitties
    if (this.nftStandard && this.isSpecial !== undefined) return;
    if (Object.prototype.hasOwnProperty.call(OLD_ERC721_LIST, this.contractAddress.toLowerCase())) {
      this.nftStandard = CONTRACT_TYPE_ERC721;
      this.isSpecial = true;
      return {
        standard: CONTRACT_TYPE_ERC721,
        isSpecial: true
      };
    }
    const isErc721 = await this.contractSupportsInterface(CONTRACT_TYPE_ERC721, ERC721_INTERFACE_ID);
    if (isErc721) {
      this.nftStandard = CONTRACT_TYPE_ERC721;
      this.isSpecial = false;
      return {
        standard: CONTRACT_TYPE_ERC721,
        isSpecial: false
      };
    }
    const isErc1155 = await this.contractSupportsInterface(CONTRACT_TYPE_ERC1155, ERC1155_INTERFACE_ID);
    if (isErc1155) {
      this.nftStandard = CONTRACT_TYPE_ERC1155;
      this.isSpecial = false;
      return {
        standard: CONTRACT_TYPE_ERC1155,
        isSpecial: false
      };
    }
    throw new Error("Unsupported nft standard");
  }
  async contractSupportsInterface(standard, interfaceId) {
    const abi = standard === CONTRACT_TYPE_ERC721 ? erc721Abi : erc1155Abi;
    const contract = new Contract(this.contractAddress, abi, this.provider);
    return contract.supportsInterface(interfaceId);
  }
  async getCollectibleTokenURI(tokenId, standard = CONTRACT_TYPE_ERC721) {
    const method = standard === CONTRACT_TYPE_ERC721 ? "tokenURI" : "uri";
    const abi = standard === CONTRACT_TYPE_ERC721 ? erc721Abi : erc1155Abi;
    const contract = new Contract(this.contractAddress, abi, this.provider);
    return contract[method](tokenId);
  }
}

export { NftHandler };
