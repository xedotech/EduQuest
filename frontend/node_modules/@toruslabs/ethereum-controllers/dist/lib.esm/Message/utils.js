import { isValidAddress, stripHexPrefix, addHexPrefix, bytesToHex } from '@ethereumjs/util';
import { CHAIN_NAMESPACES } from '@toruslabs/base-controllers';
import { isHexString, JsonRpcProvider, toQuantity } from 'ethers';

const hexRe = /^[0-9A-Fa-f]+$/gu;
function validateAddress(address, propertyName) {
  if (!address || typeof address !== "string" || !isValidAddress(address)) {
    throw new Error(`Invalid "${propertyName}" address: ${address} must be a valid string.`);
  }
}
function validateSignMessageData(messageData) {
  const {
    from,
    data
  } = messageData;
  validateAddress(from, "from");
  if (!data || typeof data !== "string") {
    throw new Error(`Invalid message "data": ${data} must be a valid string.`);
  }
}
function normalizeMessageData(data) {
  try {
    const stripped = stripHexPrefix(data);
    if (stripped.match(hexRe)) {
      return addHexPrefix(stripped);
    }
  } catch {
    // do nothing
  }
  return bytesToHex(Buffer.from(data, "utf8"));
}
async function validateTypedSignMessageDataV4(messageData, currentChainId) {
  validateAddress(messageData.from, "from");
  if (!messageData.data || Array.isArray(messageData.data) || typeof messageData.data !== "object" && typeof messageData.data !== "string") {
    throw new Error(`Invalid message "data": Must be a valid string or object.`);
  }
  let data;
  if (typeof messageData.data === "object") {
    data = messageData.data;
  } else {
    try {
      data = JSON.parse(messageData.data);
    } catch {
      throw new Error("Data must be passed as a valid JSON string.");
    }
  }
  if (!currentChainId) {
    throw new Error("Current chainId cannot be null or undefined.");
  }
  let {
    chainId
  } = data.domain;
  if (chainId) {
    if (typeof chainId === "string") {
      chainId = parseInt(chainId, chainId.startsWith("0x") ? 16 : 10);
    }
    const activeChainId = parseInt(currentChainId, 16);
    if (Number.isNaN(activeChainId)) {
      throw new Error(`Cannot sign messages for chainId "${chainId}", because MetaMask is switching networks.`);
    }
    if (chainId !== activeChainId) {
      throw new Error(`Provided chainId "${chainId}" must match the active chainId "${activeChainId}"`);
    }
  }
}
async function validateAddChainData(data) {
  const {
    chainId,
    rpcUrls,
    nativeCurrency
  } = data || {};
  if (!chainId) {
    throw new Error("Invalid add chain params: please pass chainId in params");
  }
  if (!isHexString(chainId)) {
    throw new Error("Invalid add chain params: please pass a valid hex chainId in params, for: ex: 0x1");
  }
  if (!rpcUrls || rpcUrls.length === 0) throw new Error("params.rpcUrls not provided");
  if (!nativeCurrency) throw new Error("params.nativeCurrency not provided");
  const {
    name,
    symbol,
    decimals
  } = nativeCurrency;
  if (!name) throw new Error("params.nativeCurrency.name not provided");
  if (!symbol) throw new Error("params.nativeCurrency.symbol not provided");
  if (decimals === undefined) throw new Error("params.nativeCurrency.decimals not provided");
  const _web3 = new JsonRpcProvider(rpcUrls[0], "any");
  const {
    chainId: networkChainID
  } = await _web3.getNetwork();
  if (Number.parseInt(networkChainID.toString()) !== Number.parseInt(chainId, 16)) {
    throw new Error(`Provided rpc url's chainId version is not matching with provided chainId, expected: ${toQuantity(networkChainID)}, received: ${chainId}`);
  }
}
function validateSwitchChainData(data) {
  const {
    chainId: fullChainId
  } = data || {};
  if (!fullChainId) {
    throw new Error("Invalid switch chain params: please pass chainId in params");
  }
  if (!isHexString(fullChainId)) {
    const [namespace, chainId] = fullChainId.split(":");
    if (namespace !== CHAIN_NAMESPACES.SOLANA && namespace !== CHAIN_NAMESPACES.EIP155) {
      throw new Error("Invalid switch chain params: invalid namespace");
    }
    if (!chainId || isNaN(Number(chainId))) {
      throw new Error("Invalid switch chain params: invalid chainId");
    }
  }
}

export { normalizeMessageData, validateAddChainData, validateAddress, validateSignMessageData, validateSwitchChainData, validateTypedSignMessageDataV4 };
