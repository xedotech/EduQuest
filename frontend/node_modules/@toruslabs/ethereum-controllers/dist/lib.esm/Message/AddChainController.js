import _objectSpread from '@babel/runtime/helpers/objectSpread2';
import _defineProperty from '@babel/runtime/helpers/defineProperty';
import { AbstractMessageController, MessageStatus, randomId, MESSAGE_EVENTS } from '@toruslabs/base-controllers';
import log from 'loglevel';
import { METHOD_TYPES } from '../utils/constants.js';
import { validateAddChainData } from './utils.js';

class AddChainController extends AbstractMessageController {
  constructor({
    config,
    state,
    addChain
  }) {
    super({
      config,
      state
    });
    _defineProperty(this, "name", "AddChainController");
    _defineProperty(this, "addChain", void 0);
    this.addChain = addChain;
    this.initialize();
  }
  async processAddChain(messageId) {
    const msgObject = this.getMessage(messageId);
    if (!msgObject) {
      throw new Error("Message not found");
    }
    try {
      await this.approveMessage(messageId, msgObject.messageParams);
      await this.addChain(msgObject.messageParams);
      this.updateMessage(_objectSpread(_objectSpread({}, msgObject), {}, {
        rawSig: JSON.stringify(msgObject.messageParams)
      }));
      this.setMessageStatus(messageId, MessageStatus.SIGNED);
      return null;
    } catch (error) {
      log.error(error);
      msgObject.error = (error === null || error === void 0 ? void 0 : error.message) || (error === null || error === void 0 ? void 0 : error.toString());
      this.setMessageStatus(messageId, MessageStatus.FAILED);
    }
  }
  async addNewUnapprovedMessage(messageParams, req) {
    await this.addUnapprovedMessage(messageParams, req);
    return this.waitForFinishStatus(messageParams, this.name);
  }
  async addUnapprovedMessage(messageParams, req) {
    // set message params origin first to satisfy the eslint rule (origin won't be checked by validateAddChainData)
    // for "Possible race condition: `messageParams.origin` might be assigned based on an outdated state of `messageParams`"
    if (req) {
      messageParams.origin = req.origin;
    }
    await validateAddChainData(messageParams);
    const messageId = messageParams.id || randomId();
    const messageData = {
      id: messageId,
      messageParams,
      status: MessageStatus.UNAPPROVED,
      time: Date.now(),
      type: METHOD_TYPES.ADD_CHAIN
    };
    await this.addMessage(messageData);
    this.emit(MESSAGE_EVENTS.UNAPPROVED_MESSAGE, {
      messageData,
      req
    });
    return messageId;
  }
  prepMessageForSigning(messageParams) {
    return Promise.resolve(messageParams);
  }
}

export { AddChainController };
