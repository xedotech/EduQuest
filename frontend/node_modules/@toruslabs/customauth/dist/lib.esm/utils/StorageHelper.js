import _defineProperty from '@babel/runtime/helpers/defineProperty';
import { SESSION_SERVER_API_URL } from '@toruslabs/constants';
import { getPublic, sign } from '@toruslabs/eccrypto';
import { post } from '@toruslabs/http-helpers';
import { keccak256, encryptData, decryptData } from '@toruslabs/metadata-helpers';
import { REDIRECT_PARAMS_STORAGE_METHOD } from './enums.js';
import { storageAvailable } from './helpers.js';
import log from './loglevel.js';

class StorageHelper {
  constructor(serverUrl) {
    _defineProperty(this, "currentStorageMethod", REDIRECT_PARAMS_STORAGE_METHOD.LOCAL_STORAGE);
    _defineProperty(this, "isInitialized", false);
    _defineProperty(this, "storageServerUrl", SESSION_SERVER_API_URL);
    _defineProperty(this, "localStorageAvailable", true);
    this.storageServerUrl = serverUrl;
  }
  get storageMethodUsed() {
    return this.currentStorageMethod;
  }
  init() {
    // const support = are3PCSupported();
    const localStorageAvailable = storageAvailable(REDIRECT_PARAMS_STORAGE_METHOD.LOCAL_STORAGE);
    this.localStorageAvailable = localStorageAvailable;
    // if (support && localStorageAvailable) {
    //   // use local storage as default for storing stuff
    //   this.currentStorageMethod = REDIRECT_PARAMS_STORAGE_METHOD.LOCAL_STORAGE;
    // } else {
    //   // use server store as default for storing stuff
    //   this.currentStorageMethod = REDIRECT_PARAMS_STORAGE_METHOD.SERVER;
    // }
    this.isInitialized = true;
  }
  async storeData(key, params) {
    if (!this.isInitialized) throw new Error("StorageHelper is not initialized");
    if (this.localStorageAvailable) window.localStorage.setItem(key, JSON.stringify(params));
    // if (this.currentStorageMethod === REDIRECT_PARAMS_STORAGE_METHOD.SERVER) {
    const privKey = keccak256(Buffer.from(key, "utf8"));
    const privKeyHex = privKey.toString("hex");
    const publicKeyHex = getPublic(privKey).toString("hex");
    const encData = await encryptData(privKeyHex, params);
    const signature = (await sign(privKey, keccak256(Buffer.from(encData, "utf8")))).toString("hex");
    await post(`${this.storageServerUrl}/v2/store/set`, {
      key: publicKeyHex,
      data: encData,
      signature,
      allowedOrigin: true
    });
    // }
  }
  async retrieveData(key) {
    if (!this.isInitialized) throw new Error("StorageHelper is not initialized");
    if (this.localStorageAvailable) {
      const data = window.localStorage.getItem(key);
      if (data) {
        this.currentStorageMethod = REDIRECT_PARAMS_STORAGE_METHOD.LOCAL_STORAGE;
        return JSON.parse(data || "{}");
      }
    }
    // if (this.currentStorageMethod === REDIRECT_PARAMS_STORAGE_METHOD.SERVER) {
    this.currentStorageMethod = REDIRECT_PARAMS_STORAGE_METHOD.SERVER;
    const privKey = keccak256(Buffer.from(key, "utf8"));
    const privKeyHex = privKey.toString("hex");
    const publicKeyHex = getPublic(privKey).toString("hex");
    try {
      const encData = await post(`${this.storageServerUrl}/v2/store/get`, {
        key: publicKeyHex
      });
      if (encData.message) {
        const data = await decryptData(privKeyHex, encData.message);
        return data;
      }
    } catch (error) {
      if (error.status === 404) {
        log.warn(error, "Session likely expired");
      } else {
        throw error;
      }
    }
    // }
  }
  clearStorage(key) {
    if (!this.isInitialized) throw new Error("StorageHelper is not initialized");
    if (this.localStorageAvailable) window.localStorage.removeItem(key);
    // No need to clear server details cause they auto expire and scope is never re-used for different login attempts
  }
  clearOrphanedData(baseKey) {
    if (!this.isInitialized) throw new Error("StorageHelper is not initialized");
    if (!this.localStorageAvailable) return;
    const allStorageKeys = Object.keys(window.localStorage);
    allStorageKeys.forEach(key => {
      if (key.startsWith(baseKey)) {
        window.localStorage.removeItem(key);
      }
    });
    // No need to clear server details cause they auto expire and scope is never re-used for different login attempts
  }
}

export { StorageHelper };
