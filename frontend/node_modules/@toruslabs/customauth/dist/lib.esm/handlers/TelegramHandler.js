import _objectSpread from '@babel/runtime/helpers/objectSpread2';
import _objectWithoutProperties from '@babel/runtime/helpers/objectWithoutProperties';
import _defineProperty from '@babel/runtime/helpers/defineProperty';
import base64url from 'base64url';
import deepmerge from 'deepmerge';
import { UX_MODE } from '../utils/enums.js';
import { validateAndConstructUrl, objectToAuthDataMap, getTimeout } from '../utils/helpers.js';
import log from '../utils/loglevel.js';
import { PopupHandler } from '../utils/PopupHandler.js';
import AbstractLoginHandler from './AbstractLoginHandler.js';

const _excluded = ["event", "origin", "result"];
class TelegramHandler extends AbstractLoginHandler {
  constructor(params) {
    super(params);
    _defineProperty(this, "RESPONSE_TYPE", "token");
    _defineProperty(this, "SCOPE", "profile");
    _defineProperty(this, "PROMPT", "select_account");
    this.setFinalUrl();
  }
  setFinalUrl() {
    const {
      domain
    } = this.params.jwtParams;
    const finalUrl = validateAndConstructUrl(domain || "https://oauth.telegram.org/auth");
    const clonedParams = JSON.parse(JSON.stringify(this.params.jwtParams || {}));
    clonedParams.origin = `${this.params.redirect_uri}?state=${this.state}&nonce=${this.nonce}`;
    const finalJwtParams = deepmerge({
      state: this.state,
      response_type: this.RESPONSE_TYPE,
      bot_id: this.params.clientId,
      prompt: this.PROMPT,
      redirect_uri: `${this.params.redirect_uri}?state=${this.state}&nonce=${this.nonce}`,
      scope: this.SCOPE,
      nonce: this.nonce
    }, clonedParams);
    Object.keys(finalJwtParams).forEach(key => {
      const localKey = key;
      if (finalJwtParams[localKey]) finalUrl.searchParams.append(localKey, finalJwtParams[localKey]);
    });
    this.finalURL = finalUrl;
  }
  async getUserInfo(params) {
    const {
      idToken
    } = params;
    const userInfo = objectToAuthDataMap(idToken);
    const {
      photo_url: profileImage = "",
      first_name = "",
      last_name = "",
      id
    } = userInfo;
    return {
      email: "",
      // Telegram does not provide email
      name: `${first_name} ${last_name}`,
      profileImage,
      authConnectionId: this.params.authConnectionId,
      userId: id.toString(),
      authConnection: this.params.authConnection,
      groupedAuthConnectionId: this.params.groupedAuthConnectionId
    };
  }
  async handleLoginWindow(params) {
    const authConnectionWindow = new PopupHandler({
      url: this.finalURL,
      features: params.popupFeatures,
      timeout: getTimeout(this.params.authConnection)
    });
    if (this.params.uxMode === UX_MODE.REDIRECT) {
      authConnectionWindow.redirect(params.locationReplaceOnRedirect);
    } else {
      return new Promise((resolve, reject) => {
        const handleData = async ev => {
          try {
            const _ref = JSON.parse(ev) || {},
              {
                event,
                origin,
                result
              } = _ref,
              rest = _objectWithoutProperties(_ref, _excluded);
            // 1. Parse URL
            const parsedUrl = new URL(origin);
            // 2. Get state param
            const stateParam = parsedUrl.searchParams.get("state");
            if (event && event === "auth_result") {
              // properly resolve the data
              resolve(_objectSpread(_objectSpread({
                accessToken: ""
              }, rest), {}, {
                idToken: base64url.encode(JSON.stringify(result)) || "",
                state: base64url.decode(stateParam)
              }));
            }
          } catch (error) {
            log.error(error);
            reject(error);
          }
        };
        const postMessageEventHandler = async postMessageEvent => {
          if (!postMessageEvent.data) {
            throw new Error("Invalid data received");
          }
          if (this.finalURL.origin !== postMessageEvent.origin) {
            throw new Error("Invalid origin received");
          }
          // make sure event is auth_result from telegram
          const ev = postMessageEvent.data;
          if (typeof ev != "string") {
            throw new Error("Invalid data type received");
          }
          const {
            event
          } = JSON.parse(ev) || {};
          if (event && event !== "auth_result") {
            log.info("Invalid event received");
          }
          window.removeEventListener("message", postMessageEventHandler);
          handleData(ev);
          authConnectionWindow.close();
        };
        window.addEventListener("message", postMessageEventHandler);
        try {
          authConnectionWindow.open();
        } catch (error) {
          log.error(error);
          reject(error);
          return;
        }
        authConnectionWindow.once("close", () => {
          reject(new Error("user closed popup"));
        });
      });
    }
    return null;
  }
}

export { TelegramHandler as default };
