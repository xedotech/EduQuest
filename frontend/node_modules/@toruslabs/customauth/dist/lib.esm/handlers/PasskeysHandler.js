import base64url from 'base64url';
import deepmerge from 'deepmerge';
import { fetchDataFromBroadcastServer } from '../utils/sessionHelper.js';
import AbstractLoginHandler from './AbstractLoginHandler.js';

class PasskeysHandler extends AbstractLoginHandler {
  constructor(params) {
    super(params);
    this.setFinalUrl();
  }
  setFinalUrl() {
    const {
      passkeysHostUrl
    } = this.params.customState || {};
    if (!passkeysHostUrl) throw new Error("Invalid passkeys url.");
    const finalUrl = new URL(passkeysHostUrl);
    const clonedParams = JSON.parse(JSON.stringify(this.params.jwtParams || {}));
    const finalJwtParams = deepmerge({
      state: this.state,
      client_id: this.params.clientId,
      redirect_uri: this.params.redirect_uri
    }, clonedParams);
    Object.keys(finalJwtParams).forEach(key => {
      const localKey = key;
      if (finalJwtParams[localKey]) finalUrl.searchParams.append(localKey, finalJwtParams[localKey]);
    });
    this.finalURL = finalUrl;
  }
  async getUserInfo(parameters, storageServerUrl) {
    const {
      idToken,
      extraParams
    } = parameters;
    const {
      sessionId
    } = JSON.parse(base64url.decode(extraParams)) || {};
    if (!sessionId) {
      throw new Error("sessionId not found");
    }
    const {
      verifier_id: verifierId,
      signature,
      clientDataJSON,
      authenticatorData,
      publicKey,
      challenge,
      rpOrigin,
      rpId,
      credId,
      transports,
      username
    } = await fetchDataFromBroadcastServer(sessionId, storageServerUrl);
    if (signature !== idToken) {
      throw new Error("idtoken should be equal to signature");
    }
    return {
      email: "",
      name: "Passkeys Login",
      profileImage: "",
      authConnectionId: this.params.authConnectionId,
      userId: verifierId,
      authConnection: this.params.authConnection,
      groupedAuthConnectionId: this.params.groupedAuthConnectionId,
      extraConnectionParams: {
        signature,
        clientDataJSON,
        authenticatorData,
        publicKey,
        challenge,
        rpOrigin,
        rpId,
        credId,
        transports,
        username
      }
    };
  }
}

export { PasskeysHandler as default };
