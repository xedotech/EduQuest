import _objectSpread from '@babel/runtime/helpers/objectSpread2';
import _defineProperty from '@babel/runtime/helpers/defineProperty';
import { post } from '@toruslabs/http-helpers';
import bowser from 'bowser';
import log from 'loglevel';
import { BaseController } from '../BaseController.js';
import { LOGIN_PROVIDER } from '../interfaces.js';
import { cloneDeep } from '../utils/lodashUtils.js';
import { WSApiClient } from '../WSApiClient.js';
import { ACCOUNT_CATEGORY } from './IPreferencesController.js';
import { getCustomDeviceInfo, getHeaders } from '../utils/utils.js';

// By default, poll every 3 minutes
const DEFAULT_INTERVAL = 180 * 1000;
const DEFAULT_PREFERENCES = {
  selectedCurrency: "USD",
  theme: "dark",
  locale: "en",
  accountType: ACCOUNT_CATEGORY.NORMAL,
  contacts: [],
  jwtToken: "",
  fetchedPastTx: [],
  pastTransactions: [],
  paymentTx: [],
  defaultPublicAddress: "",
  customTokens: [],
  customNfts: [],
  crashReport: true,
  userInfo: {
    aggregateVerifier: "",
    email: "",
    name: "",
    profileImage: "",
    typeOfLogin: LOGIN_PROVIDER.GOOGLE,
    verifier: "",
    verifierId: ""
  }
};

/**
 * Controller that stores shared settings and exposes convenience methods
 */
class BasePreferencesController extends BaseController {
  /**
   * Creates a PreferencesController instance
   *
   * @param config - Initial options used to configure this controller
   * @param state - Initial state to set on this controller
   */
  constructor({
    config,
    state,
    defaultPreferences,
    signAuthMessage,
    validateSignMessage
  }) {
    super({
      config,
      state
    });
    /**
     * Name of this controller used during composition
     */
    _defineProperty(this, "name", "PreferencesController");
    _defineProperty(this, "iframeOrigin", void 0);
    _defineProperty(this, "wsApiClient", void 0);
    _defineProperty(this, "chainNamespace", void 0);
    _defineProperty(this, "signAuthMessage", void 0);
    _defineProperty(this, "validateSignMessage", void 0);
    _defineProperty(this, "defaultPreferences", void 0);
    if (!config.api) {
      throw new Error("PreferencesController - no api specified in config.");
    }
    this.defaultState = {
      identities: {},
      selectedAddress: "",
      lastErrorMessage: "",
      lastSuccessMessage: ""
    };
    this.defaultConfig = {
      api: config.api,
      pollInterval: DEFAULT_INTERVAL
    };
    this.initialize();
    this.defaultPreferences = _objectSpread(_objectSpread({}, DEFAULT_PREFERENCES), defaultPreferences);
    this.signAuthMessage = signAuthMessage;
    this.validateSignMessage = validateSignMessage;
    this.wsApiClient = WSApiClient(this.config.api, this);
  }
  setIframeOrigin(origin) {
    this.iframeOrigin = origin;
  }
  getAddressState(address) {
    const selectedAddress = address || this.state.selectedAddress;
    return this.state.identities[selectedAddress];
  }

  /**
   * Sets selected address
   *
   * @param selectedAddress - casper account hash
   */
  setSelectedAddress(selectedAddress) {
    this.update({
      selectedAddress
    });
  }
  async getUser(address) {
    const user = await this.wsApiClient.authGet("user?fetchTx=false", this.authCredentials(address), {
      useAPIKey: true
    });
    return user.data;
  }
  async createUser(params) {
    const {
      selectedCurrency,
      theme,
      verifier,
      verifierId,
      locale,
      address,
      idToken,
      type,
      web3AuthNetwork,
      metadata
    } = params;
    const userPayload = _objectSpread({
      default_currency: selectedCurrency,
      theme,
      verifier,
      verifier_id: verifierId,
      locale,
      idToken,
      account_type: type,
      web3auth_network: web3AuthNetwork
    }, metadata);
    await this.wsApiClient.authPost("user", userPayload, this.authCredentials(address), {
      useAPIKey: true
    });
    this.updateState({
      theme,
      defaultPublicAddress: address,
      selectedCurrency,
      locale,
      accountType: type
    }, address);
  }
  async storeUserLogin(params) {
    const {
      verifierId,
      verifier,
      options,
      address,
      idToken,
      web3AuthClientId,
      web3AuthNetwork,
      sessionPubKey,
      loginMode
    } = params;
    if (!options.rehydrate) {
      const browser = bowser.getParser(window.navigator.userAgent);
      const specialBrowser = getCustomDeviceInfo();
      const recordLoginPayload = {
        os: browser.getOSName(),
        os_version: browser.getOSVersion() || "unidentified",
        browser: (specialBrowser === null || specialBrowser === void 0 ? void 0 : specialBrowser.browser) || browser.getBrowserName() || "unidentified",
        browser_version: browser.getBrowserVersion() || "unidentified",
        platform: browser.getPlatform().type || "desktop",
        hostname: this.iframeOrigin,
        verifier,
        verifier_id: verifierId,
        idToken,
        web3auth_client_id: web3AuthClientId,
        web3auth_network: web3AuthNetwork,
        session_pub_key: sessionPubKey,
        login_mode: loginMode
      };
      await this.wsApiClient.authPost("user/recordLogin", recordLoginPayload, this.authCredentials(address), {
        useAPIKey: true
      });
    }
  }
  async setCrashReport(isEnabled) {
    var _this$getAddressState;
    if (isEnabled === ((_this$getAddressState = this.getAddressState()) === null || _this$getAddressState === void 0 ? void 0 : _this$getAddressState.crashReport)) return true;
    try {
      await this.wsApiClient.authPatch("user", {
        enable_crash_reporter: isEnabled
      }, this.authCredentials(), {
        useAPIKey: true
      });
      this.updateState({
        crashReport: isEnabled
      });
      return true;
    } catch (error) {
      log.error(error);
      return false;
    }
  }
  async setUserTheme(theme) {
    var _this$getAddressState2;
    if (theme === ((_this$getAddressState2 = this.getAddressState()) === null || _this$getAddressState2 === void 0 ? void 0 : _this$getAddressState2.theme)) return true;
    try {
      await this.wsApiClient.authPatch("user", {
        theme
      }, this.authCredentials(), {
        useAPIKey: true
      });
      this.updateState({
        theme
      });
      return true;
    } catch (error) {
      log.error(error);
      return false;
    }
  }
  async setUserLocale(locale) {
    var _this$getAddressState3;
    if (locale === ((_this$getAddressState3 = this.getAddressState()) === null || _this$getAddressState3 === void 0 ? void 0 : _this$getAddressState3.locale)) return;
    try {
      await this.wsApiClient.authPatch("user", {
        locale
      }, this.authCredentials(), {
        useAPIKey: true
      });
      this.updateState({
        locale
      });
      return true;
    } catch (error) {
      log.error("unable to set locale", error);
      return false;
    }
  }
  async setSelectedCurrency(payload) {
    var _this$getAddressState4;
    if (payload.selectedCurrency === ((_this$getAddressState4 = this.getAddressState()) === null || _this$getAddressState4 === void 0 ? void 0 : _this$getAddressState4.selectedCurrency)) return true;
    try {
      await this.wsApiClient.authPatch("user", {
        default_currency: payload.selectedCurrency
      }, this.authCredentials(), {
        useAPIKey: true
      });
      this.updateState({
        selectedCurrency: payload.selectedCurrency
      });
      return true;
    } catch (error) {
      log.error(error);
      return false;
    }
  }
  async addContact(contact) {
    try {
      var _this$getAddressState5;
      const response = await this.wsApiClient.authPost("contact", contact, this.authCredentials(), {
        useAPIKey: true
      });
      this.updateState({
        contacts: [...(((_this$getAddressState5 = this.getAddressState()) === null || _this$getAddressState5 === void 0 ? void 0 : _this$getAddressState5.contacts) || []), response.data]
      });
      return true;
    } catch (error) {
      log.error("unable to add contact", error);
      return false;
    }
  }
  async deleteContact(contactId) {
    try {
      var _this$getAddressState6;
      const response = await this.wsApiClient.authRemove(`contact/${contactId}`, {}, this.authCredentials(), {
        useAPIKey: true
      });
      const finalContacts = (_this$getAddressState6 = this.getAddressState()) === null || _this$getAddressState6 === void 0 ? void 0 : _this$getAddressState6.contacts.filter(contact => contact.id !== response.data.id);
      if (finalContacts) this.updateState({
        contacts: [...finalContacts]
      });
      return true;
    } catch (error) {
      log.error("unable to delete contact", error);
      return false;
    }
  }
  async revokeDiscord(idToken) {
    try {
      const resp = await this.wsApiClient.authPost("revoke/discord", {
        token: idToken
      }, this.authCredentials(), {
        useAPIKey: true
      });
      log.info(resp);
    } catch (error) {
      log.error(error);
    }
  }
  async patchPastTx(body, address) {
    try {
      const response = await this.wsApiClient.authPatch("transaction", body, this.authCredentials(address), {
        useAPIKey: true
      });
      log.info("successfully patched", response);
    } catch (error) {
      log.error("unable to patch tx", error);
    }
  }
  async postPastTx(tx, address) {
    try {
      const response = await this.wsApiClient.authPost("transaction", tx, this.authCredentials(address), {
        useAPIKey: true
      });
      log.info("successfully posted tx", response);
      return response;
    } catch (error) {
      log.error(error, "unable to insert transaction");
    }
  }
  async getWalletOrders(address) {
    try {
      const response = await this.wsApiClient.authGet("transaction", this.authCredentials(address), {
        useAPIKey: true
      });
      return response.success ? response.data ? response.data : [] : [];
    } catch (error) {
      log.error("unable to get wallet orders tx", error);
      return [];
    }
  }
  async getTopUpOrders(address) {
    try {
      const response = await this.wsApiClient.authGet("transaction", this.authCredentials(address), {
        useAPIKey: true
      });
      return response.data || [];
    } catch (error) {
      log.error("unable to fetch past Top up orders", error);
    }
  }
  async getBillBoardData() {
    try {
      const response = await this.wsApiClient.authGet("billboard", this.authCredentials(), {
        useAPIKey: true
      });
      return response.success ? response.data : [];
    } catch (error) {
      log.error("unable to get billboard data", error);
      return [];
    }
  }
  async getMessageForSigning(publicAddress, web3AuthIdToken) {
    const response = await post(`${this.config.api}/auth/message`, {
      public_address: publicAddress,
      id_token: web3AuthIdToken,
      chain_namespace: this.chainNamespace
    }, {}, {
      useAPIKey: true
    });
    return response.message;
  }
  async getTwitterId(payload) {
    const res = await this.wsApiClient.authGet(`twitter?screen_name=${payload.nick}`, this.authCredentials(), {
      useAPIKey: true
    });
    return `${payload.typeOfLogin.toLowerCase()}|${res.data.toString()}`;
  }
  async sendEmail(payload) {
    return this.wsApiClient.authPost("transaction/sendemail", payload.emailObject, this.authCredentials(), {
      useAPIKey: true
    });
  }
  async refreshJwt() {
    const address = this.state.selectedAddress;
    const messageToSign = await this.getMessageForSigning(address);
    await this.validateSignMessage(messageToSign);
    const signedMessage = await this.signAuthMessage(address, messageToSign);
    const response = await post(`${this.config.api}/auth/verify`, {
      challenge: messageToSign,
      public_address: address,
      signed_message: signedMessage,
      chain_namespace: this.chainNamespace
    }, {}, {
      useAPIKey: true
    });
    this.updateState({
      jwtToken: response.token
    }, address);
  }
  async getDappList() {
    try {
      const response = await this.wsApiClient.authGet("dapps", this.authCredentials(), {
        useAPIKey: true
      });
      return response.success ? response.data : [];
    } catch (error) {
      log.error("unable to get dapps list", error);
      return [];
    }
  }

  /**
   * Strategy
   * For account type: threshold, normal (web3auth login)
   * idToken from web3auth login must be present. We use it directly
   *
   * For account type: app_scoped, IMPORTED
   * idToken from web3auth login must be present. We request a message for signing using the idToken
   * and sign it using the private key of the account. We then send the signed message to the backend
   * to verify the signature and return a new jwtToken that includes the app_scoped address
   *
   * For account type: Account abstraction
   * idToken from web3auth login must be present. We use it to exchange for a new jwtToken.
   * Because backend can derive AA address from public address and issue this token easily.
   *
   * For account type: external
   * idToken from web3auth `authenticateUser` (siww) login must be present. We use it directly
   */
  async init(params) {
    const {
      address,
      userInfo,
      idToken,
      metadata = {},
      type
    } = params;
    if (this.getAddressState(address)) return;
    let jwtToken;
    switch (type) {
      case ACCOUNT_CATEGORY.EXTERNAL:
        {
          if (!idToken) throw new Error("SIWW idToken must be present");
          const response = await post(`${this.config.api}/auth/verify`, _objectSpread({
            account_type: type,
            public_address: address,
            id_token: idToken,
            verifier: userInfo.aggregateVerifier || userInfo.verifier,
            verifier_id: userInfo.verifierId,
            chain_namespace: this.chainNamespace
          }, metadata), {}, {
            useAPIKey: true
          });
          jwtToken = response.token;
          break;
        }
      case ACCOUNT_CATEGORY.IMPORTED:
      case ACCOUNT_CATEGORY.APP_SCOPED_DERIVED:
      case ACCOUNT_CATEGORY.ACCOUNT_ABSTRACTION:
        {
          if (!idToken) throw new Error("Web3Auth idToken must be present");
          const response = await post(`${this.config.api}/auth/verify`, _objectSpread({
            public_address: address,
            id_token: idToken,
            verifier: userInfo.aggregateVerifier || userInfo.verifier,
            verifier_id: userInfo.verifierId,
            account_type: type,
            chain_namespace: this.chainNamespace
          }, metadata), {}, {
            useAPIKey: true
          });
          jwtToken = response.token;
          break;
        }
      case ACCOUNT_CATEGORY.MPC:
      case ACCOUNT_CATEGORY.SFA:
        {
          if (!metadata.signatures) throw new Error("MPC signatures must be present");
          const response = await post(`${this.config.api}/auth/verify`, _objectSpread({
            public_address: address,
            verifier: userInfo.aggregateVerifier || userInfo.verifier,
            verifier_id: userInfo.verifierId,
            account_type: type,
            chain_namespace: this.chainNamespace
          }, metadata), {}, {
            useAPIKey: true
          });
          jwtToken = response.token;
          break;
        }
      case ACCOUNT_CATEGORY.NORMAL:
      case ACCOUNT_CATEGORY.THRESHOLD:
      case ACCOUNT_CATEGORY.APP_SCOPED:
      default:
        if (!idToken) throw new Error("Web3Auth idToken must be present");
        jwtToken = idToken;
        break;
    }
    this.updateState({
      jwtToken,
      userInfo,
      accountType: type !== null && type !== void 0 ? type : this.defaultPreferences.accountType
    }, address);
  }
  updateState(preferences, address) {
    const selectedAddress = address || this.state.selectedAddress;
    const currentState = this.getAddressState(selectedAddress) || cloneDeep(this.defaultPreferences);
    const mergedState = _objectSpread(_objectSpread({}, currentState), preferences);
    this.update({
      identities: _objectSpread(_objectSpread({}, this.state.identities), {}, {
        [selectedAddress]: mergedState
      })
    });
    return mergedState;
  }
  authCredentials(address) {
    var _this$getAddressState7;
    const selectedAddress = address || this.state.selectedAddress;
    const jwtToken = ((_this$getAddressState7 = this.getAddressState(selectedAddress)) === null || _this$getAddressState7 === void 0 ? void 0 : _this$getAddressState7.jwtToken) || "";
    return {
      jwtToken,
      publicAddress: selectedAddress,
      chainNamespace: this.chainNamespace
    };
  }
  headers(address) {
    var _this$getAddressState8;
    const selectedAddress = address || this.state.selectedAddress;
    return getHeaders(((_this$getAddressState8 = this.getAddressState(selectedAddress)) === null || _this$getAddressState8 === void 0 ? void 0 : _this$getAddressState8.jwtToken) || "", selectedAddress);
  }
}

export { BasePreferencesController, DEFAULT_PREFERENCES };
