import _objectSpread from '@babel/runtime/helpers/objectSpread2';
import { get, post, put, patch, remove } from '@toruslabs/http-helpers';
import { jwtDecode } from 'jwt-decode';
import { ControllerEvents } from './enums.js';
import { isUnauthorizedError } from './utils/utils.js';

var HTTP_METHOD = /*#__PURE__*/function (HTTP_METHOD) {
  HTTP_METHOD[HTTP_METHOD["GET"] = 0] = "GET";
  HTTP_METHOD[HTTP_METHOD["POST"] = 1] = "POST";
  HTTP_METHOD[HTTP_METHOD["PUT"] = 2] = "PUT";
  HTTP_METHOD[HTTP_METHOD["PATCH"] = 3] = "PATCH";
  HTTP_METHOD[HTTP_METHOD["DELETE"] = 4] = "DELETE";
  return HTTP_METHOD;
}(HTTP_METHOD || {});
const constructAuthHeaders = ({
  jwtToken,
  publicAddress,
  eoaAddress,
  chainNamespace
}) => {
  const headers = {
    Authorization: `Bearer ${jwtToken}`,
    "public-address": publicAddress,
    "chain-namespace": chainNamespace
  };
  if (eoaAddress) {
    headers["eoa-address"] = eoaAddress;
  }
  return {
    headers
  };
};
const withUnauthorizedHandler = async (fn, emitter) => {
  try {
    const response = await fn();
    return response;
  } catch (e) {
    if (isUnauthorizedError(e)) {
      emitter.emit(ControllerEvents.UserUnauthorized);
    }
    throw e;
  }
};
const jwtTokenExpired = jwt => {
  const decoded = jwtDecode(jwt);
  const jwtExpiry = decoded.exp * 1000;
  const currentTime = new Date().getTime();
  return currentTime >= jwtExpiry;
};
const WSApiClient = (baseApiUrl, emitter) => {
  const authRequest = (method, url, data, authCredentials, customOptions) => {
    if (jwtTokenExpired(authCredentials.jwtToken)) {
      emitter.emit(ControllerEvents.UserUnauthorized);
      // eslint-disable-next-line @typescript-eslint/no-throw-literal
      throw new Response(null, {
        status: 401,
        statusText: "Unauthorized"
      });
    }
    const headers = _objectSpread({
      "Content-Type": "application/json; charset=utf-8"
    }, constructAuthHeaders(authCredentials));
    if (method === HTTP_METHOD.GET) {
      return withUnauthorizedHandler(() => get(url, headers, customOptions), emitter);
    }
    if (method === HTTP_METHOD.POST) {
      return withUnauthorizedHandler(() => post(url, data, headers, customOptions), emitter);
    }
    if (method === HTTP_METHOD.PUT) {
      return withUnauthorizedHandler(() => put(url, data, headers, customOptions), emitter);
    }
    if (method === HTTP_METHOD.PATCH) {
      return withUnauthorizedHandler(() => patch(url, data, headers, customOptions), emitter);
    }
    if (method === HTTP_METHOD.DELETE) {
      return withUnauthorizedHandler(() => remove(url, data, headers, customOptions), emitter);
    }
  };
  return {
    authGet: (url, authCredentials, customOptions) => authRequest(HTTP_METHOD.GET, `${baseApiUrl}/${url}`, {}, authCredentials, customOptions),
    authPost: (url, data, authCredentials, customOptions) => authRequest(HTTP_METHOD.POST, `${baseApiUrl}/${url}`, data, authCredentials, customOptions),
    authPut: (url, data, authCredentials, customOptions) => authRequest(HTTP_METHOD.PUT, `${baseApiUrl}/${url}`, data, authCredentials, customOptions),
    authPatch: (url, data, authCredentials, customOptions) => authRequest(HTTP_METHOD.PATCH, `${baseApiUrl}/${url}`, data, authCredentials, customOptions),
    authRemove: (url, data, authCredentials, customOptions) => authRequest(HTTP_METHOD.DELETE, `${baseApiUrl}/${url}`, data, authCredentials, customOptions)
  };
};

export { WSApiClient, constructAuthHeaders };
