import { fromSigned, bytesToBigInt, toUnsigned, stripHexPrefix, bigIntToHex, addHexPrefix, hashPersonalMessage, ecsign, bigIntToBytes } from '@ethereumjs/util';
import { safeatob } from '@web3auth/auth';
import BigNumber from 'bignumber.js';

/**
 * General utility functions
 */

function intToHex(i) {
  const hex = i.toString(16);
  return `0x${hex}`;
}

/**
 * Returns a random number. Don't use for cryptographic purposes.
 * @returns a random number
 */
const randomId = () => Math.random().toString(36).slice(2);

/**
 * Pads the front of the given hex string with zeroes until it reaches the
 * target length. If the input string is already longer than or equal to the
 * target length, it is returned unmodified.
 *
 * If the input string is "0x"-prefixed or not a hex string, an error will be
 * thrown.
 *
 * @param hexString - The hexadecimal string to pad with zeroes.
 * @param targetLength - The target length of the hexadecimal string.
 * @returns The input string front-padded with zeroes, or the original string
 * if it was already greater than or equal to to the target length.
 */
function padWithZeroes(hexString, targetLength) {
  if (hexString !== "" && !/^[a-f0-9]+$/iu.test(hexString)) {
    throw new Error(`Expected an unprefixed hex string. Received: ${hexString}`);
  }
  if (targetLength < 0) {
    throw new Error(`Expected a non-negative integer target length. Received: ${targetLength}`);
  }
  return String.prototype.padStart.call(hexString, targetLength, "0");
}
/**
 * Concatenate an extended ECDSA signature into a hex string.
 *
 * @param v - The 'v' portion of the signature.
 * @param r - The 'r' portion of the signature.
 * @param s - The 's' portion of the signature.
 * @returns The concatenated ECDSA signature.
 */
function concatSig(v, r, s) {
  const rSig = fromSigned(r);
  const sSig = fromSigned(s);
  const vSig = bytesToBigInt(v);
  const rStr = padWithZeroes(Buffer.from(toUnsigned(rSig)).toString("hex"), 64);
  const sStr = padWithZeroes(Buffer.from(toUnsigned(sSig)).toString("hex"), 64);
  const vStr = stripHexPrefix(bigIntToHex(vSig));
  return addHexPrefix(rStr.concat(sStr, vStr));
}
function timeout(duration) {
  return new Promise(resolve => {
    const timeoutRef = window.setTimeout(() => {
      resolve();
      window.clearTimeout(timeoutRef);
    }, duration);
  });
}
const getHeaders = (jwt, publicAddress) => {
  return {
    headers: {
      Authorization: `Bearer ${jwt}`,
      "Content-Type": "application/json; charset=utf-8",
      "public-address": publicAddress
    }
  };
};

/**
 * Text/number formatting utilities
 */
const formatSmallNumbers = (number, currency = "usd", noTilde = false) => {
  const finalNumber = BigNumber.isBigNumber(number) ? number.toNumber() : number;
  if (!Number.isFinite(finalNumber)) return "";
  const value = currency.toLowerCase() === "usd" ? parseFloat(Number(finalNumber).toFixed(2)) : parseFloat(Number(finalNumber).toFixed(5));
  const tilde = value > 0 ? "~ " : "";
  return `${currency.toLowerCase() === "usd" || noTilde ? "" : tilde}${Number(value)} ${currency.toUpperCase()}`;
};
const addressSlicer = (address, sliceLength = 5) => {
  if (!address) return "";
  if (address.length < 11) {
    return address;
  }
  if (typeof address !== "string") return "";
  return `${address.slice(0, sliceLength)}...${address.slice(-sliceLength)}`;
};
const significantDigits = (number, perc = false, length_ = 2) => {
  let input = !BigNumber.isBigNumber(number) ? new BigNumber(number) : number;
  if (input.isZero()) return input;
  if (perc) {
    input = input.times(new BigNumber(100));
  }
  let depth;
  if (input.gte(new BigNumber(1))) {
    depth = length_;
  } else {
    depth = length_ - 1 + Math.ceil(Math.log10(new BigNumber("1").div(input).toNumber()));
  }
  const shift = new BigNumber(10).pow(new BigNumber(depth));
  const roundedNumber = Math.round(shift.times(input).toNumber()) / shift.toNumber();
  return roundedNumber;
};
const formatDate = inputDate => {
  const monthList = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  const date = new Date(inputDate);
  const day = date.getDate();
  const month = monthList[date.getMonth()];
  const year = date.getFullYear();
  return `${day} ${month} ${year}`;
};
const formatTime = time => {
  return new Date(time).toTimeString().slice(0, 8);
};

/**
 * Network utilities
 */
const transactionMatchesNetwork = (transaction, chainId) => {
  if (typeof transaction.chainId !== "undefined") {
    return transaction.chainId === chainId;
  }
  return false;
};

/**
 * Signing utils
 */
const hashMessage = message => {
  const bufferedMessage = Buffer.from(message, "utf8");
  const el = hashPersonalMessage(bufferedMessage);
  return Buffer.from(el);
};
const signMessage = async (privateKey, data) => {
  const privKey = Buffer.from(privateKey, "hex");
  const message = stripHexPrefix(data);
  const msgSig = ecsign(Buffer.from(message, "hex"), privKey);
  const rawMsgSig = concatSig(Buffer.from(bigIntToBytes(msgSig.v)), Buffer.from(msgSig.r), Buffer.from(msgSig.s));
  return rawMsgSig;
};

/**
 * popup handler utils
 */
function getPopupFeatures({
  width: w,
  height: h
}) {
  // Fixes dual-screen position                             Most browsers      Firefox
  const dualScreenLeft = window.screenLeft !== undefined ? window.screenLeft : window.screenX;
  const dualScreenTop = window.screenTop !== undefined ? window.screenTop : window.screenY;
  const width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : window.screen.width;
  const height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : window.screen.height;
  const systemZoom = 1; // No reliable estimate

  const left = Math.abs((width - w) / 2 / systemZoom + dualScreenLeft);
  const top = Math.abs((height - h) / 2 / systemZoom + dualScreenTop);
  const features = `titlebar=0,toolbar=0,status=0,location=0,menubar=0,height=${h / systemZoom},width=${w / systemZoom},top=${top},left=${left}`;
  return features;
}
const broadcastChannelOptions = {
  type: "server",
  // type: 'localstorage', // (optional) enforce a type, oneOf['native', 'idb', 'localstorage', 'node']
  webWorkerSupport: false // (optional) set this to false if you know that your channel will never be used in a WebWorker (increases performance)
};
function getCustomDeviceInfo() {
  var _navigator;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  if ((_navigator = navigator) !== null && _navigator !== void 0 && _navigator.brave) {
    return {
      browser: "Brave"
    };
  }
}
class UserError extends Error {}
const handleRedirectParameters = (hash, queryParameters) => {
  const hashParameters = {};
  const hashUrl = new URL(`${window.location.origin}/?${hash.slice(1)}`);
  hashUrl.searchParams.forEach((value, key) => {
    hashParameters[key] = value;
  });
  let instanceParameters = {};
  let error = "";
  if (!queryParameters.windowId) {
    if (Object.keys(hashParameters).length > 0 && hashParameters.state) {
      instanceParameters = JSON.parse(safeatob(decodeURIComponent(decodeURIComponent(hashParameters.state)))) || {};
      error = hashParameters.error_description || hashParameters.error || error;
    } else if (Object.keys(queryParameters).length > 0 && queryParameters.state) {
      instanceParameters = JSON.parse(safeatob(decodeURIComponent(decodeURIComponent(queryParameters.state)))) || {};
      if (queryParameters.error) error = queryParameters.error;
    }
  }
  return {
    error,
    instanceParameters,
    hashParameters
  };
};
function sleep(ms) {
  return new Promise(resolve => {
    setTimeout(resolve, ms);
  });
}
const isUnauthorizedError = error => {
  return error instanceof Response && error.status === 401;
};

export { UserError, addressSlicer, broadcastChannelOptions, concatSig, formatDate, formatSmallNumbers, formatTime, getCustomDeviceInfo, getHeaders, getPopupFeatures, handleRedirectParameters, hashMessage, intToHex, isUnauthorizedError, padWithZeroes, randomId, signMessage, significantDigits, sleep, timeout, transactionMatchesNetwork };
