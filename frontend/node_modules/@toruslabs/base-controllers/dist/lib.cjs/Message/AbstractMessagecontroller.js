'use strict';

var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var auth = require('@web3auth/auth');
var BaseController = require('../BaseController.js');
var constants = require('./constants.js');

class AbstractMessageController extends BaseController.BaseController {
  /**
   * Controller in charge of managing - storing, adding, removing, updating - Messages.
   *
   */
  constructor({
    config,
    state
  }) {
    super({
      config,
      state
    });
    _defineProperty(this, "messages", void 0);
    this.defaultState = {
      unapprovedMessages: {},
      unapprovedMessagesCount: 0
    };
    this.messages = [];
    this.defaultConfig = {};
    super.initialize();
  }
  getMessage(messageId) {
    return this.messages.find(message => message.id === messageId);
  }
  getAllMessages() {
    return this.messages;
  }
  setMetadata(messageId, metadata) {
    const message = this.getMessage(messageId);
    if (!message) {
      throw new Error(`${this.name}: Message not found for id: ${messageId}.`);
    }
    message.metadata = metadata;
    this.updateMessage(message);
  }
  getUnapprovedMessages() {
    return this.messages.filter(message => message.status === constants.MessageStatus.UNAPPROVED).reduce((result, message) => {
      result[message.id] = message;
      return result;
    }, {});
  }
  async addMessage(message) {
    this.messages.push(message);
    this.saveMessageList();
  }
  approveMessage(messageId, messageParams) {
    this.setMessageStatus(messageId, constants.MessageStatus.APPROVED);
    return this.prepMessageForSigning(messageParams);
  }
  setMessageStatus(messageId, status) {
    const message = this.getMessage(messageId);
    if (!message) {
      throw new Error(`${this.name}: Message not found for id: ${messageId}.`);
    }
    message.status = status;
    this.updateMessage(message);
    this.emit(`${messageId}:${status}`, message);
    if (status === constants.MessageStatus.REJECTED || status === constants.MessageStatus.SIGNED || status === constants.MessageStatus.FAILED) {
      this.emit(`${messageId}:finished`, message);
    }
  }
  async waitForFinishStatus(msgParams, messageName) {
    return new Promise((resolve, reject) => {
      const handleFinished = msg => {
        if (msg.status === constants.MessageStatus.REJECTED) {
          return reject(auth.providerErrors.userRejectedRequest(`${messageName} Signature: User denied message signature`));
        }
        if (msg.status === constants.MessageStatus.FAILED) {
          return reject(auth.rpcErrors.internal(`${messageName} Signature: failed to sign message ${msg.error}`));
        }
        if (msg.status === constants.MessageStatus.SIGNED) {
          return resolve(msg.rawSig);
        }
        return reject(auth.rpcErrors.internal(`${messageName} Signature: Unknown problem: ${JSON.stringify(msgParams)}`));
      };
      this.once(`${msgParams.id}:finished`, handleFinished);
    });
  }
  updateMessage(message) {
    const index = this.messages.findIndex(msg => message.id === msg.id);
    if (index !== -1) {
      this.messages[index] = message;
    }
    this.saveMessageList();
  }
  saveMessageList() {
    const unapprovedMessages = this.getUnapprovedMessages();
    const unapprovedMessagesCount = Object.keys(unapprovedMessages).length;
    this.update({
      unapprovedMessages,
      unapprovedMessagesCount
    });
  }
}

exports.AbstractMessageController = AbstractMessageController;
