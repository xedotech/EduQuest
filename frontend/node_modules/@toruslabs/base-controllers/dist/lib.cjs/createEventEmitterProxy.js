'use strict';

const filterNoop = () => true;
const internalEvents = ["newListener", "removeListener"];
const externalEventFilter = name => !internalEvents.includes(name);
function getRawListeners(eventEmitter, name) {
  // prefer native
  return typeof eventEmitter.rawListeners !== "undefined" ? eventEmitter.rawListeners(name) : eventEmitter.listeners(name);
}
function createEventEmitterProxy(initialTarget, opts) {
  // parse options
  const finalOpts = opts || {};
  let eventFilter = finalOpts.eventFilter || filterNoop;
  if (typeof eventFilter === "string" && eventFilter === "skipInternal") eventFilter = externalEventFilter;
  if (typeof eventFilter !== "function") throw new Error("createEventEmitterProxy - Invalid eventFilter");
  let target = initialTarget;
  let setTarget = newTarget => {
    if (target === newTarget) return;
    const oldTarget = target;
    target = newTarget;
    const eventNames = oldTarget.eventNames();
    eventNames.filter(eventFilter).forEach(name => {
      getRawListeners(oldTarget, name).forEach(handler => {
        newTarget.on(name, handler);
      });
    });

    // remove old listeners
    oldTarget.removeAllListeners();
  };
  const proxy = new Proxy({}, {
    get: (_, name) => {
      // override `setTarget` access
      if (name === "setTarget") return setTarget;
      return target[name];
    },
    set: (_, name, value) => {
      // allow `setTarget` overrides
      if (name === "setTarget") {
        setTarget = value;
        return true;
      }
      target[name] = value;
      return true;
    },
    has: (_, key) => {
      if (key[0] === "_") {
        return false;
      }
      return key in target;
    }
  });
  return proxy;
}

exports.createEventEmitterProxy = createEventEmitterProxy;
