'use strict';

var _objectSpread = require('@babel/runtime/helpers/objectSpread2');
var httpHelpers = require('@toruslabs/http-helpers');
var jwtDecode = require('jwt-decode');
var enums = require('./enums.js');
var utils = require('./utils/utils.js');

var HTTP_METHOD = /*#__PURE__*/function (HTTP_METHOD) {
  HTTP_METHOD[HTTP_METHOD["GET"] = 0] = "GET";
  HTTP_METHOD[HTTP_METHOD["POST"] = 1] = "POST";
  HTTP_METHOD[HTTP_METHOD["PUT"] = 2] = "PUT";
  HTTP_METHOD[HTTP_METHOD["PATCH"] = 3] = "PATCH";
  HTTP_METHOD[HTTP_METHOD["DELETE"] = 4] = "DELETE";
  return HTTP_METHOD;
}(HTTP_METHOD || {});
const constructAuthHeaders = ({
  jwtToken,
  publicAddress,
  eoaAddress,
  chainNamespace
}) => {
  const headers = {
    Authorization: `Bearer ${jwtToken}`,
    "public-address": publicAddress,
    "chain-namespace": chainNamespace
  };
  if (eoaAddress) {
    headers["eoa-address"] = eoaAddress;
  }
  return {
    headers
  };
};
const withUnauthorizedHandler = async (fn, emitter) => {
  try {
    const response = await fn();
    return response;
  } catch (e) {
    if (utils.isUnauthorizedError(e)) {
      emitter.emit(enums.ControllerEvents.UserUnauthorized);
    }
    throw e;
  }
};
const jwtTokenExpired = jwt => {
  const decoded = jwtDecode.jwtDecode(jwt);
  const jwtExpiry = decoded.exp * 1000;
  const currentTime = new Date().getTime();
  return currentTime >= jwtExpiry;
};
const WSApiClient = (baseApiUrl, emitter) => {
  const authRequest = (method, url, data, authCredentials, customOptions) => {
    if (jwtTokenExpired(authCredentials.jwtToken)) {
      emitter.emit(enums.ControllerEvents.UserUnauthorized);
      // eslint-disable-next-line @typescript-eslint/no-throw-literal
      throw new Response(null, {
        status: 401,
        statusText: "Unauthorized"
      });
    }
    const headers = _objectSpread({
      "Content-Type": "application/json; charset=utf-8"
    }, constructAuthHeaders(authCredentials));
    if (method === HTTP_METHOD.GET) {
      return withUnauthorizedHandler(() => httpHelpers.get(url, headers, customOptions), emitter);
    }
    if (method === HTTP_METHOD.POST) {
      return withUnauthorizedHandler(() => httpHelpers.post(url, data, headers, customOptions), emitter);
    }
    if (method === HTTP_METHOD.PUT) {
      return withUnauthorizedHandler(() => httpHelpers.put(url, data, headers, customOptions), emitter);
    }
    if (method === HTTP_METHOD.PATCH) {
      return withUnauthorizedHandler(() => httpHelpers.patch(url, data, headers, customOptions), emitter);
    }
    if (method === HTTP_METHOD.DELETE) {
      return withUnauthorizedHandler(() => httpHelpers.remove(url, data, headers, customOptions), emitter);
    }
  };
  return {
    authGet: (url, authCredentials, customOptions) => authRequest(HTTP_METHOD.GET, `${baseApiUrl}/${url}`, {}, authCredentials, customOptions),
    authPost: (url, data, authCredentials, customOptions) => authRequest(HTTP_METHOD.POST, `${baseApiUrl}/${url}`, data, authCredentials, customOptions),
    authPut: (url, data, authCredentials, customOptions) => authRequest(HTTP_METHOD.PUT, `${baseApiUrl}/${url}`, data, authCredentials, customOptions),
    authPatch: (url, data, authCredentials, customOptions) => authRequest(HTTP_METHOD.PATCH, `${baseApiUrl}/${url}`, data, authCredentials, customOptions),
    authRemove: (url, data, authCredentials, customOptions) => authRequest(HTTP_METHOD.DELETE, `${baseApiUrl}/${url}`, data, authCredentials, customOptions)
  };
};

exports.WSApiClient = WSApiClient;
exports.constructAuthHeaders = constructAuthHeaders;
