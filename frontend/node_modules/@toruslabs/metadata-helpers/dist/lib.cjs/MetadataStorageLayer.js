'use strict';

var _objectSpread = require('@babel/runtime/helpers/objectSpread2');
var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var httpHelpers = require('@toruslabs/http-helpers');
var stringify = require('json-stable-stringify');
var utils = require('./utils.js');

class MetadataStorageLayer {
  // ms

  constructor(metadataHost = "https://metadata.tor.us", serverTimeOffset = 0) {
    _defineProperty(this, "metadataHost", void 0);
    _defineProperty(this, "serverTimeOffset", void 0);
    this.metadataHost = metadataHost;
    this.serverTimeOffset = serverTimeOffset;
  }
  static setAPIKey(apiKey) {
    httpHelpers.setAPIKey(apiKey);
  }
  static setEmbedHost(embedHost) {
    httpHelpers.setEmbedHost(embedHost);
  }
  generateMetadataParams(message, privateKeyHex) {
    var _sig$recoveryParam$to, _sig$recoveryParam;
    const key = utils.ec.keyFromPrivate(privateKeyHex, "hex");
    const setData = {
      data: message,
      timestamp: Math.floor(this.serverTimeOffset + Date.now() / 1000).toString(16)
    };
    const sig = key.sign(utils.keccak256(Buffer.from(stringify(setData), "utf8")));
    return {
      pub_key_X: key.getPublic().getX().toString(16, 64),
      pub_key_Y: key.getPublic().getY().toString(16, 64),
      set_data: setData,
      signature: Buffer.from(sig.r.toString(16, 64) + sig.s.toString(16, 64) + ((_sig$recoveryParam$to = (_sig$recoveryParam = sig.recoveryParam) === null || _sig$recoveryParam === void 0 ? void 0 : _sig$recoveryParam.toString(16).padStart(2, "0").slice(-2)) !== null && _sig$recoveryParam$to !== void 0 ? _sig$recoveryParam$to : "00"), "hex").toString("base64")
    };
  }
  generatePubKeyParams(privateKeyHex) {
    const key = utils.ec.keyFromPrivate(privateKeyHex, "hex");
    return {
      pub_key_X: key.getPublic().getX().toString(16, 64),
      pub_key_Y: key.getPublic().getY().toString(16, 64)
    };
  }
  async setMetadata(data, namespace, options) {
    const params = namespace !== null ? _objectSpread(_objectSpread({}, data), {}, {
      namespace
    }) : data;
    const metadataResponse = await httpHelpers.post(`${this.metadataHost}/set`, params, options, {
      useAPIKey: true
    });
    return metadataResponse.message;
  }
  async getMetadata(pubKey, namespace, options) {
    const params = namespace !== null ? _objectSpread(_objectSpread({}, pubKey), {}, {
      namespace
    }) : pubKey;
    const metadataResponse = await httpHelpers.post(`${this.metadataHost}/get`, params, options, {
      useAPIKey: true
    });
    return metadataResponse.message;
  }
}

exports.MetadataStorageLayer = MetadataStorageLayer;
