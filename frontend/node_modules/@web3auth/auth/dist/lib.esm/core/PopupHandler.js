import _defineProperty from '@babel/runtime/helpers/defineProperty';
import { SESSION_SERVER_API_URL, SESSION_SERVER_SOCKET_URL } from '@toruslabs/constants';
import { SecurePubSub } from '@toruslabs/secure-pub-sub';
import { EventEmitter } from 'events';
import { LoginError } from './errors.js';
import { getPopupFeatures } from './utils.js';

class PopupHandler extends EventEmitter {
  constructor({
    url,
    target,
    features,
    timeout = 30000,
    sessionSocketUrl,
    sessionServerUrl
  }) {
    // Disabling the rule here, as it is a false positive.
    // eslint-disable-next-line constructor-super
    super();
    _defineProperty(this, "url", void 0);
    _defineProperty(this, "target", void 0);
    _defineProperty(this, "features", void 0);
    _defineProperty(this, "window", void 0);
    _defineProperty(this, "windowTimer", void 0);
    _defineProperty(this, "iClosedWindow", void 0);
    _defineProperty(this, "timeout", void 0);
    _defineProperty(this, "sessionSocketUrl", void 0);
    _defineProperty(this, "sessionServerUrl", void 0);
    this.url = url;
    this.target = target || "_blank";
    this.features = features || getPopupFeatures();
    this.window = undefined;
    this.windowTimer = undefined;
    this.iClosedWindow = false;
    this.timeout = timeout;
    this.sessionServerUrl = sessionServerUrl || SESSION_SERVER_API_URL;
    this.sessionSocketUrl = sessionSocketUrl || SESSION_SERVER_SOCKET_URL;
    this._setupTimer();
  }
  _setupTimer() {
    this.windowTimer = Number(setInterval(() => {
      if (this.window && this.window.closed) {
        clearInterval(this.windowTimer);
        setTimeout(() => {
          if (!this.iClosedWindow) {
            this.emit("close");
          }
          this.iClosedWindow = false;
          this.window = undefined;
        }, this.timeout);
      }
      if (this.window === undefined) clearInterval(this.windowTimer);
    }, 500));
  }
  open() {
    var _this$window;
    this.window = window.open(this.url, this.target, this.features);
    if (!this.window) throw LoginError.popupBlocked();
    if ((_this$window = this.window) !== null && _this$window !== void 0 && _this$window.focus) this.window.focus();
  }
  close() {
    this.iClosedWindow = true;
    if (this.window) this.window.close();
  }
  redirect(locationReplaceOnRedirect) {
    if (locationReplaceOnRedirect) {
      window.location.replace(this.url);
    } else {
      window.location.href = this.url;
    }
  }
  async listenOnChannel(loginId) {
    const securePubSub = new SecurePubSub({
      serverUrl: this.sessionServerUrl,
      socketUrl: this.sessionSocketUrl
    });
    const data = await securePubSub.subscribe(loginId);
    this.close();
    securePubSub.cleanup();
    const parsedData = JSON.parse(data);
    if (parsedData.error) {
      return {
        error: parsedData.error,
        state: parsedData.state
      };
    }
    return parsedData.data;
  }
}

export { PopupHandler as default };
