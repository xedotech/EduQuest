'use strict';

var _objectSpread = require('@babel/runtime/helpers/objectSpread2');
var errorConstants = require('./error-constants.js');

const FALLBACK_ERROR_CODE = errorConstants.errorCodes.rpc.internal;
const FALLBACK_MESSAGE = "Unspecified error message. This is a bug, please report it.";
const JSON_RPC_SERVER_ERROR_MESSAGE = "Unspecified server error.";
/**
 * Returns whether the given code is valid.
 * A code is valid if it is an integer.
 *
 * @param code - The error code.
 * @returns Whether the given code is valid.
 */
function isValidCode(code) {
  return Number.isInteger(code);
}
function isValidString(value) {
  return typeof value === "string" && value.length > 0;
}

/**
 * A type guard for {@link RuntimeObject}.
 *
 * @param value - The value to check.
 * @returns Whether the specified value has a runtime type of `object` and is
 * neither `null` nor an `Array`.
 */
function isObject(value) {
  return Boolean(value) && typeof value === "object" && !Array.isArray(value);
}

/**
 * Check if the value is plain object.
 *
 * @param value - Value to be checked.
 * @returns True if an object is the plain JavaScript object,
 * false if the object is not plain (e.g. function).
 */
function isPlainObject(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  try {
    let proto = value;
    while (Object.getPrototypeOf(proto) !== null) {
      proto = Object.getPrototypeOf(proto);
    }
    return Object.getPrototypeOf(value) === proto;
  } catch (_) {
    return false;
  }
}

/**
 * Check if the given code is a valid JSON-RPC server error code.
 *
 * @param code - The error code.
 * @returns Whether the given code is a valid JSON-RPC server error code.
 */
function isJsonRpcServerError(code) {
  return code >= -32099 && code <= -32000;
}
function isJsonRpcError(value) {
  const castValue = value;
  if (!castValue) return false;
  if (!isValidCode(castValue.code) || !isValidString(castValue.message)) return false;
  if (castValue.stack && !isValidString(castValue.stack)) return false;
  return true;
}

/**
 * Gets the message for a given code, or a fallback message if the code has
 * no corresponding message.
 *
 * @param code - The error code.
 * @param fallbackMessage - The fallback message to use if the code has no
 * corresponding message.
 * @returns The message for the given code, or the fallback message if the code
 * has no corresponding message.
 */
function getMessageFromCode(code, fallbackMessage = FALLBACK_MESSAGE) {
  if (isValidCode(code)) {
    const codeString = code.toString();
    if (Object.hasOwn(errorConstants.errorValues, codeString)) {
      return errorConstants.errorValues[codeString].message;
    }
    if (isJsonRpcServerError(code)) {
      return JSON_RPC_SERVER_ERROR_MESSAGE;
    }
  }
  return fallbackMessage;
}
const FALLBACK_ERROR = {
  code: FALLBACK_ERROR_CODE,
  message: getMessageFromCode(FALLBACK_ERROR_CODE)
};
function isValidJson(str) {
  try {
    JSON.parse(JSON.stringify(str, (strKey, strVal) => {
      if (strKey === "__proto__" || strKey === "constructor") {
        throw new Error("Not valid json");
      }
      if (typeof strVal === "function" || typeof strVal === "symbol") {
        throw new Error("Not valid json");
      }
      return strVal;
    }), (propKey, propValue) => {
      // Strip __proto__ and constructor properties to prevent prototype pollution.
      if (propKey === "__proto__" || propKey === "constructor") {
        return undefined;
      }
      return propValue;
    });
    // this means, it's a valid json so far
  } catch (e) {
    return false;
  }
  return true;
}

/**
 * Extracts all JSON-serializable properties from an object.
 *
 * @param object - The object in question.
 * @returns An object containing all the JSON-serializable properties.
 */
function serializeObject(object) {
  return Object.getOwnPropertyNames(object).reduce((acc, key) => {
    const value = object[key];
    if (isValidJson(value)) {
      acc[key] = value;
    }
    return acc;
  }, {});
}

/**
 * Serializes an unknown error to be used as the `cause` in a fallback error.
 *
 * @param error - The unknown error.
 * @returns A JSON-serializable object containing as much information about the original error as possible.
 */
function serializeCause(error) {
  if (Array.isArray(error)) {
    return error.map(entry => {
      if (isValidJson(entry)) {
        return entry;
      } else if (isObject(entry)) {
        return serializeObject(entry);
      }
      return null;
    });
  } else if (isObject(error)) {
    return serializeObject(error);
  }
  if (isValidJson(error)) {
    return error;
  }
  return null;
}

/**
 * Construct a JSON-serializable object given an error and a JSON serializable `fallbackError`
 *
 * @param error - The error in question.
 * @param fallbackError - A JSON serializable fallback error.
 * @returns A JSON serializable error object.
 */
function buildError(error, fallbackError) {
  // If an error specifies a `serialize` function, we call it and return the result.
  if (error && typeof error === "object" && "serialize" in error && typeof error.serialize === "function") {
    return error.serialize();
  }
  if (isJsonRpcError(error)) {
    return error;
  }

  // If the error does not match the JsonRpcError type, use the fallback error, but try to include the original error as `cause`.
  const cause = serializeCause(error);
  const fallbackWithCause = _objectSpread(_objectSpread({}, fallbackError), {}, {
    data: {
      cause
    }
  });
  return fallbackWithCause;
}

/**
 * Serializes the given error to an Ethereum JSON RPC-compatible error object.
 * If the given error is not fully compatible, it will be preserved on the
 * returned object's data.cause property.
 *
 * @param error - The error to serialize.
 * @param options - Options bag.
 * @param options.fallbackError - The error to return if the given error is
 * not compatible. Should be a JSON serializable value.
 * @param options.shouldIncludeStack - Whether to include the error's stack
 * on the returned object.
 * @returns The serialized error.
 */
function serializeError(error, {
  fallbackError = FALLBACK_ERROR,
  shouldIncludeStack = true
} = {}) {
  if (!isJsonRpcError(fallbackError)) {
    throw new Error("Must provide fallback error with integer number code and string message.");
  }
  const serialized = buildError(error, fallbackError);
  if (!shouldIncludeStack) {
    delete serialized.stack;
  }
  return serialized;
}

/**
 * Returns true if supplied error data has a usable `cause` property; false otherwise.
 *
 * @param data - Optional data to validate.
 * @returns Whether cause property is present and an object.
 */
function dataHasCause(data) {
  return isObject(data) && Object.hasOwn(data, "cause") && isObject(data.cause);
}

exports.JSON_RPC_SERVER_ERROR_MESSAGE = JSON_RPC_SERVER_ERROR_MESSAGE;
exports.dataHasCause = dataHasCause;
exports.getMessageFromCode = getMessageFromCode;
exports.isObject = isObject;
exports.isPlainObject = isPlainObject;
exports.isValidCode = isValidCode;
exports.isValidString = isValidString;
exports.serializeCause = serializeCause;
exports.serializeError = serializeError;
