'use strict';

var _objectSpread = require('@babel/runtime/helpers/objectSpread2');
var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var constants$1 = require('@toruslabs/constants');
var sessionManager = require('@toruslabs/session-manager');
var logger = require('../utils/logger.js');
var errors = require('./errors.js');
var PopupHandler = require('./PopupHandler.js');
var utils = require('./utils.js');
var constants = require('../utils/constants.js');
var browserStorage = require('../utils/browserStorage.js');
var utils$1 = require('../utils/utils.js');

class Auth {
  constructor(options) {
    _defineProperty(this, "state", {});
    _defineProperty(this, "options", void 0);
    _defineProperty(this, "sessionManager", void 0);
    _defineProperty(this, "currentStorage", void 0);
    _defineProperty(this, "_storageBaseKey", "auth_store");
    _defineProperty(this, "dappState", void 0);
    _defineProperty(this, "addVersionInUrls", true);
    if (!options.clientId) throw errors.InitializationError.invalidParams("clientId is required");
    if (!options.network) options.network = constants.WEB3AUTH_NETWORK.SAPPHIRE_MAINNET;
    if (!options.buildEnv) options.buildEnv = constants.BUILD_ENV.PRODUCTION;
    if (options.buildEnv === constants.BUILD_ENV.DEVELOPMENT || options.buildEnv === constants.BUILD_ENV.TESTING || options.sdkUrl) this.addVersionInUrls = false;
    if (!options.sdkUrl && !options.useMpc) {
      if (options.buildEnv === constants.BUILD_ENV.DEVELOPMENT) {
        options.sdkUrl = "http://localhost:3000";
        options.dashboardUrl = "http://localhost:5173";
      } else if (options.buildEnv === constants.BUILD_ENV.STAGING) {
        options.sdkUrl = "https://staging-auth.web3auth.io";
        options.dashboardUrl = "https://staging-account.web3auth.io";
      } else if (options.buildEnv === constants.BUILD_ENV.TESTING) {
        options.sdkUrl = "https://develop-auth.web3auth.io";
        options.dashboardUrl = "https://develop-account.web3auth.io";
      } else {
        options.sdkUrl = "https://auth.web3auth.io";
        options.dashboardUrl = "https://account.web3auth.io";
      }
    }
    if (options.useMpc && !options.sdkUrl) {
      if (Object.values(constants.WEB3AUTH_LEGACY_NETWORK).includes(options.network)) throw errors.InitializationError.invalidParams("MPC is not supported on legacy networks, please use sapphire_devnet or sapphire_mainnet.");
      if (options.buildEnv === constants.BUILD_ENV.DEVELOPMENT) {
        options.sdkUrl = "http://localhost:3000";
      } else if (options.buildEnv === constants.BUILD_ENV.STAGING) {
        options.sdkUrl = "https://staging-mpc-auth.web3auth.io";
      } else if (options.buildEnv === constants.BUILD_ENV.TESTING) {
        options.sdkUrl = "https://develop-mpc-auth.web3auth.io";
      } else {
        options.sdkUrl = "https://mpc-auth.web3auth.io";
      }
    }
    if (!options.redirectUrl && typeof window !== "undefined") {
      options.redirectUrl = `${window.location.protocol}//${window.location.host}${window.location.pathname}`;
    }
    if (!options.uxMode) options.uxMode = constants.UX_MODE.REDIRECT;
    if (typeof options.replaceUrlOnRedirect !== "boolean") options.replaceUrlOnRedirect = true;
    if (!options.originData) options.originData = {};
    if (!options.whiteLabel) options.whiteLabel = {};
    if (!options.loginConfig) options.loginConfig = {};
    if (!options.mfaSettings) options.mfaSettings = {};
    if (!options.storageServerUrl) options.storageServerUrl = constants$1.SESSION_SERVER_API_URL;
    if (!options.sessionSocketUrl) options.sessionSocketUrl = constants$1.SESSION_SERVER_SOCKET_URL;
    if (!options.storageKey) options.storageKey = "local";
    if (!options.webauthnTransports) options.webauthnTransports = ["internal"];
    if (!options.sessionTime) options.sessionTime = 86400;
    this.options = options;
  }
  get privKey() {
    if (this.options.useMpc) return this.state.factorKey || "";
    return this.state.privKey ? this.state.privKey.padStart(64, "0") : "";
  }
  get coreKitKey() {
    return this.state.coreKitKey ? this.state.coreKitKey.padStart(64, "0") : "";
  }
  get ed25519PrivKey() {
    return this.state.ed25519PrivKey ? this.state.ed25519PrivKey.padStart(128, "0") : "";
  }
  get coreKitEd25519Key() {
    return this.state.coreKitEd25519PrivKey ? this.state.coreKitEd25519PrivKey.padStart(128, "0") : "";
  }
  get sessionId() {
    return this.state.sessionId || "";
  }
  get sessionNamespace() {
    return this.options.sessionNamespace || "";
  }
  get appState() {
    return this.state.userInfo.appState || this.dappState || "";
  }
  get baseUrl() {
    // testing and develop don't have versioning
    if (!this.addVersionInUrls) return `${this.options.sdkUrl}`;
    return `${this.options.sdkUrl}/v${utils.version.split(".")[0]}`;
  }
  get dashboardUrl() {
    // testing and develop don't have versioning
    if (!this.addVersionInUrls) return `${this.options.dashboardUrl}`;
    return `${this.options.dashboardUrl}/v${utils.version.split(".")[0]}`;
  }
  async init() {
    // get sessionNamespace from the redirect result.
    const params = utils.getHashQueryParams(this.options.replaceUrlOnRedirect);
    if (params.sessionNamespace) this.options.sessionNamespace = params.sessionNamespace;
    const storageKey = this.options.sessionNamespace ? `${this._storageBaseKey}_${this.options.sessionNamespace}` : this._storageBaseKey;
    this.currentStorage = browserStorage.BrowserStorage.getInstance(storageKey, this.options.storageKey);
    const sessionId = this.currentStorage.get("sessionId");
    this.sessionManager = new sessionManager.SessionManager({
      sessionServerBaseUrl: this.options.storageServerUrl,
      sessionNamespace: this.options.sessionNamespace,
      sessionTime: this.options.sessionTime,
      sessionId,
      allowedOrigin: this.options.sdkUrl
    });
    if (this.options.network === constants.WEB3AUTH_NETWORK.TESTNET || this.options.network === constants.WEB3AUTH_NETWORK.SAPPHIRE_DEVNET) {
      // using console log because it shouldn't be affected by loglevel config
      // eslint-disable-next-line no-console
      console.log(`%c WARNING! You are on ${this.options.network}. Please set network: 'mainnet' or 'sapphire_mainnet' in production`, "color: #FF0000");
    }
    if (this.options.buildEnv !== constants.BUILD_ENV.PRODUCTION) {
      // using console log because it shouldn't be affected by loglevel config
      // eslint-disable-next-line no-console
      console.log(`%c WARNING! You are using build env ${this.options.buildEnv}. Please set buildEnv: 'production' in production`, "color: #FF0000");
    }
    if (params.error) {
      this.dappState = params.state;
      throw errors.LoginError.loginFailed(params.error);
    }
    if (params.sessionId) {
      this.currentStorage.set("sessionId", params.sessionId);
      this.sessionManager.sessionId = params.sessionId;
    }
    if (this.sessionManager.sessionId) {
      const data = await this._authorizeSession();
      // Fill state with correct info from session
      // If session is invalid all the data is unset here.
      this.updateState(data);
      if (Object.keys(data).length === 0) {
        // If session is invalid, unset the sessionId from localStorage.
        this.currentStorage.set("sessionId", "");
      } else {
        this.updateState({
          sessionId: this.sessionManager.sessionId
        });
      }
    }
  }
  async login(params) {
    if (!params.loginProvider) throw errors.LoginError.invalidLoginParams(`loginProvider is required`);

    // in case of redirect mode, redirect url will be dapp specified
    // in case of popup mode, redirect url will be sdk specified
    const defaultParams = {
      redirectUrl: this.options.redirectUrl
    };
    const loginParams = _objectSpread(_objectSpread({
      loginProvider: params.loginProvider
    }, defaultParams), params);
    const dataObject = {
      actionType: constants.AUTH_ACTIONS.LOGIN,
      options: this.options,
      params: loginParams
    };
    const result = await this.authHandler(`${this.baseUrl}/start`, dataObject, utils.getTimeout(params.loginProvider));
    if (this.options.uxMode === constants.UX_MODE.REDIRECT) return null;
    if (result.error) {
      this.dappState = result.state;
      throw errors.LoginError.loginFailed(result.error);
    }
    this.sessionManager.sessionId = result.sessionId;
    this.options.sessionNamespace = result.sessionNamespace;
    this.currentStorage.set("sessionId", result.sessionId);
    await this.rehydrateSession();
    return {
      privKey: this.privKey
    };
  }
  async logout() {
    if (!this.sessionManager.sessionId) throw errors.LoginError.userNotLoggedIn();
    await this.sessionManager.invalidateSession();
    this.updateState({
      privKey: "",
      coreKitKey: "",
      coreKitEd25519PrivKey: "",
      ed25519PrivKey: "",
      walletKey: "",
      oAuthPrivateKey: "",
      tKey: "",
      metadataNonce: "",
      keyMode: undefined,
      userInfo: {
        name: "",
        profileImage: "",
        dappShare: "",
        idToken: "",
        oAuthIdToken: "",
        oAuthAccessToken: "",
        appState: "",
        email: "",
        verifier: "",
        verifierId: "",
        aggregateVerifier: "",
        typeOfLogin: "",
        isMfaEnabled: false
      },
      authToken: "",
      sessionId: "",
      factorKey: "",
      signatures: [],
      tssShareIndex: -1,
      tssPubKey: "",
      tssShare: "",
      tssNonce: -1
    });
    this.currentStorage.set("sessionId", "");
  }
  async enableMFA(params) {
    var _this$state$userInfo;
    if (!this.sessionId) throw errors.LoginError.userNotLoggedIn();
    if (this.state.userInfo.isMfaEnabled) throw errors.LoginError.mfaAlreadyEnabled();
    // in case of redirect mode, redirect url will be dapp specified
    // in case of popup mode, redirect url will be sdk specified
    const defaultParams = {
      redirectUrl: this.options.redirectUrl
    };
    const dataObject = {
      actionType: constants.AUTH_ACTIONS.ENABLE_MFA,
      options: this.options,
      params: _objectSpread(_objectSpread(_objectSpread({}, defaultParams), params), {}, {
        loginProvider: this.state.userInfo.typeOfLogin,
        extraLoginOptions: {
          login_hint: this.state.userInfo.verifierId
        },
        mfaLevel: "mandatory"
      }),
      sessionId: this.sessionId
    };
    const result = await this.authHandler(`${this.baseUrl}/start`, dataObject, utils.getTimeout(dataObject.params.loginProvider));
    if (this.options.uxMode === constants.UX_MODE.REDIRECT) return null;
    if (result.error) {
      this.dappState = result.state;
      throw errors.LoginError.loginFailed(result.error);
    }
    this.sessionManager.sessionId = result.sessionId;
    this.options.sessionNamespace = result.sessionNamespace;
    this.currentStorage.set("sessionId", result.sessionId);
    await this.rehydrateSession();
    return Boolean((_this$state$userInfo = this.state.userInfo) === null || _this$state$userInfo === void 0 ? void 0 : _this$state$userInfo.isMfaEnabled);
  }
  async manageMFA(params) {
    if (!this.sessionId) throw errors.LoginError.userNotLoggedIn();
    if (!this.state.userInfo.isMfaEnabled) throw errors.LoginError.mfaNotEnabled();

    // in case of redirect mode, redirect url will be dapp specified
    // in case of popup mode, redirect url will be sdk specified
    const defaultParams = {
      redirectUrl: `${this.dashboardUrl}/wallet/account`,
      dappUrl: `${window.location.origin}${window.location.pathname}`
    };
    const loginId = sessionManager.SessionManager.generateRandomSessionKey();
    const dataObject = {
      actionType: constants.AUTH_ACTIONS.MANAGE_MFA,
      // manage mfa always opens in a new tab, so need to fix the uxMode to redirect.
      options: _objectSpread(_objectSpread({}, this.options), {}, {
        uxMode: "redirect"
      }),
      params: _objectSpread(_objectSpread(_objectSpread({}, defaultParams), params), {}, {
        loginProvider: this.state.userInfo.typeOfLogin,
        extraLoginOptions: {
          login_hint: this.state.userInfo.verifierId
        },
        appState: utils$1.jsonToBase64({
          loginId
        })
      }),
      sessionId: this.sessionId
    };
    this.createLoginSession(loginId, dataObject, dataObject.options.sessionTime, true);
    const configParams = {
      loginId,
      sessionNamespace: this.options.sessionNamespace,
      storageServerUrl: this.options.storageServerUrl
    };
    const loginUrl = utils.constructURL({
      baseURL: `${this.baseUrl}/start`,
      hash: {
        b64Params: utils$1.jsonToBase64(configParams)
      }
    });
    window.open(loginUrl, "_blank");
  }
  async manageSocialFactor(actionType, params) {
    if (!this.sessionId) throw errors.LoginError.userNotLoggedIn();

    // in case of redirect mode, redirect url will be dapp specified
    // in case of popup mode, redirect url will be sdk specified
    const defaultParams = {
      redirectUrl: this.options.redirectUrl
    };
    const dataObject = {
      actionType,
      options: this.options,
      params: _objectSpread(_objectSpread({}, defaultParams), params),
      sessionId: this.sessionId
    };
    const result = await this.authHandler(`${this.baseUrl}/start`, dataObject);
    if (this.options.uxMode === constants.UX_MODE.REDIRECT) return undefined;
    if (result.error) return false;
    return true;
  }
  async addAuthenticatorFactor(params) {
    if (!this.sessionId) throw errors.LoginError.userNotLoggedIn();

    // in case of redirect mode, redirect url will be dapp specified
    // in case of popup mode, redirect url will be sdk specified
    const defaultParams = {
      redirectUrl: this.options.redirectUrl
    };
    const dataObject = {
      actionType: constants.AUTH_ACTIONS.ADD_AUTHENTICATOR_FACTOR,
      options: this.options,
      params: _objectSpread(_objectSpread(_objectSpread({}, defaultParams), params), {}, {
        loginProvider: constants.LOGIN_PROVIDER.AUTHENTICATOR
      }),
      sessionId: this.sessionId
    };
    const result = await this.authHandler(`${this.baseUrl}/start`, dataObject);
    if (this.options.uxMode === constants.UX_MODE.REDIRECT) return undefined;
    if (result.error) return false;
    return true;
  }
  async addPasskeyFactor(params) {
    if (!this.sessionId) throw errors.LoginError.userNotLoggedIn();

    // in case of redirect mode, redirect url will be dapp specified
    // in case of popup mode, redirect url will be sdk specified
    const defaultParams = {
      redirectUrl: this.options.redirectUrl
    };
    const dataObject = {
      actionType: constants.AUTH_ACTIONS.ADD_PASSKEY_FACTOR,
      options: this.options,
      params: _objectSpread(_objectSpread(_objectSpread({}, defaultParams), params), {}, {
        loginProvider: constants.LOGIN_PROVIDER.PASSKEYS
      }),
      sessionId: this.sessionId
    };
    const result = await this.authHandler(`${this.baseUrl}/start`, dataObject);
    if (this.options.uxMode === constants.UX_MODE.REDIRECT) return undefined;
    if (result.error) return false;
    return true;
  }
  getUserInfo() {
    if (!this.sessionManager.sessionId) {
      throw errors.LoginError.userNotLoggedIn();
    }
    return this.state.userInfo;
  }
  async createLoginSession(loginId, data, timeout = 600, skipAwait = false) {
    if (!this.sessionManager) throw errors.InitializationError.notInitialized();
    const loginSessionMgr = new sessionManager.SessionManager({
      sessionServerBaseUrl: data.options.storageServerUrl,
      sessionNamespace: data.options.sessionNamespace,
      sessionTime: timeout,
      // each login key must be used with 10 mins (might be used at the end of popup redirect)
      sessionId: loginId,
      allowedOrigin: this.options.sdkUrl
    });
    const promise = loginSessionMgr.createSession(JSON.parse(JSON.stringify(data)));
    if (data.options.uxMode === constants.UX_MODE.REDIRECT && !skipAwait) {
      await promise;
    }
  }
  async _authorizeSession() {
    try {
      if (!this.sessionManager.sessionId) return {};
      const result = await this.sessionManager.authorizeSession();
      return result;
    } catch (err) {
      logger.loglevel.error("authorization failed", err);
      return {};
    }
  }
  updateState(data) {
    this.state = _objectSpread(_objectSpread({}, this.state), data);
  }
  async rehydrateSession() {
    const result = await this._authorizeSession();
    this.updateState(result);
  }
  async authHandler(url, dataObject, popupTimeout = 1000 * 10) {
    const loginId = sessionManager.SessionManager.generateRandomSessionKey();
    await this.createLoginSession(loginId, dataObject);
    const configParams = {
      loginId,
      sessionNamespace: this.options.sessionNamespace,
      storageServerUrl: this.options.storageServerUrl
    };
    if (this.options.uxMode === constants.UX_MODE.REDIRECT) {
      const loginUrl = utils.constructURL({
        baseURL: url,
        hash: {
          b64Params: utils$1.jsonToBase64(configParams)
        }
      });
      window.location.href = loginUrl;
      return undefined;
    }
    const loginUrl = utils.constructURL({
      baseURL: url,
      hash: {
        b64Params: utils$1.jsonToBase64(configParams)
      }
    });
    const currentWindow = new PopupHandler({
      url: loginUrl,
      timeout: popupTimeout,
      sessionServerUrl: this.options.storageServerUrl,
      sessionSocketUrl: this.options.sessionSocketUrl
    });
    return new Promise((resolve, reject) => {
      currentWindow.on("close", () => {
        reject(errors.LoginError.popupClosed());
      });
      currentWindow.listenOnChannel(loginId).then(resolve).catch(reject);
      try {
        currentWindow.open();
      } catch (error) {
        reject(error);
      }
    });
  }
}

exports.Auth = Auth;
