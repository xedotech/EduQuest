'use strict';

var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var constants = require('@toruslabs/constants');
var securePubSub = require('@toruslabs/secure-pub-sub');
var events = require('events');
var errors = require('./errors.js');
var utils = require('./utils.js');

class PopupHandler extends events.EventEmitter {
  constructor({
    url,
    target,
    features,
    timeout = 30000,
    sessionSocketUrl,
    sessionServerUrl
  }) {
    // Disabling the rule here, as it is a false positive.
    // eslint-disable-next-line constructor-super
    super();
    _defineProperty(this, "url", void 0);
    _defineProperty(this, "target", void 0);
    _defineProperty(this, "features", void 0);
    _defineProperty(this, "window", void 0);
    _defineProperty(this, "windowTimer", void 0);
    _defineProperty(this, "iClosedWindow", void 0);
    _defineProperty(this, "timeout", void 0);
    _defineProperty(this, "sessionSocketUrl", void 0);
    _defineProperty(this, "sessionServerUrl", void 0);
    this.url = url;
    this.target = target || "_blank";
    this.features = features || utils.getPopupFeatures();
    this.window = undefined;
    this.windowTimer = undefined;
    this.iClosedWindow = false;
    this.timeout = timeout;
    this.sessionServerUrl = sessionServerUrl || constants.SESSION_SERVER_API_URL;
    this.sessionSocketUrl = sessionSocketUrl || constants.SESSION_SERVER_SOCKET_URL;
    this._setupTimer();
  }
  _setupTimer() {
    this.windowTimer = Number(setInterval(() => {
      if (this.window && this.window.closed) {
        clearInterval(this.windowTimer);
        setTimeout(() => {
          if (!this.iClosedWindow) {
            this.emit("close");
          }
          this.iClosedWindow = false;
          this.window = undefined;
        }, this.timeout);
      }
      if (this.window === undefined) clearInterval(this.windowTimer);
    }, 500));
  }
  open() {
    var _this$window;
    this.window = window.open(this.url, this.target, this.features);
    if (!this.window) throw errors.LoginError.popupBlocked();
    if ((_this$window = this.window) !== null && _this$window !== void 0 && _this$window.focus) this.window.focus();
  }
  close() {
    this.iClosedWindow = true;
    if (this.window) this.window.close();
  }
  redirect(locationReplaceOnRedirect) {
    if (locationReplaceOnRedirect) {
      window.location.replace(this.url);
    } else {
      window.location.href = this.url;
    }
  }
  async listenOnChannel(loginId) {
    const securePubSub$1 = new securePubSub.SecurePubSub({
      serverUrl: this.sessionServerUrl,
      socketUrl: this.sessionSocketUrl
    });
    const data = await securePubSub$1.subscribe(loginId);
    this.close();
    securePubSub$1.cleanup();
    const parsedData = JSON.parse(data);
    if (parsedData.error) {
      return {
        error: parsedData.error,
        state: parsedData.state
      };
    }
    return parsedData.data;
  }
}

module.exports = PopupHandler;
