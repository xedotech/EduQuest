'use strict';

var _objectSpread = require('@babel/runtime/helpers/objectSpread2');
var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var baseControllers = require('@toruslabs/base-controllers');
var auth = require('@web3auth/auth');
var pump = require('pump');
var isStream = require('./isStream.js');
var messages = require('./messages.js');
var utils = require('./utils.js');

/**
 * @param connectionStream - A Node.js duplex stream
 * @param opts - An options bag
 */
class BaseProvider extends auth.SafeEventEmitter {
  constructor(connectionStream, {
    maxEventListeners = 100,
    jsonRpcStreamName = "provider"
  }) {
    super();
    _defineProperty(this, "rpcEngine", void 0);
    _defineProperty(this, "jsonRpcConnectionEvents", void 0);
    /**
     * Indicating that this provider is a Web3Auth provider.
     */
    _defineProperty(this, "isWeb3Auth", void 0);
    _defineProperty(this, "state", void 0);
    if (!isStream.isDuplexStream(connectionStream)) {
      throw new Error(messages.errors.invalidDuplexStream());
    }
    this.isWeb3Auth = true;
    this.setMaxListeners(maxEventListeners);
    this.handleConnect = this.handleConnect.bind(this);
    this.handleDisconnect = this.handleDisconnect.bind(this);
    this.handleStreamDisconnect = this.handleStreamDisconnect.bind(this);
    this.rpcRequest = this.rpcRequest.bind(this);
    this.initializeState = this.initializeState.bind(this);
    this.request = this.request.bind(this);
    this.sendAsync = this.sendAsync.bind(this);
    this.send = this.send.bind(this);
    // this.enable = this.enable.bind(this);
    // setup connectionStream multiplexing
    const mux = new auth.ObjectMultiplex();
    pump(connectionStream, mux, connectionStream, this.handleStreamDisconnect.bind(this, "Web3Auth"));
    // ignore phishing warning message (handled elsewhere)
    mux.ignoreStream("phishing");
    // setup own event listeners
    // connect to async provider
    const jsonRpcConnection = auth.createStreamMiddleware();
    pump(jsonRpcConnection.stream, mux.createStream(jsonRpcStreamName), jsonRpcConnection.stream, this.handleStreamDisconnect.bind(this, "Web3Auth RpcProvider"));
    // handle RPC requests via dapp-side rpc engine
    const rpcEngine = new auth.JRPCEngine();
    rpcEngine.push(auth.createIdRemapMiddleware());
    rpcEngine.push(utils.createErrorMiddleware());
    rpcEngine.push(baseControllers.createLoggerMiddleware({
      origin: location.origin
    }));
    rpcEngine.push(jsonRpcConnection.middleware);
    this.rpcEngine = rpcEngine;
    this.jsonRpcConnectionEvents = jsonRpcConnection.events;
  }
  /**
   * Submits an RPC request for the given method, with the given params.
   * Resolves with the result of the method call, or rejects on error.
   *
   * @param args - The RPC request arguments.
   * @returns A Promise that resolves with the result of the RPC method,
   * or rejects if an error is encountered.
   */
  async request(args) {
    if (!args || typeof args !== "object" || Array.isArray(args)) {
      throw auth.rpcErrors.invalidRequest({
        message: messages.errors.invalidRequestArgs(),
        data: _objectSpread(_objectSpread({}, args || {}), {}, {
          cause: messages.errors.invalidRequestArgs()
        })
      });
    }
    const {
      method,
      params
    } = args;
    if (typeof method !== "string" || method.length === 0) {
      throw auth.rpcErrors.invalidRequest({
        message: messages.errors.invalidRequestMethod(),
        data: _objectSpread(_objectSpread({}, args || {}), {}, {
          cause: messages.errors.invalidRequestArgs()
        })
      });
    }
    if (params !== undefined && !Array.isArray(params) && (typeof params !== "object" || params === null)) {
      throw auth.rpcErrors.invalidRequest({
        message: messages.errors.invalidRequestParams(),
        data: _objectSpread(_objectSpread({}, args || {}), {}, {
          cause: messages.errors.invalidRequestArgs()
        })
      });
    }
    return new Promise((resolve, reject) => {
      this.rpcRequest({
        method,
        params
      }, auth.getRpcPromiseCallback(resolve, reject));
    });
  }
  /**
   * Submits an RPC request per the given JSON-RPC request object.
   *
   * @param payload - The RPC request object.
   * @param cb - The callback function.
   */
  send(payload, callback) {
    this.rpcRequest(payload, callback);
  }
  /**
   * Submits an RPC request per the given JSON-RPC request object.
   *
   * @param payload - The RPC request object.
   * @param cb - The callback function.
   */
  sendAsync(payload) {
    return new Promise((resolve, reject) => {
      this.rpcRequest(payload, auth.getRpcPromiseCallback(resolve, reject));
    });
  }
  /**
   * Called when connection is lost to critical streams.
   *
   * emits InpageProvider#disconnect
   */
  handleStreamDisconnect(streamName, error) {
    utils.logStreamDisconnectWarning(streamName, error, this);
    this.handleDisconnect(false, error ? error.message : undefined);
  }
}

module.exports = BaseProvider;
