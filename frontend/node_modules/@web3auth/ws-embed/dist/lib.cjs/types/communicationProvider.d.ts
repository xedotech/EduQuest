import { ProviderEvents } from "@web3auth/auth";
import type { Duplex } from "readable-stream";
import BaseProvider from "./baseProvider";
import { CommunicationProviderState, ProviderOptions, UnValidatedJsonRpcRequest } from "./interfaces";
import PopupHandler from "./PopupHandler";
type CommunicationProviderEvents = ProviderEvents & {
    connect: (payload: {
        currentAuthConnection: string;
        isLoggedIn: boolean;
    }) => void;
    disconnect: (err: Error) => void;
};
/**
 * @param connectionStream - A Node.js duplex stream
 * @param  opts - An options bag
 */
declare class CommunicationProvider extends BaseProvider<CommunicationProviderState, CommunicationProviderEvents> {
    protected static defaultState: CommunicationProviderState;
    tryWindowHandle: (payload: UnValidatedJsonRpcRequest | UnValidatedJsonRpcRequest[], cb: (...args: unknown[]) => void) => void;
    windowRefs: Map<string, PopupHandler>;
    iframeUrl: string;
    private iframeId;
    constructor(connectionStream: Duplex, { maxEventListeners, jsonRpcStreamName }: ProviderOptions, state: Partial<CommunicationProviderState>);
    get isLoggedIn(): boolean;
    get isIFrameFullScreen(): boolean;
    get allowWalletService(): boolean;
    /**
     * Returns whether the inPage provider is connected to Torus.
     */
    isConnected(): boolean;
    initializeState(params: Record<string, unknown>): Promise<void>;
    displayIframe({ isFull, rid }?: {
        isFull?: boolean;
        rid?: string;
    }, walletRequest?: boolean): void;
    /**
     * Scenarios:
     * - Login request or pre-open confirmation windows
     * We try to open here or send a rpc request to iframe that window is blocked.
     */
    handleWindow(windowId: string, { url, target, features, timeout }?: {
        url?: string;
        target?: string;
        features?: string;
        timeout?: number;
    }): Promise<void>;
    /**
     * Internal RPC method. Forwards requests to background via the RPC engine.
     * Also remap ids inbound and outbound
     */
    protected rpcRequest(payload: UnValidatedJsonRpcRequest | UnValidatedJsonRpcRequest[], callback: (...args: unknown[]) => void): void;
    /**
     * When the provider becomes connected, updates internal state and emits
     * required events. Idempotent.
     *
     * @param currentAuthConnection - The auth connection
     * emits TorusInpageProvider#connect
     */
    protected handleConnect(currentAuthConnection: string, isLoggedIn: boolean): void;
    /**
     * When the provider becomes disconnected, updates internal state and emits
     * required events. Idempotent with respect to the isRecoverable parameter.
     *
     * Error codes per the CloseEvent status codes as required by EIP-1193:
     * https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes
     *
     * @param isRecoverable - Whether the disconnection is recoverable.
     * @param errorMessage - A custom error message.
     * emits TorusInpageProvider#disconnect
     */
    protected handleDisconnect(isRecoverable: boolean, errorMessage?: string): void;
    private handleCloseWindow;
}
export default CommunicationProvider;
