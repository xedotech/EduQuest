import _defineProperty from '@babel/runtime/helpers/defineProperty';
import { SafeEventEmitter } from '@web3auth/auth';
import { NFTCheckoutEmbed } from './embed.js';
import { NFTCheckoutPluginError } from '../../base/plugin/errors.js';
import { EVM_PLUGINS, PLUGIN_STATUS, PLUGIN_NAMESPACES, PLUGIN_EVENTS } from '../../base/plugin/IPlugin.js';
import { WALLET_CONNECTORS } from '../../base/wallet/index.js';
import { CONNECTOR_STATUS } from '../../base/connector/constants.js';

class NFTCheckoutPlugin extends SafeEventEmitter {
  constructor(params) {
    super();
    _defineProperty(this, "name", EVM_PLUGINS.NFT_CHECKOUT);
    _defineProperty(this, "status", PLUGIN_STATUS.DISCONNECTED);
    _defineProperty(this, "SUPPORTED_CONNECTORS", Object.values(WALLET_CONNECTORS));
    _defineProperty(this, "pluginNamespace", PLUGIN_NAMESPACES.EIP155);
    _defineProperty(this, "web3auth", null);
    _defineProperty(this, "nftCheckoutEmbedInstance", null);
    _defineProperty(this, "isInitialized", false);
    _defineProperty(this, "receiverAddress", null);
    this.nftCheckoutEmbedInstance = new NFTCheckoutEmbed(params);
  }
  async initWithWeb3Auth(web3auth, whiteLabel) {
    if (this.isInitialized) return;
    if (!web3auth) throw NFTCheckoutPluginError.web3authRequired();
    this.web3auth = web3auth;
    await this.nftCheckoutEmbedInstance.init({
      whiteLabel
    });
    this.isInitialized = true;
    this.status = PLUGIN_STATUS.READY;
    this.emit(PLUGIN_EVENTS.READY);
  }
  async connect() {
    if (!this.isInitialized) throw NFTCheckoutPluginError.notInitialized();
    this.emit(PLUGIN_EVENTS.CONNECTING);
    this.status = PLUGIN_STATUS.CONNECTING;
    if (this.web3auth.status !== CONNECTOR_STATUS.CONNECTED) throw NFTCheckoutPluginError.web3AuthNotConnected();
    if (!this.web3auth.provider) throw NFTCheckoutPluginError.providerRequired();
    const accounts = await this.web3auth.provider.request({
      method: "eth_accounts"
    });
    if (accounts.length === 0) throw NFTCheckoutPluginError.web3AuthNotConnected();
    this.receiverAddress = accounts[0];
    this.emit(PLUGIN_EVENTS.CONNECTED);
    this.status = PLUGIN_STATUS.CONNECTED;
  }
  async show({
    contractId
  }) {
    if (this.status !== PLUGIN_STATUS.CONNECTED) NFTCheckoutPluginError.pluginNotConnected();
    return this.nftCheckoutEmbedInstance.show({
      receiverAddress: this.receiverAddress,
      contractId
    });
  }
  disconnect() {
    if (this.status !== PLUGIN_STATUS.CONNECTED) NFTCheckoutPluginError.pluginNotConnected();
    this.emit(PLUGIN_EVENTS.DISCONNECTED);
    this.status = PLUGIN_STATUS.DISCONNECTED;
    return Promise.resolve();
  }
  cleanup() {
    this.nftCheckoutEmbedInstance.cleanup();
    this.receiverAddress = null;
    this.isInitialized = false;
    return Promise.resolve();
  }
}
const nftCheckoutPlugin = params => {
  return () => {
    return new NFTCheckoutPlugin(params);
  };
};

export { nftCheckoutPlugin };
