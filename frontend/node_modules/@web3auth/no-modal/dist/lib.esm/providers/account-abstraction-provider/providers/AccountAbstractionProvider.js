import _objectSpread from '@babel/runtime/helpers/objectSpread2';
import _defineProperty from '@babel/runtime/helpers/defineProperty';
import { SMART_ACCOUNT, METHOD_TYPES } from '@toruslabs/ethereum-controllers';
export { SMART_ACCOUNT } from '@toruslabs/ethereum-controllers';
import { JRPCEngine, providerFromEngine, providerErrors } from '@web3auth/auth';
import { defineChain, createPublicClient, http, createWalletClient, custom } from 'viem';
import { createPaymasterClient, createBundlerClient } from 'viem/account-abstraction';
import { createEoaMiddleware, providerAsMiddleware, createAaMiddleware } from '../rpc/ethRpcMiddlewares.js';
import { getProviderHandlers } from './utils.js';
import { BaseProvider } from '../../base-provider/baseProvider.js';
import { CHAIN_NAMESPACES } from '@toruslabs/base-controllers';
import { WalletInitializationError } from '../../../base/errors/index.js';

var _AccountAbstractionProvider;
class AccountAbstractionProvider extends BaseProvider {
  constructor({
    config,
    state
  }) {
    super({
      config,
      state
    });
    _defineProperty(this, "PROVIDER_CHAIN_NAMESPACE", CHAIN_NAMESPACES.EIP155);
    _defineProperty(this, "_smartAccount", void 0);
    _defineProperty(this, "_publicClient", void 0);
    _defineProperty(this, "_bundlerClient", void 0);
    _defineProperty(this, "_paymasterClient", void 0);
    _defineProperty(this, "_useProviderAsTransport", void 0);
    this.update({
      chainId: config.chain.chainId
    });
  }
  get smartAccount() {
    return this._smartAccount;
  }
  get bundlerClient() {
    return this._bundlerClient;
  }
  get paymasterClient() {
    return this._paymasterClient;
  }
  get publicClient() {
    return this._publicClient;
  }
  async enable() {
    if (!this.state.eoaProvider) throw providerErrors.custom({
      message: "eoaProvider is not found in state, please pass it",
      code: 4902
    });
    await this.setupProvider(this.state.eoaProvider);
    return this._providerEngineProxy.request({
      method: "eth_accounts"
    });
  }
  async setupProvider(eoaProvider) {
    var _bundlerConfig$transp;
    const {
      currentChain
    } = this;
    const {
      chainNamespace
    } = currentChain;
    if (chainNamespace !== this.PROVIDER_CHAIN_NAMESPACE) throw WalletInitializationError.incompatibleChainNameSpace("Invalid chain namespace");
    const bundlerAndPaymasterConfig = this.config.smartAccountChainsConfig.find(config => config.chainId === currentChain.chainId);
    if (!bundlerAndPaymasterConfig) throw WalletInitializationError.invalidProviderConfigError(`Bundler and paymaster config not found for chain ${currentChain.chainId}`);
    const {
      bundlerConfig,
      paymasterConfig
    } = bundlerAndPaymasterConfig;
    const chain = defineChain({
      id: Number.parseInt(currentChain.chainId, 16),
      // id in number form
      name: currentChain.displayName,
      rpcUrls: {
        default: {
          http: [currentChain.rpcTarget],
          webSocket: [currentChain.wsTarget]
        }
      },
      blockExplorers: currentChain.blockExplorerUrl ? {
        default: {
          name: "explorer",
          // TODO: correct name if chain config has it
          url: currentChain.blockExplorerUrl
        }
      } : undefined,
      nativeCurrency: {
        name: currentChain.tickerName,
        symbol: currentChain.ticker,
        decimals: currentChain.decimals || 18
      }
    });
    // setup public client for viem smart account
    this._publicClient = createPublicClient({
      chain,
      transport: http(currentChain.rpcTarget)
    });
    const [eoaAddress] = await eoaProvider.request({
      method: METHOD_TYPES.ETH_REQUEST_ACCOUNTS
    });
    const walletClient = createWalletClient({
      account: eoaAddress,
      chain,
      transport: custom(eoaProvider)
    });
    this._smartAccount = await this.config.smartAccountInit.getSmartAccount({
      walletClient,
      client: this._publicClient
    });

    // setup bundler and paymaster
    if (paymasterConfig) {
      var _paymasterConfig$tran;
      this._paymasterClient = createPaymasterClient(_objectSpread(_objectSpread({}, paymasterConfig), {}, {
        transport: this._useProviderAsTransport ? custom(eoaProvider) : (_paymasterConfig$tran = paymasterConfig.transport) !== null && _paymasterConfig$tran !== void 0 ? _paymasterConfig$tran : http(paymasterConfig.url)
      }));
    }
    this._bundlerClient = createBundlerClient(_objectSpread(_objectSpread({}, bundlerConfig), {}, {
      account: this.smartAccount,
      client: this._publicClient,
      transport: this._useProviderAsTransport ? custom(eoaProvider) : (_bundlerConfig$transp = bundlerConfig.transport) !== null && _bundlerConfig$transp !== void 0 ? _bundlerConfig$transp : http(bundlerConfig.url),
      paymaster: this._paymasterClient
    }));
    const providerHandlers = getProviderHandlers({
      bundlerClient: this._bundlerClient,
      smartAccount: this._smartAccount,
      chain,
      eoaProvider
    });

    // setup rpc engine and AA middleware
    const engine = new JRPCEngine();
    const aaMiddleware = await createAaMiddleware({
      eoaProvider,
      handlers: providerHandlers
    });
    engine.push(aaMiddleware);
    const eoaMiddleware = providerAsMiddleware(eoaProvider);
    engine.push(eoaMiddleware);
    const provider = providerFromEngine(engine);
    this.updateProviderEngineProxy(provider);
    eoaProvider.once("chainChanged", chainId => {
      this.update({
        chainId
      });
      this.setupChainSwitchMiddleware();
      this.emit("chainChanged", chainId);
    });
  }
  async updateAccount(_params) {
    throw providerErrors.unsupportedMethod("updateAccount. Please call it on eoaProvider");
  }
  async switchChain(_params) {
    throw providerErrors.unsupportedMethod("switchChain. Please call it on eoaProvider");
  }
  async lookupNetwork() {
    throw providerErrors.unsupportedMethod("lookupNetwork. Please call it on eoaProvider");
  }
  async setupChainSwitchMiddleware() {
    return this.setupProvider(this.state.eoaProvider);
  }
}
_AccountAbstractionProvider = AccountAbstractionProvider;
_defineProperty(AccountAbstractionProvider, "getProviderInstance", async params => {
  const providerInstance = new _AccountAbstractionProvider({
    config: params
  });
  providerInstance._useProviderAsTransport = params.useProviderAsTransport;
  await providerInstance.setupProvider(params.eoaProvider);
  providerInstance.update({
    eoaProvider: params.eoaProvider
  });
  return providerInstance;
});
const accountAbstractionProvider = async ({
  accountAbstractionConfig,
  chain,
  chains,
  provider,
  useProviderAsTransport
}) => {
  let smartAccountInit;
  const {
    smartAccountType,
    chains: smartAccountChainsConfig
  } = accountAbstractionConfig;
  const {
    smartAccountConfig
  } = smartAccountChainsConfig.find(config => config.chainId === chain.chainId) || {};
  switch (smartAccountType) {
    case SMART_ACCOUNT.BICONOMY:
      {
        const {
          BiconomySmartAccount
        } = await import('@toruslabs/ethereum-controllers');
        smartAccountInit = new BiconomySmartAccount(smartAccountConfig);
        break;
      }
    case SMART_ACCOUNT.KERNEL:
      {
        const {
          KernelSmartAccount
        } = await import('@toruslabs/ethereum-controllers');
        smartAccountInit = new KernelSmartAccount(smartAccountConfig);
        break;
      }
    case SMART_ACCOUNT.NEXUS:
      {
        const {
          NexusSmartAccount
        } = await import('@toruslabs/ethereum-controllers');
        smartAccountInit = new NexusSmartAccount(smartAccountConfig);
        break;
      }
    case SMART_ACCOUNT.SAFE:
      {
        const {
          SafeSmartAccount
        } = await import('@toruslabs/ethereum-controllers');
        smartAccountInit = new SafeSmartAccount(smartAccountConfig);
        break;
      }
    case SMART_ACCOUNT.TRUST:
      {
        const {
          TrustSmartAccount
        } = await import('@toruslabs/ethereum-controllers');
        smartAccountInit = new TrustSmartAccount(smartAccountConfig);
        break;
      }
    case SMART_ACCOUNT.METAMASK:
      {
        const {
          MetamaskSmartAccount
        } = await import('@toruslabs/ethereum-controllers');
        smartAccountInit = new MetamaskSmartAccount(smartAccountConfig);
        break;
      }
    default:
      throw new Error("Smart account type not supported");
  }
  return AccountAbstractionProvider.getProviderInstance({
    eoaProvider: provider,
    smartAccountInit,
    chain,
    chains,
    smartAccountChainsConfig,
    useProviderAsTransport
  });
};
const toEoaProvider = async aaProvider => {
  // derive EOA provider from AA provider
  const engine = new JRPCEngine();
  const eoaMiddleware = await createEoaMiddleware({
    aaProvider
  });
  engine.push(eoaMiddleware);
  engine.push(providerAsMiddleware(aaProvider));
  return providerFromEngine(engine);
};

export { accountAbstractionProvider, toEoaProvider };
