import _objectSpread from '@babel/runtime/helpers/objectSpread2';
import { isHexString, addHexPrefix } from '@ethereumjs/util';
import { providerErrors } from '@web3auth/auth';
import { createWalletClient, http } from 'viem';
import { log } from '../../../base/loglevel.js';

function getProviderHandlers({
  bundlerClient,
  smartAccount,
  chain,
  eoaProvider
}) {
  const walletClient = createWalletClient({
    account: smartAccount,
    chain,
    transport: http()
  });
  return {
    getAccounts: async _ => {
      const [smartAccounts, eoaAccounts] = await Promise.all([smartAccount.getAddress(), eoaProvider.request({
        method: "eth_accounts"
      })]);
      log.info("smartAccounts", smartAccounts);
      log.info("eoaAccounts", eoaAccounts);
      return [smartAccounts, ...eoaAccounts];
    },
    getPrivateKey: async _ => {
      throw providerErrors.custom({
        message: "Smart accounts do not have private key",
        code: 4903
      });
    },
    getPublicKey: async _ => {
      throw providerErrors.custom({
        message: "Smart accounts do not have a public key. Use address instead.",
        code: 4903
      });
    },
    processTransaction: async txParams => {
      if (txParams.input && !txParams.data) txParams.data = addHexPrefix(txParams.input);
      const {
        to,
        value,
        data
      } = txParams;
      // @ts-expect-error viem types are too deep
      const userOperationParams = {
        account: smartAccount,
        calls: [{
          to,
          // Explicit conversation required to avoid value being passed as hex
          value: BigInt(value),
          data
        }]
        // should not use maxFeePerGas/maxPriorityFeePerGas from transaction params since that's fee for transaction not user operation and let bundler handle it instead
      };
      const userOpHash = await bundlerClient.sendUserOperation(userOperationParams);
      const txReceipt = await bundlerClient.waitForUserOperationReceipt({
        hash: userOpHash
      });
      if (!txReceipt.success) {
        throw providerErrors.custom({
          message: txReceipt.reason,
          code: 4905
        });
      }
      return txReceipt.receipt.transactionHash;
    },
    processSignTransaction: async txParams => {
      const {
        to,
        value,
        data
      } = txParams;
      const request = await bundlerClient.prepareUserOperation({
        account: smartAccount,
        calls: [{
          to,
          value: BigInt(value),
          data
        }]
      });
      const signature = await smartAccount.signUserOperation({
        callData: request.callData,
        callGasLimit: request.callGasLimit,
        maxFeePerGas: request.maxFeePerGas,
        maxPriorityFeePerGas: request.maxPriorityFeePerGas,
        nonce: request.nonce,
        preVerificationGas: request.preVerificationGas,
        verificationGasLimit: request.verificationGasLimit,
        signature: request.signature
      });
      return signature;
    },
    processEthSignMessage: async (_, req) => {
      return eoaProvider.request(req);
    },
    processPersonalMessage: async (msgParams, _) => {
      const message = msgParams.data;
      return walletClient.signMessage({
        account: smartAccount,
        message: isHexString(message) ? {
          raw: message
        } : message
      });
    },
    processTypedMessageV4: async (msgParams, _) => {
      try {
        const data = typeof msgParams.data === "string" ? JSON.parse(msgParams.data) : msgParams.data;
        const signature = await walletClient.signTypedData({
          account: smartAccount,
          domain: _objectSpread(_objectSpread({}, data.domain), {}, {
            verifyingContract: data.domain.verifyingContract,
            salt: data.domain.salt,
            chainId: Number(data.domain.chainId)
          }),
          primaryType: data.primaryType,
          types: data.types,
          message: data.message
        });
        return signature;
      } catch (error) {
        throw providerErrors.custom({
          message: error instanceof Error ? error.message : "Failed to sign typed data",
          code: 4905
        });
      }
    }
  };
}

export { getProviderHandlers };
