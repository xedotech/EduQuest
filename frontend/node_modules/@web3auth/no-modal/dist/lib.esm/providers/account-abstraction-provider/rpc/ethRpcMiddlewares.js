import _objectSpread from '@babel/runtime/helpers/objectSpread2';
import { METHOD_TYPES } from '@toruslabs/ethereum-controllers';
import { createScaffoldMiddleware, createAsyncMiddleware, rpcErrors } from '@web3auth/auth';

async function createAaMiddleware({
  eoaProvider,
  handlers
}) {
  const [eoaAddress] = await eoaProvider.request({
    method: METHOD_TYPES.GET_ACCOUNTS
  });

  /**
   * Validates the keyholder address, and returns a normalized (i.e. lowercase)
   * copy of it.
   *
   * an error
   */
  async function validateAndNormalizeKeyholder(address, req) {
    if (typeof address === "string" && address.length > 0) {
      // ensure address is included in provided accounts
      const accounts = await handlers.getAccounts(req);
      const normalizedAccounts = accounts.map(_address => _address.toLowerCase());
      const normalizedAddress = address.toLowerCase();
      if (normalizedAccounts.includes(normalizedAddress)) {
        return normalizedAddress;
      }
    }
    throw rpcErrors.invalidParams({
      message: `Invalid parameters: must provide an Ethereum address.`
    });
  }
  async function normalizeSignSenderAddress(address, req) {
    // sender is EOA address
    if (address.toLowerCase() === eoaAddress.toLowerCase()) {
      return eoaAddress;
    }
    const [smartAccountAddress] = await handlers.getAccounts(req);
    // sender is smart account address
    if (address.toLowerCase() === smartAccountAddress.toLowerCase()) {
      // use EOA address as sender for signing
      return eoaAddress;
    }
    throw rpcErrors.invalidParams({
      message: `Invalid parameters: must provide valid sender address.`
    });
  }
  async function lookupAccounts(req, res) {
    res.result = await handlers.getAccounts(req);
  }
  async function fetchPrivateKey(req, res) {
    if (!handlers.getPrivateKey) {
      throw rpcErrors.methodNotSupported();
    }
    res.result = await handlers.getPrivateKey(req);
  }
  async function sendTransaction(req, res) {
    if (!handlers.processTransaction) {
      throw rpcErrors.methodNotSupported();
    }
    const txParams = req.params[0] || {
      from: ""
    };
    txParams.from = await validateAndNormalizeKeyholder(txParams.from, req);
    res.result = handlers.processTransaction(txParams, req);
  }
  async function signTransaction(req, res) {
    const txParams = req.params[0] || {
      from: ""
    };

    // normalize sender address
    if (txParams.from) {
      txParams.from = await normalizeSignSenderAddress(txParams.from, req);
    }
    res.result = await handlers.processSignTransaction(txParams, req);
  }
  async function ethSign(req, res) {
    let msgParams = req.params;
    const extraParams = req.params[2] || {};
    if (Array.isArray(req.params)) {
      if (!(req.params.length === 2)) throw new Error(`WalletMiddleware - incorrect params for ${req.method} method. expected [address, message]`);
      const params = req.params;
      const address = params[0];
      const message = params[1];
      msgParams = {
        from: address,
        data: message
      };
    }
    msgParams = _objectSpread(_objectSpread({}, extraParams), msgParams);
    res.result = await handlers.processEthSignMessage(msgParams, req);
  }
  async function signTypedDataV4(req, res) {
    if (!(req !== null && req !== void 0 && req.params)) throw new Error("WalletMiddleware - missing params");
    let msgParams = req.params;
    if (Array.isArray(req.params)) {
      if (!(req.params.length === 2)) throw new Error(`WalletMiddleware - incorrect params for ${req.method} method. expected [address, typedData]`);
      const params = req.params;
      const address = params[0];
      const message = params[1];
      msgParams = {
        from: address,
        data: message
      };
    }
    res.result = await handlers.processTypedMessageV4(msgParams, req);
  }
  async function personalSign(req, res) {
    let msgParams = req.params;
    const extraParams = req.params[2] || {};
    if (Array.isArray(req.params)) {
      if (!(req.params.length >= 2)) throw new Error(`WalletMiddleware - incorrect params for ${req.method} method. expected [message, address]`);
      const params = req.params;
      if (typeof params[0] === "object") {
        const {
          challenge,
          address
        } = params[0];
        msgParams = {
          from: address,
          data: challenge
        };
      } else {
        const message = params[0];
        const address = params[1];
        msgParams = {
          from: address,
          data: message
        };
      }
    }
    msgParams = _objectSpread(_objectSpread({}, extraParams), msgParams);
    res.result = await handlers.processPersonalMessage(msgParams, req);
  }
  async function fetchPublicKey(req, res) {
    if (!handlers.getPublicKey) {
      throw rpcErrors.methodNotSupported();
    }
    res.result = await handlers.getPublicKey(req);
  }
  return createScaffoldMiddleware({
    // account lookups
    eth_accounts: createAsyncMiddleware(lookupAccounts),
    eth_requestAccounts: createAsyncMiddleware(lookupAccounts),
    eth_private_key: createAsyncMiddleware(fetchPrivateKey),
    private_key: createAsyncMiddleware(fetchPrivateKey),
    eth_public_key: createAsyncMiddleware(fetchPublicKey),
    public_key: createAsyncMiddleware(fetchPublicKey),
    // tx signatures
    eth_sendTransaction: createAsyncMiddleware(sendTransaction),
    eth_signTransaction: createAsyncMiddleware(signTransaction),
    // message signatures
    eth_sign: createAsyncMiddleware(ethSign),
    eth_signTypedData_v4: createAsyncMiddleware(signTypedDataV4),
    personal_sign: createAsyncMiddleware(personalSign)
  });
}
async function createEoaMiddleware({
  aaProvider
}) {
  async function getAccounts(_req, res) {
    const [, eoaAddress] = await aaProvider.request({
      method: METHOD_TYPES.GET_ACCOUNTS
    });
    res.result = [eoaAddress];
  }
  async function requestAccounts(_req, res) {
    const [, eoaAddress] = await aaProvider.request({
      method: METHOD_TYPES.ETH_REQUEST_ACCOUNTS
    });
    res.result = [eoaAddress];
  }
  return createScaffoldMiddleware({
    eth_accounts: createAsyncMiddleware(getAccounts),
    eth_requestAccounts: createAsyncMiddleware(requestAccounts)
  });
}
function providerAsMiddleware(provider) {
  return async (req, res, _next, end) => {
    // send request to provider
    try {
      const providerRes = await provider.request(req);
      res.result = providerRes;
      return end();
    } catch (error) {
      return end(error);
    }
  };
}

export { createAaMiddleware, createEoaMiddleware, providerAsMiddleware };
