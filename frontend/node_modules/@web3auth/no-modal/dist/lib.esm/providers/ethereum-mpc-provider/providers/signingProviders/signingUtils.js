import _objectSpread from '@babel/runtime/helpers/objectSpread2';
import { publicToAddress, toBytes, isHexString, stripHexPrefix, intToBytes } from '@ethereumjs/util';
import { concatSig } from '@toruslabs/base-controllers';
import { providerErrors } from '@web3auth/auth';
import { hashMessage, Signature } from 'ethers';
import { validateTypedData, hexToBytes, hashTypedData } from 'viem';
import { validateTypedSignMessageDataV4 } from '../../../ethereum-provider/providers/privateKeyProviders/TransactionFormatter/utils.js';
import { SignTypedDataVersion } from '../../../ethereum-provider/providers/privateKeyProviders/TransactionFormatter/interfaces.js';
import { log } from '../../../../base/loglevel.js';

async function signTx(txParams, sign, txFormatter) {
  const {
    Transaction
  } = await import('ethers');
  const finalTxParams = await txFormatter.formatTransaction(txParams);
  const ethTx = Transaction.from(_objectSpread(_objectSpread({}, finalTxParams), {}, {
    from: undefined // from is already calculated inside Transaction.from and is not allowed to be passed in
  }));
  const msgHash = stripHexPrefix(ethTx.unsignedHash);
  const vrs = await sign(Buffer.from(msgHash, "hex"));
  let {
    v
  } = vrs;
  const {
    r,
    s
  } = vrs;

  // mpc-core-kit workaround (revert back to 0/1)
  if (v > 1) {
    v = v - 27;
  }

  // addSignature will handle the v value
  const tx = ethTx;
  tx.signature = Signature.from({
    v,
    r: `0x${r.toString("hex")}`,
    s: `0x${s.toString("hex")}`
  });
  return tx.serialized;
}
async function signMessage(sign, data) {
  const message = stripHexPrefix(data);
  const msgSig = await sign(Buffer.from(message, "hex"));
  let modifiedV = msgSig.v;
  if (modifiedV <= 1) {
    modifiedV = modifiedV + 27;
  }
  const rawMsgSig = concatSig(Buffer.from(intToBytes(modifiedV)), msgSig.r, msgSig.s);
  return rawMsgSig;
}
async function personalSign(sign, data) {
  if (data === null || data === undefined) {
    throw new Error("Missing data parameter");
  }
  // we need to check if the data is hex or not
  // For historical reasons, you must submit the message to sign in hex-encoded UTF-8.
  // https://docs.metamask.io/wallet/how-to/sign-data/#use-personal_sign
  const message = isHexString(data) ? Buffer.from(stripHexPrefix(data), "hex") : Buffer.from(data);
  const msgHash = hashMessage(message);
  const prefix = Buffer.from(`\u0019Ethereum Signed Message:\n${message.length}`, "utf-8");
  const sig = await sign(Buffer.from(msgHash.slice(2), "hex"), Buffer.concat([prefix, message]));
  let modifiedV = sig.v;
  if (modifiedV <= 1) {
    modifiedV = modifiedV + 27;
  }
  const serialized = concatSig(Buffer.from(toBytes(modifiedV)), sig.r, sig.s);
  return serialized;
}
function validateVersion(version, allowedVersions) {
  if (!Object.keys(SignTypedDataVersion).includes(version)) {
    throw new Error(`Invalid version: '${version}'`);
  }
}
async function signTypedData(sign, data, version) {
  validateVersion(version); // Note: this is intentional;
  if (data === null || data === undefined) {
    throw new Error("Missing data parameter");
  }
  const message = typeof data === "string" ? JSON.parse(data) : data;
  validateTypedData(message);
  const {
    v,
    r,
    s
  } = await sign(Buffer.from(hexToBytes(hashTypedData(message))));
  let modifiedV = v;
  if (modifiedV <= 1) {
    modifiedV = modifiedV + 27;
  }
  return concatSig(Buffer.from(toBytes(modifiedV)), r, s);
}
function getProviderHandlers({
  txFormatter,
  sign,
  getPublic,
  getProviderEngineProxy
}) {
  return {
    getAccounts: async _ => {
      const pubKey = await getPublic();
      return [`0x${Buffer.from(publicToAddress(pubKey)).toString("hex")}`];
    },
    getPrivateKey: async _ => {
      throw providerErrors.custom({
        message: "MPC Provider cannot return private key",
        code: 4902
      });
    },
    getPublicKey: async _ => {
      const pubKey = await getPublic();
      return `0x${pubKey.toString("hex")}`;
    },
    processTransaction: async (txParams, _) => {
      const providerEngineProxy = getProviderEngineProxy();
      if (!providerEngineProxy) throw providerErrors.custom({
        message: "Provider is not initialized",
        code: 4902
      });
      const serializedTxn = await signTx(txParams, sign, txFormatter);
      const txHash = await providerEngineProxy.request({
        method: "eth_sendRawTransaction",
        params: [serializedTxn]
      });
      return txHash;
    },
    processSignTransaction: async (txParams, _) => {
      const providerEngineProxy = getProviderEngineProxy();
      if (!providerEngineProxy) throw providerErrors.custom({
        message: "Provider is not initialized",
        code: 4902
      });
      const serializedTxn = await signTx(txParams, sign, txFormatter);
      return serializedTxn;
    },
    processEthSignMessage: async (msgParams, _) => {
      const rawMessageSig = signMessage(sign, msgParams.data);
      return rawMessageSig;
    },
    processPersonalMessage: async (msgParams, _) => {
      const sig = personalSign(sign, msgParams.data);
      return sig;
    },
    processTypedMessageV4: async (msgParams, _) => {
      log.debug("processTypedMessageV4", msgParams);
      const providerEngineProxy = getProviderEngineProxy();
      if (!providerEngineProxy) throw providerErrors.custom({
        message: "Provider is not initialized",
        code: 4902
      });
      const chainId = await providerEngineProxy.request({
        method: "eth_chainId"
      });
      await validateTypedSignMessageDataV4(msgParams, chainId);
      const data = typeof msgParams.data === "string" ? JSON.parse(msgParams.data) : msgParams.data;
      const sig = signTypedData(sign, data, SignTypedDataVersion.V4);
      return sig;
    }
  };
}

export { getProviderHandlers };
