import _objectSpread from '@babel/runtime/helpers/objectSpread2';
import _defineProperty from '@babel/runtime/helpers/defineProperty';
import { BaseController, createEventEmitterProxy } from '@toruslabs/base-controllers';
import { rpcErrors } from '@web3auth/auth';
import { EIP1193_EVENTS } from './utils.js';
import { WalletInitializationError, WalletProviderError } from '../../base/errors/index.js';

class BaseProvider extends BaseController {
  constructor({
    config,
    state
  }) {
    super({
      config,
      state
    });
    // should be Assigned in setupProvider
    _defineProperty(this, "_providerEngineProxy", null);
    // set to true when the keyExportEnabled flag is set by code.
    // This is to prevent the flag from being overridden by the dashboard config.
    _defineProperty(this, "keyExportFlagSetByCode", false);
    const {
      chain
    } = config;
    if (!chain) throw WalletInitializationError.invalidProviderConfigError("Please provide chain");
    if (!chain.chainId) throw WalletInitializationError.invalidProviderConfigError("Please provide chainId inside chain");
    if (!chain.rpcTarget) throw WalletInitializationError.invalidProviderConfigError("Please provide rpcTarget inside chain");
    if (typeof config.keyExportEnabled === "boolean") this.keyExportFlagSetByCode = true;
    this.defaultState = {
      chainId: "loading"
    };
    this.defaultConfig = {
      chain: config.chain,
      chains: config.chains,
      keyExportEnabled: typeof config.keyExportEnabled === "boolean" ? config.keyExportEnabled : true
    };
    super.initialize();
  }
  get currentChain() {
    return this.config.chains.find(chain => chain.chainId === this.state.chainId);
  }
  get provider() {
    return this._providerEngineProxy;
  }
  get chainId() {
    return this.state.chainId;
  }
  set provider(_) {
    throw new Error("Method not implemented.");
  }
  async request(args) {
    var _this$provider;
    if (!args || typeof args !== "object" || Array.isArray(args)) {
      throw rpcErrors.invalidRequest({
        message: WalletProviderError.invalidRequestArgs().message,
        data: _objectSpread(_objectSpread({}, args || {}), {}, {
          cause: WalletProviderError.invalidRequestArgs().message
        })
      });
    }
    const {
      method,
      params
    } = args;
    if (typeof method !== "string" || method.length === 0) {
      throw rpcErrors.invalidRequest({
        message: WalletProviderError.invalidRequestMethod().message,
        data: _objectSpread(_objectSpread({}, args || {}), {}, {
          cause: WalletProviderError.invalidRequestMethod().message
        })
      });
    }
    if (params !== undefined && !Array.isArray(params) && (typeof params !== "object" || params === null)) {
      throw rpcErrors.invalidRequest({
        message: WalletProviderError.invalidRequestParams().message,
        data: _objectSpread(_objectSpread({}, args || {}), {}, {
          cause: WalletProviderError.invalidRequestParams().message
        })
      });
    }
    return (_this$provider = this.provider) === null || _this$provider === void 0 ? void 0 : _this$provider.request(args);
  }
  sendAsync(req, callback) {
    if (callback) return this.send(req, callback);
    return this.request(req);
  }
  send(req, callback) {
    this.request(req).then(res => callback(null, {
      result: res
    })).catch(err => callback(err, null));
  }
  updateProviderEngineProxy(provider) {
    if (this._providerEngineProxy) {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      this._providerEngineProxy.setTarget(provider);

      // we want events to propagate from Ethereum provider -> wrapper provider (e.g. CommonJRPC provider) -> SDK -> dapp
      // ensure that only one handler is added for each event
      const reEmitHandler = event => {
        // skip newListener event
        if (event === "newListener") return;

        // listen to the event from the Ethereum provider
        provider.on(event, (...args) => {
          // handle chainChanged event: update chainId state
          if (event === EIP1193_EVENTS.CHAIN_CHANGED) {
            const chainId = args[0];
            this.update({
              chainId
            });
          }

          // re-emit the event
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          this.emit(event, ...args);
        });
      };

      // handle existing events
      this.eventNames().forEach(event => {
        reEmitHandler(event);
      });
      // handle when a new listener is added
      this.on("newListener", event => {
        // skip if the event already exists
        if (this.listenerCount(event) > 0) return;
        reEmitHandler(event);
      });
    } else {
      this._providerEngineProxy = createEventEmitterProxy(provider);
    }
  }
  setKeyExportFlag(flag) {
    if (!this.keyExportFlagSetByCode) {
      this.configure({
        keyExportEnabled: flag
      });
    }
  }
  getProviderEngineProxy() {
    return this._providerEngineProxy;
  }
  getChain(chainId) {
    return this.config.chains.find(chain => chain.chainId === chainId);
  }
}

export { BaseProvider };
