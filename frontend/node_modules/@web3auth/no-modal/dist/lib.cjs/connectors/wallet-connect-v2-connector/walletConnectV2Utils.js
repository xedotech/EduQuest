'use strict';

var _objectSpread = require('@babel/runtime/helpers/objectSpread2');
var bs58 = require('@toruslabs/bs58');
var utils = require('@walletconnect/utils');
var auth = require('@web3auth/auth');
var wsEmbed = require('@web3auth/ws-embed');
require('@babel/runtime/helpers/defineProperty');
require('@segment/analytics-next');
require('../../base/loglevel.js');
require('@toruslabs/base-controllers');
var index = require('../../base/errors/index.js');
require('../../base/wallet/index.js');
require('../../base/connector/constants.js');
require('jwt-decode');
var constants = require('../../base/constants.js');
require('../../base/plugin/errors.js');
require('../../base/plugin/IPlugin.js');
require('@toruslabs/constants');
require('@toruslabs/http-helpers');

async function getLastActiveSession(signClient) {
  if (signClient.session.length) {
    const lastKeyIndex = signClient.session.keys.length - 1;
    return signClient.session.get(signClient.session.keys[lastKeyIndex]);
  }
  return null;
}
function isMobileDevice() {
  return /Mobi|Android|iPhone|iPad|iPod|Opera Mini|IEMobile|WPDesktop/i.test(window.navigator.userAgent);
}
function isSolanaChain(chainId) {
  return chainId.startsWith("solana:");
}
async function sendJrpcRequest(signClient, chainId, method, params) {
  const session = await getLastActiveSession(signClient);
  if (!session) {
    throw auth.providerErrors.disconnected();
  }
  if (typeof window !== "undefined" && isMobileDevice()) {
    if (session.peer.metadata.redirect && session.peer.metadata.redirect.native) {
      window.open(session.peer.metadata.redirect.native, "_blank");
    }
  }
  return signClient.request({
    topic: session.topic,
    chainId,
    request: {
      method,
      params: isSolanaChain(chainId) ? _objectSpread(_objectSpread({}, params), {}, {
        pubkey: session.self.publicKey
      }) : params
    }
  });
}
async function getAccounts(signClient) {
  const session = await getLastActiveSession(signClient);
  if (!session) {
    throw auth.providerErrors.disconnected();
  }
  const accounts = utils.getAccountsFromNamespaces(session.namespaces);
  if (accounts && accounts.length) {
    return [...new Set(accounts.map(add => {
      return utils.parseAccountId(add).address;
    }))];
  }
  throw index.WalletLoginError.connectionError("Failed to get accounts");
}
function getEthProviderHandlers({
  connector,
  chainId
}) {
  return {
    getPrivateKey: async () => {
      throw auth.rpcErrors.methodNotSupported();
    },
    getPublicKey: async () => {
      throw auth.rpcErrors.methodNotSupported();
    },
    getAccounts: async _ => {
      return getAccounts(connector);
    },
    processTransaction: async (txParams, _) => {
      const methodRes = await sendJrpcRequest(connector, `eip155:${chainId}`, wsEmbed.EVM_METHOD_TYPES.ETH_TRANSACTION, [txParams]);
      return methodRes;
    },
    processSignTransaction: async (txParams, _) => {
      const methodRes = await sendJrpcRequest(connector, `eip155:${chainId}`, "eth_signTransaction", [txParams]);
      return methodRes;
    },
    processEthSignMessage: async (msgParams, _) => {
      const methodRes = await sendJrpcRequest(connector, `eip155:${chainId}`, wsEmbed.EVM_METHOD_TYPES.ETH_SIGN, [msgParams.from, msgParams.data]);
      return methodRes;
    },
    processPersonalMessage: async (msgParams, _) => {
      const methodRes = await sendJrpcRequest(connector, `eip155:${chainId}`, wsEmbed.EVM_METHOD_TYPES.PERSONAL_SIGN, [msgParams.data, msgParams.from]);
      return methodRes;
    },
    processTypedMessageV4: async msgParams => {
      const methodRes = await sendJrpcRequest(connector, `eip155:${chainId}`, wsEmbed.EVM_METHOD_TYPES.ETH_SIGN_TYPED_DATA_V4, [msgParams.from, msgParams.data]);
      return methodRes;
    }
  };
}
function getSolProviderHandlers({
  connector,
  chainId
}) {
  return {
    requestAccounts: async _ => {
      return getAccounts(connector);
    },
    getPrivateKey: async () => {
      throw auth.rpcErrors.methodNotSupported();
    },
    getSecretKey: async () => {
      throw auth.rpcErrors.methodNotSupported();
    },
    getPublicKey: async () => {
      throw auth.rpcErrors.methodNotSupported();
    },
    getAccounts: async _ => {
      return getAccounts(connector);
    },
    signAllTransactions: async _ => {
      throw auth.rpcErrors.methodNotSupported();
    },
    signAndSendTransaction: async _ => {
      throw auth.rpcErrors.methodNotSupported();
    },
    signMessage: async req => {
      const methodRes = await sendJrpcRequest(connector, `solana:${constants.SOLANA_CAIP_CHAIN_MAP[chainId]}`, wsEmbed.SOLANA_METHOD_TYPES.SIGN_MESSAGE, {
        message: bs58.bs58.encode(Buffer.from(req.params.data, "utf-8"))
      });
      return methodRes.signature;
    },
    signTransaction: async req => {
      const accounts = await getAccounts(connector);
      if (accounts.length === 0) {
        throw auth.providerErrors.disconnected();
      }
      const methodRes = await sendJrpcRequest(connector, `solana:${constants.SOLANA_CAIP_CHAIN_MAP[chainId]}`, wsEmbed.SOLANA_METHOD_TYPES.SIGN_TRANSACTION, {
        transaction: req.params.message
      });
      return methodRes.signature;
    }
  };
}
async function switchChain({
  connector,
  chainId,
  newChainId
}) {
  await sendJrpcRequest(connector, `eip155:${chainId}`, "wallet_switchEthereumChain", [{
    chainId: newChainId
  }]);
}

exports.getAccounts = getAccounts;
exports.getEthProviderHandlers = getEthProviderHandlers;
exports.getSolProviderHandlers = getSolProviderHandlers;
exports.sendJrpcRequest = sendJrpcRequest;
exports.switchChain = switchChain;
