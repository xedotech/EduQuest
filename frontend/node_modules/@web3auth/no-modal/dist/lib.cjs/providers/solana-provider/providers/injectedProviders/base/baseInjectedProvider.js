'use strict';

var auth = require('@web3auth/auth');
require('@babel/runtime/helpers/objectSpread2');
require('@babel/runtime/helpers/defineProperty');
require('@segment/analytics-next');
require('../../../../../base/loglevel.js');
require('@toruslabs/base-controllers');
var index = require('../../../../../base/errors/index.js');
require('../../../../../base/wallet/index.js');
require('../../../../../base/connector/constants.js');
require('jwt-decode');
require('../../../../../base/plugin/errors.js');
require('../../../../../base/plugin/IPlugin.js');
require('@toruslabs/constants');
require('@toruslabs/http-helpers');
var baseProvider = require('../../../../base-provider/baseProvider.js');
require('../../../../base-provider/CommonJRPCProvider.js');
require('../../../../base-provider/commonPrivateKeyProvider.js');
require('../../../../base-provider/utils.js');
var JrpcClient = require('../../../rpc/JrpcClient.js');
var solanaRpcMiddlewares = require('../../../rpc/solanaRpcMiddlewares.js');

class BaseInjectedProvider extends baseProvider.BaseProvider {
  constructor({
    config,
    state
  }) {
    super({
      config,
      state
    });
  }
  async switchChain(_) {
    throw index.WalletLoginError.unsupportedOperation("Chain switching is not supported by this connector");
  }
  async setupProvider(injectedProvider, chainId) {
    const engine = new auth.JRPCEngine();
    const chain = this.getChain(chainId);
    const providerHandlers = this.getProviderHandlers(injectedProvider);
    const solanaMiddleware = solanaRpcMiddlewares.createSolanaMiddleware(providerHandlers);
    engine.push(solanaMiddleware);
    const configMiddleware = JrpcClient.createConfigMiddleware(chain);
    engine.push(configMiddleware);
    const injectedProviderProxy = this.getInjectedProviderProxy(injectedProvider);
    if (injectedProviderProxy) {
      engine.push(injectedProviderProxy);
    }
    const provider = auth.providerFromEngine(engine);
    this.updateProviderEngineProxy(provider);
    await this.lookupNetwork(injectedProvider, chainId);
  }
  async lookupNetwork(_injectedProvider, chainId) {
    this.update({
      chainId
    });
    return chainId || "";
  }
  getInjectedProviderProxy(_) {
    return undefined;
  }
}

exports.BaseInjectedProvider = BaseInjectedProvider;
