'use strict';

var _objectSpread = require('@babel/runtime/helpers/objectSpread2');
var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var ethereumControllers = require('@toruslabs/ethereum-controllers');
var auth = require('@web3auth/auth');
var viem = require('viem');
var accountAbstraction = require('viem/account-abstraction');
require('@segment/analytics-next');
require('../../../base/loglevel.js');
var baseControllers = require('@toruslabs/base-controllers');
var index = require('../../../base/errors/index.js');
require('../../../base/wallet/index.js');
require('../../../base/connector/constants.js');
require('jwt-decode');
require('../../../base/plugin/errors.js');
require('../../../base/plugin/IPlugin.js');
require('@toruslabs/constants');
require('@toruslabs/http-helpers');
var baseProvider = require('../../base-provider/baseProvider.js');
require('../../base-provider/CommonJRPCProvider.js');
require('../../base-provider/commonPrivateKeyProvider.js');
require('../../base-provider/utils.js');
var ethRpcMiddlewares = require('../rpc/ethRpcMiddlewares.js');
var utils = require('./utils.js');

var _AccountAbstractionProvider;
class AccountAbstractionProvider extends baseProvider.BaseProvider {
  constructor({
    config,
    state
  }) {
    super({
      config,
      state
    });
    _defineProperty(this, "PROVIDER_CHAIN_NAMESPACE", baseControllers.CHAIN_NAMESPACES.EIP155);
    _defineProperty(this, "_smartAccount", void 0);
    _defineProperty(this, "_publicClient", void 0);
    _defineProperty(this, "_bundlerClient", void 0);
    _defineProperty(this, "_paymasterClient", void 0);
    _defineProperty(this, "_useProviderAsTransport", void 0);
    this.update({
      chainId: config.chain.chainId
    });
  }
  get smartAccount() {
    return this._smartAccount;
  }
  get bundlerClient() {
    return this._bundlerClient;
  }
  get paymasterClient() {
    return this._paymasterClient;
  }
  get publicClient() {
    return this._publicClient;
  }
  async enable() {
    if (!this.state.eoaProvider) throw auth.providerErrors.custom({
      message: "eoaProvider is not found in state, please pass it",
      code: 4902
    });
    await this.setupProvider(this.state.eoaProvider);
    return this._providerEngineProxy.request({
      method: "eth_accounts"
    });
  }
  async setupProvider(eoaProvider) {
    var _bundlerConfig$transp;
    const {
      currentChain
    } = this;
    const {
      chainNamespace
    } = currentChain;
    if (chainNamespace !== this.PROVIDER_CHAIN_NAMESPACE) throw index.WalletInitializationError.incompatibleChainNameSpace("Invalid chain namespace");
    const bundlerAndPaymasterConfig = this.config.smartAccountChainsConfig.find(config => config.chainId === currentChain.chainId);
    if (!bundlerAndPaymasterConfig) throw index.WalletInitializationError.invalidProviderConfigError(`Bundler and paymaster config not found for chain ${currentChain.chainId}`);
    const {
      bundlerConfig,
      paymasterConfig
    } = bundlerAndPaymasterConfig;
    const chain = viem.defineChain({
      id: Number.parseInt(currentChain.chainId, 16),
      // id in number form
      name: currentChain.displayName,
      rpcUrls: {
        default: {
          http: [currentChain.rpcTarget],
          webSocket: [currentChain.wsTarget]
        }
      },
      blockExplorers: currentChain.blockExplorerUrl ? {
        default: {
          name: "explorer",
          // TODO: correct name if chain config has it
          url: currentChain.blockExplorerUrl
        }
      } : undefined,
      nativeCurrency: {
        name: currentChain.tickerName,
        symbol: currentChain.ticker,
        decimals: currentChain.decimals || 18
      }
    });
    // setup public client for viem smart account
    this._publicClient = viem.createPublicClient({
      chain,
      transport: viem.http(currentChain.rpcTarget)
    });
    const [eoaAddress] = await eoaProvider.request({
      method: ethereumControllers.METHOD_TYPES.ETH_REQUEST_ACCOUNTS
    });
    const walletClient = viem.createWalletClient({
      account: eoaAddress,
      chain,
      transport: viem.custom(eoaProvider)
    });
    this._smartAccount = await this.config.smartAccountInit.getSmartAccount({
      walletClient,
      client: this._publicClient
    });
    // setup bundler and paymaster
    if (paymasterConfig) {
      var _paymasterConfig$tran;
      this._paymasterClient = accountAbstraction.createPaymasterClient(_objectSpread(_objectSpread({}, paymasterConfig), {}, {
        transport: this._useProviderAsTransport ? viem.custom(eoaProvider) : (_paymasterConfig$tran = paymasterConfig.transport) !== null && _paymasterConfig$tran !== void 0 ? _paymasterConfig$tran : viem.http(paymasterConfig.url)
      }));
    }
    this._bundlerClient = accountAbstraction.createBundlerClient(_objectSpread(_objectSpread({}, bundlerConfig), {}, {
      account: this.smartAccount,
      client: this._publicClient,
      transport: this._useProviderAsTransport ? viem.custom(eoaProvider) : (_bundlerConfig$transp = bundlerConfig.transport) !== null && _bundlerConfig$transp !== void 0 ? _bundlerConfig$transp : viem.http(bundlerConfig.url),
      paymaster: this._paymasterClient
    }));
    const providerHandlers = utils.getProviderHandlers({
      bundlerClient: this._bundlerClient,
      smartAccount: this._smartAccount,
      chain,
      eoaProvider
    });
    // setup rpc engine and AA middleware
    const engine = new auth.JRPCEngine();
    const aaMiddleware = await ethRpcMiddlewares.createAaMiddleware({
      eoaProvider,
      handlers: providerHandlers
    });
    engine.push(aaMiddleware);
    const eoaMiddleware = ethRpcMiddlewares.providerAsMiddleware(eoaProvider);
    engine.push(eoaMiddleware);
    const provider = auth.providerFromEngine(engine);
    this.updateProviderEngineProxy(provider);
    eoaProvider.once("chainChanged", chainId => {
      this.update({
        chainId
      });
      this.setupChainSwitchMiddleware();
      this.emit("chainChanged", chainId);
    });
  }
  async updateAccount(_params) {
    throw auth.providerErrors.unsupportedMethod("updateAccount. Please call it on eoaProvider");
  }
  async switchChain(_params) {
    throw auth.providerErrors.unsupportedMethod("switchChain. Please call it on eoaProvider");
  }
  async lookupNetwork() {
    throw auth.providerErrors.unsupportedMethod("lookupNetwork. Please call it on eoaProvider");
  }
  async setupChainSwitchMiddleware() {
    return this.setupProvider(this.state.eoaProvider);
  }
}
_AccountAbstractionProvider = AccountAbstractionProvider;
_defineProperty(AccountAbstractionProvider, "getProviderInstance", async params => {
  const providerInstance = new _AccountAbstractionProvider({
    config: params
  });
  providerInstance._useProviderAsTransport = params.useProviderAsTransport;
  await providerInstance.setupProvider(params.eoaProvider);
  providerInstance.update({
    eoaProvider: params.eoaProvider
  });
  return providerInstance;
});
const accountAbstractionProvider = async ({
  accountAbstractionConfig,
  chain,
  chains,
  provider,
  useProviderAsTransport
}) => {
  let smartAccountInit;
  const {
    smartAccountType,
    chains: smartAccountChainsConfig
  } = accountAbstractionConfig;
  const {
    smartAccountConfig
  } = smartAccountChainsConfig.find(config => config.chainId === chain.chainId) || {};
  switch (smartAccountType) {
    case ethereumControllers.SMART_ACCOUNT.BICONOMY:
      {
        const {
          BiconomySmartAccount
        } = await import('@toruslabs/ethereum-controllers');
        smartAccountInit = new BiconomySmartAccount(smartAccountConfig);
        break;
      }
    case ethereumControllers.SMART_ACCOUNT.KERNEL:
      {
        const {
          KernelSmartAccount
        } = await import('@toruslabs/ethereum-controllers');
        smartAccountInit = new KernelSmartAccount(smartAccountConfig);
        break;
      }
    case ethereumControllers.SMART_ACCOUNT.NEXUS:
      {
        const {
          NexusSmartAccount
        } = await import('@toruslabs/ethereum-controllers');
        smartAccountInit = new NexusSmartAccount(smartAccountConfig);
        break;
      }
    case ethereumControllers.SMART_ACCOUNT.SAFE:
      {
        const {
          SafeSmartAccount
        } = await import('@toruslabs/ethereum-controllers');
        smartAccountInit = new SafeSmartAccount(smartAccountConfig);
        break;
      }
    case ethereumControllers.SMART_ACCOUNT.TRUST:
      {
        const {
          TrustSmartAccount
        } = await import('@toruslabs/ethereum-controllers');
        smartAccountInit = new TrustSmartAccount(smartAccountConfig);
        break;
      }
    case ethereumControllers.SMART_ACCOUNT.METAMASK:
      {
        const {
          MetamaskSmartAccount
        } = await import('@toruslabs/ethereum-controllers');
        smartAccountInit = new MetamaskSmartAccount(smartAccountConfig);
        break;
      }
    default:
      throw new Error("Smart account type not supported");
  }
  return AccountAbstractionProvider.getProviderInstance({
    eoaProvider: provider,
    smartAccountInit,
    chain,
    chains,
    smartAccountChainsConfig,
    useProviderAsTransport
  });
};
const toEoaProvider = async aaProvider => {
  // derive EOA provider from AA provider
  const engine = new auth.JRPCEngine();
  const eoaMiddleware = await ethRpcMiddlewares.createEoaMiddleware({
    aaProvider
  });
  engine.push(eoaMiddleware);
  engine.push(ethRpcMiddlewares.providerAsMiddleware(aaProvider));
  return auth.providerFromEngine(engine);
};

Object.defineProperty(exports, "SMART_ACCOUNT", {
    enumerable: true,
    get: function () { return ethereumControllers.SMART_ACCOUNT; }
});
exports.accountAbstractionProvider = accountAbstractionProvider;
exports.toEoaProvider = toEoaProvider;
