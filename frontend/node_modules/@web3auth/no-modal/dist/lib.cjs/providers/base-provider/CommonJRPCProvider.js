'use strict';

var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var auth = require('@web3auth/auth');
var baseProvider = require('./baseProvider.js');
var jrpcClient = require('./jrpcClient.js');

var _CommonJRPCProvider;
class CommonJRPCProvider extends baseProvider.BaseProvider {
  constructor({
    config,
    state
  }) {
    super({
      config,
      state
    });
  }
  async setupProvider(chainId) {
    const chain = this.getChain(chainId);
    if (!chain) throw auth.providerErrors.custom({
      message: "Chain not found",
      code: 4902
    });
    const {
      networkMiddleware
    } = jrpcClient.createJsonRpcClient(chain);
    const engine = new auth.JRPCEngine();
    engine.push(networkMiddleware);
    const provider = auth.providerFromEngine(engine);
    this.updateProviderEngineProxy(provider);
    this.emit("chainChanged", chainId);
    this.emit("connect", {
      chainId
    });
    this.update({
      chainId
    });
  }
  async switchChain(params) {
    if (!this._providerEngineProxy) throw auth.providerErrors.custom({
      message: "Provider is not initialized",
      code: 4902
    });
    const newChainId = params.chainId;
    if (this.chainId === newChainId) return;
    this.update({
      chainId: "loading"
    });
    await this.setupProvider(newChainId);
  }
  getProviderEngineProxy() {
    return this._providerEngineProxy;
  }
  lookupNetwork() {
    throw new Error("Method not implemented.");
  }
}
_CommonJRPCProvider = CommonJRPCProvider;
_defineProperty(CommonJRPCProvider, "getProviderInstance", async params => {
  const providerFactory = new _CommonJRPCProvider({
    config: {
      chain: params.chain,
      chains: params.chains
    }
  });
  const {
    chainId
  } = params.chain;
  await providerFactory.setupProvider(chainId);
  return providerFactory;
});

exports.CommonJRPCProvider = CommonJRPCProvider;
