'use strict';

var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var auth = require('@web3auth/auth');
require('@babel/runtime/helpers/objectSpread2');
require('@segment/analytics-next');
require('../../base/loglevel.js');
require('@toruslabs/base-controllers');
require('../../base/errors/index.js');
var index = require('../../base/wallet/index.js');
var constants = require('../../base/connector/constants.js');
require('jwt-decode');
var errors = require('../../base/plugin/errors.js');
var IPlugin = require('../../base/plugin/IPlugin.js');
require('@toruslabs/constants');
require('@toruslabs/http-helpers');
var embed = require('./embed.js');

class NFTCheckoutPlugin extends auth.SafeEventEmitter {
  constructor(params) {
    super();
    _defineProperty(this, "name", IPlugin.EVM_PLUGINS.NFT_CHECKOUT);
    _defineProperty(this, "status", IPlugin.PLUGIN_STATUS.DISCONNECTED);
    _defineProperty(this, "SUPPORTED_CONNECTORS", Object.values(index.WALLET_CONNECTORS));
    _defineProperty(this, "pluginNamespace", IPlugin.PLUGIN_NAMESPACES.EIP155);
    _defineProperty(this, "web3auth", null);
    _defineProperty(this, "nftCheckoutEmbedInstance", null);
    _defineProperty(this, "isInitialized", false);
    _defineProperty(this, "receiverAddress", null);
    this.nftCheckoutEmbedInstance = new embed.NFTCheckoutEmbed(params);
  }
  async initWithWeb3Auth(web3auth, whiteLabel) {
    if (this.isInitialized) return;
    if (!web3auth) throw errors.NFTCheckoutPluginError.web3authRequired();
    this.web3auth = web3auth;
    await this.nftCheckoutEmbedInstance.init({
      whiteLabel
    });
    this.isInitialized = true;
    this.status = IPlugin.PLUGIN_STATUS.READY;
    this.emit(IPlugin.PLUGIN_EVENTS.READY);
  }
  async connect() {
    if (!this.isInitialized) throw errors.NFTCheckoutPluginError.notInitialized();
    this.emit(IPlugin.PLUGIN_EVENTS.CONNECTING);
    this.status = IPlugin.PLUGIN_STATUS.CONNECTING;
    if (this.web3auth.status !== constants.CONNECTOR_STATUS.CONNECTED) throw errors.NFTCheckoutPluginError.web3AuthNotConnected();
    if (!this.web3auth.provider) throw errors.NFTCheckoutPluginError.providerRequired();
    const accounts = await this.web3auth.provider.request({
      method: "eth_accounts"
    });
    if (accounts.length === 0) throw errors.NFTCheckoutPluginError.web3AuthNotConnected();
    this.receiverAddress = accounts[0];
    this.emit(IPlugin.PLUGIN_EVENTS.CONNECTED);
    this.status = IPlugin.PLUGIN_STATUS.CONNECTED;
  }
  async show({
    contractId
  }) {
    if (this.status !== IPlugin.PLUGIN_STATUS.CONNECTED) errors.NFTCheckoutPluginError.pluginNotConnected();
    return this.nftCheckoutEmbedInstance.show({
      receiverAddress: this.receiverAddress,
      contractId
    });
  }
  disconnect() {
    if (this.status !== IPlugin.PLUGIN_STATUS.CONNECTED) errors.NFTCheckoutPluginError.pluginNotConnected();
    this.emit(IPlugin.PLUGIN_EVENTS.DISCONNECTED);
    this.status = IPlugin.PLUGIN_STATUS.DISCONNECTED;
    return Promise.resolve();
  }
  cleanup() {
    this.nftCheckoutEmbedInstance.cleanup();
    this.receiverAddress = null;
    this.isInitialized = false;
    return Promise.resolve();
  }
}
const nftCheckoutPlugin = params => {
  return () => {
    return new NFTCheckoutPlugin(params);
  };
};

exports.nftCheckoutPlugin = nftCheckoutPlugin;
