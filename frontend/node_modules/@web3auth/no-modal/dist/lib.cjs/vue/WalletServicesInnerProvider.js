'use strict';

var vue = require('vue');
require('@babel/runtime/helpers/objectSpread2');
require('@babel/runtime/helpers/defineProperty');
require('@segment/analytics-next');
require('../base/loglevel.js');
require('@toruslabs/base-controllers');
require('@web3auth/auth');
require('../base/errors/index.js');
require('../base/wallet/index.js');
var constants = require('../base/connector/constants.js');
require('jwt-decode');
var errors = require('../base/plugin/errors.js');
var IPlugin = require('../base/plugin/IPlugin.js');
require('@toruslabs/constants');
require('@toruslabs/http-helpers');
var useWeb3AuthInner = require('./composables/useWeb3AuthInner.js');
var WalletServicesContext = require('./context/WalletServicesContext.js');

const WalletServicesInnerProvider = vue.defineComponent({
  name: "WalletServicesInnerProvider",
  setup() {
    const web3AuthContext = useWeb3AuthInner.useWeb3AuthInner();
    if (!web3AuthContext) throw errors.WalletServicesPluginError.fromCode(1000, "`WalletServicesProvider` must be wrapped by `Web3AuthProvider`");
    const {
      getPlugin,
      isInitialized,
      isConnected
    } = web3AuthContext;
    const walletServicesPlugin = vue.shallowRef(null);
    const ready = vue.ref(false);
    const connecting = vue.ref(false);
    vue.watch(isInitialized, newIsInitialized => {
      if (newIsInitialized) {
        const plugin = getPlugin(IPlugin.EVM_PLUGINS.WALLET_SERVICES);
        walletServicesPlugin.value = plugin;
      }
    });
    vue.watch(isConnected, newIsConnected => {
      if (newIsConnected) {
        var _walletServicesPlugin;
        const plugin = getPlugin(IPlugin.EVM_PLUGINS.WALLET_SERVICES);
        if (!walletServicesPlugin.value) walletServicesPlugin.value = plugin;
        // when rehydrating, the connectedListener may be registered after the connected event is emitted, we need to check the status here
        if (((_walletServicesPlugin = walletServicesPlugin.value) === null || _walletServicesPlugin === void 0 ? void 0 : _walletServicesPlugin.status) === constants.CONNECTOR_STATUS.CONNECTED) ready.value = true;
      }
    });
    vue.watch(walletServicesPlugin, (newWalletServicesPlugin, prevWalletServicesPlugin) => {
      const connectedListener = () => {
        ready.value = true;
      };
      const disconnectedListener = () => {
        ready.value = false;
      };
      const connectingListener = () => {
        connecting.value = true;
      };
      // unregister previous listeners
      if (prevWalletServicesPlugin && newWalletServicesPlugin !== prevWalletServicesPlugin) {
        prevWalletServicesPlugin.off(IPlugin.PLUGIN_EVENTS.CONNECTED, connectedListener);
        prevWalletServicesPlugin.off(IPlugin.PLUGIN_EVENTS.DISCONNECTED, disconnectedListener);
        prevWalletServicesPlugin.off(IPlugin.PLUGIN_EVENTS.CONNECTING, connectingListener);
      }
      if (newWalletServicesPlugin && newWalletServicesPlugin !== prevWalletServicesPlugin) {
        newWalletServicesPlugin.on(IPlugin.PLUGIN_EVENTS.CONNECTED, connectedListener);
        newWalletServicesPlugin.on(IPlugin.PLUGIN_EVENTS.DISCONNECTED, disconnectedListener);
        newWalletServicesPlugin.on(IPlugin.PLUGIN_EVENTS.CONNECTING, connectingListener);
      }
    });
    vue.provide(WalletServicesContext.WalletServicesContextKey, {
      plugin: walletServicesPlugin,
      ready,
      connecting
    });
  },
  render() {
    var _this$$slots$default;
    return vue.h((_this$$slots$default = this.$slots.default) !== null && _this$$slots$default !== void 0 ? _this$$slots$default : "");
  }
});

exports.WalletServicesInnerProvider = WalletServicesInnerProvider;
