import _defineProperty from '@babel/runtime/helpers/defineProperty';
import { BroadcastChannel } from '@toruslabs/broadcast-channel';
import log from 'loglevel';
import { POPUP_LOADED, POPUP_RESULT } from '../enums.js';
import { PopupHandler } from './PopupHandler.js';
import { broadcastChannelOptions, UserError } from '../utils/utils.js';

/**
 * PopupWithBcHandler is a PopupHandler which uses broadcast channel to communicate with the popup window.
 */
class PopupWithBcHandler extends PopupHandler {
  constructor({
    config,
    state,
    channelPrefix
  }) {
    super({
      config,
      state
    });
    _defineProperty(this, "channelPrefix", void 0);
    this.channelPrefix = channelPrefix;
  }

  /**
   * Receives the data from popup window and closes the window
   * @param successExtraFn - Extra function to be called after the data is received
   * @returns The data to be received
   */
  handle(successExtraFn) {
    const channelName = `${this.channelPrefix}_${this.config.instanceId}_${this.state.windowId}`;
    const bc = new BroadcastChannel(channelName, broadcastChannelOptions);
    return new Promise((resolve, reject) => {
      const closeListener = () => {
        bc.close();
        reject(new UserError("user closed popup"));
        this.removeListener("close", closeListener);
      };
      this.on("close", closeListener);
      bc.addEventListener("message", async ev => {
        log.info(ev, `receiving data on channel: ${bc.name}`);
        try {
          const {
            error,
            data
          } = ev;
          if (error) {
            reject(new Error(error));
            return;
          }
          if (successExtraFn) await successExtraFn.call(this, data);
          resolve(data);
        } catch (error) {
          reject(error);
        } finally {
          bc.close();
          this.close();
        }
      });
      this.open().then(() => {
        log.info(`opened window ${bc.name}`);
        // Opened window. yay.  let the bc events do their job
        return undefined;
      }).catch(err => {
        log.error(err, "something went wrong while opening window");
        reject(err);
      });
    });
  }

  /**
   * Use this if we have to send large payloads which don't fit in query/hash params.
   * Waits for ack that popup window is ready to receive data.
   * Receives the data from popup window and closes the window
   * @param payload - The data to be sent to the popup window once we have ack that window is ready to receive data
   * @param successExtraFn - Extra function to be called after the data is received
   * @returns The data to be received
   */
  handleWithHandshake(payload, successExtraFn) {
    const channelName = `${this.channelPrefix}_${this.config.instanceId}_${this.state.windowId}`;
    const bc = new BroadcastChannel(channelName, broadcastChannelOptions);
    return new Promise((resolve, reject) => {
      const closeListener = () => {
        bc.close();
        reject(new UserError("user closed popup"));
        this.removeListener("close", closeListener);
      };
      this.on("close", closeListener);
      bc.addEventListener("message", async ev => {
        try {
          log.info(ev, `receiving data on channel: ${bc.name}`);
          const {
            error,
            data
          } = ev;
          if (error) {
            reject(new Error(error));
            return;
          }
          // Do handshake
          const {
            type = ""
          } = data;
          if (type === POPUP_LOADED) {
            // Hack with generic to use the same type for both send and receive
            await bc.postMessage({
              data: payload
            });
          } else if (type === POPUP_RESULT) {
            if (successExtraFn) await successExtraFn.call(this, data);
            resolve(data);
            // Must only close the bc after result is done
            bc.close();
            this.close();
          }
        } catch (error) {
          reject(error);
          bc.close();
          this.close();
        }
      });
      this.open().then(() => {
        log.info(`opened window ${bc.name}`);
        // Opened window. yay.  let the bc events do their job
        return undefined;
      }).catch(err => {
        log.error(err, "something went wrong while opening window");
        reject(err);
      });
    });
  }
}

export { PopupWithBcHandler };
