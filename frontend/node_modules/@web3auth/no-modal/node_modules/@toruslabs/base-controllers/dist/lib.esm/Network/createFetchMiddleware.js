import _objectSpread from '@babel/runtime/helpers/objectSpread2';
import { createAsyncMiddleware, serializeError, rpcErrors } from '@web3auth/auth';
import { ANALYTICS_TRACKED_NETWORK_JPRC_METHODS, ANALYTICS_EVENTS, ANALYTICS_JRPC_REQUEST_TYPES } from './constants.js';
import { getHostname, getCaipChainId } from '../utils/utils.js';

const RETRIABLE_ERRORS = [
// ignore server overload errors
"Gateway timeout", "ETIMEDOUT",
// ignore server sent html error pages
// or truncated json responses
"failed to parse response body",
// ignore errors where http req failed to establish
"Failed to fetch"];
function checkForHttpErrors(fetchRes) {
  // check for errors
  switch (fetchRes.status) {
    case 405:
      throw rpcErrors.methodNotFound();
    case 418:
      throw rpcErrors.internal({
        message: `Request is being rate limited.`,
        data: {
          cause: fetchRes
        }
      });
    case 503:
    case 504:
      throw rpcErrors.internal({
        message: `Gateway timeout. The request took too long to process.` + `This can happen when querying over too wide a block range.`,
        data: {
          cause: fetchRes
        }
      });
  }
}
function timeout(duration) {
  return new Promise(resolve => {
    setTimeout(resolve, duration);
  });
}
function parseResponse(fetchRes, body) {
  // check for error code
  if (fetchRes.status !== 200) {
    throw rpcErrors.internal({
      message: `Non-200 status code: '${fetchRes.status}'`,
      data: body
    });
  }
  // check for rpc error
  if (body.error) {
    var _body$error;
    throw rpcErrors.internal({
      data: body.error,
      message: (_body$error = body.error) === null || _body$error === void 0 ? void 0 : _body$error.message
    });
  }
  // return successful result
  return body.result;
}
function createFetchConfigFromReq({
  req,
  rpcTarget,
  originHttpHeaderKey
}) {
  const parsedUrl = new URL(rpcTarget);

  // prepare payload
  // copy only canonical json rpc properties
  const payload = {
    id: req.id,
    jsonrpc: req.jsonrpc,
    method: req.method,
    params: req.params
  };

  // extract 'origin' parameter from request
  const originDomain = req.origin;

  // serialize request body
  const serializedPayload = JSON.stringify(payload);

  // configure fetch params
  const fetchParams = {
    method: "POST",
    headers: {
      Accept: "application/json",
      "Content-Type": "application/json"
    },
    body: serializedPayload
  };

  // optional: add request origin as header
  if (originHttpHeaderKey && originDomain) {
    fetchParams.headers[originHttpHeaderKey] = originDomain;
  }
  return {
    fetchUrl: parsedUrl.href,
    fetchParams
  };
}
function createFetchMiddleware({
  rpcTarget,
  originHttpHeaderKey,
  analytics,
  providerConfig
}) {
  return createAsyncMiddleware(async (req, res, _next) => {
    const {
      fetchUrl,
      fetchParams
    } = createFetchConfigFromReq({
      req,
      rpcTarget,
      originHttpHeaderKey
    });

    // attempt request multiple times
    const maxAttempts = 5;
    const retryInterval = 1000;
    const startTime = Date.now();
    const isSkippedAnalytics = !Object.values(ANALYTICS_TRACKED_NETWORK_JPRC_METHODS).includes(req.method);
    const trackData = {
      chain_id: getCaipChainId(providerConfig),
      chain_rpc_target: getHostname(fetchUrl),
      method: req.method
    };
    for (let attempt = 0; attempt < maxAttempts; attempt++) {
      try {
        const fetchRes = await fetch(fetchUrl, fetchParams);
        // check for http errors
        checkForHttpErrors(fetchRes);
        // parse response body
        const fetchBody = await fetchRes.json();
        const result = parseResponse(fetchRes, fetchBody);
        // set result and exit retry loop
        res.result = result;
        if (!isSkippedAnalytics) {
          analytics === null || analytics === void 0 || analytics.track(ANALYTICS_EVENTS.JRPC_REQUEST_COMPLETED, _objectSpread(_objectSpread({
            request_type: ANALYTICS_JRPC_REQUEST_TYPES.NETWORK
          }, trackData), {}, {
            duration: Date.now() - startTime
          }));
        }
        return;
      } catch (err) {
        const errMsg = (err.message || err).toString();
        const isRetriable = RETRIABLE_ERRORS.some(phrase => errMsg.includes(phrase));
        // re-throw error if not retriable
        if (!isRetriable) {
          if (!isSkippedAnalytics) {
            analytics === null || analytics === void 0 || analytics.track(ANALYTICS_EVENTS.JRPC_REQUEST_FAILED, _objectSpread(_objectSpread({
              request_type: ANALYTICS_JRPC_REQUEST_TYPES.NETWORK
            }, trackData), {}, {
              error_code: err === null || err === void 0 ? void 0 : err.code,
              error_message: errMsg,
              duration: Date.now() - startTime
            }));
          }
          const error = await serializeError(err);
          throw error;
        }
      }
      // delay before retrying
      await timeout(retryInterval);
    }
  });
}

export { createFetchConfigFromReq, createFetchMiddleware };
