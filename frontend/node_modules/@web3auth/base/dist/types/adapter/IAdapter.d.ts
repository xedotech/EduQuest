import { type AuthUserInfo, JRPCRequest, JRPCResponse, Maybe, RequestArguments, SafeEventEmitter, SendCallBack, UX_MODE, type UX_MODE_TYPE, WEB3AUTH_NETWORK, type WEB3AUTH_NETWORK_TYPE } from "@web3auth/auth";
import { AdapterNamespaceType, ChainNamespaceType, CustomChainConfig } from "../chain/IChainInterface";
import { Web3AuthError } from "../errors";
import { ProviderEvents, SafeEventEmitterProvider } from "../provider/IProvider";
export type UserInfo = AuthUserInfo;
export { UX_MODE, UX_MODE_TYPE, WEB3AUTH_NETWORK, WEB3AUTH_NETWORK_TYPE };
export declare const ADAPTER_CATEGORY: {
    readonly EXTERNAL: "external";
    readonly IN_APP: "in_app";
};
export type ADAPTER_CATEGORY_TYPE = (typeof ADAPTER_CATEGORY)[keyof typeof ADAPTER_CATEGORY];
export interface AdapterInitOptions {
    /**
     * Whether to auto connect to the adapter based on redirect mode or saved adapters
     */
    autoConnect?: boolean;
}
export declare const ADAPTER_STATUS: {
    readonly NOT_READY: "not_ready";
    readonly READY: "ready";
    readonly CONNECTING: "connecting";
    readonly CONNECTED: "connected";
    readonly DISCONNECTED: "disconnected";
    readonly ERRORED: "errored";
};
export declare const ADAPTER_EVENTS: {
    readonly ADAPTER_DATA_UPDATED: "adapter_data_updated";
    readonly CACHE_CLEAR: "cache_clear";
    readonly NOT_READY: "not_ready";
    readonly READY: "ready";
    readonly CONNECTING: "connecting";
    readonly CONNECTED: "connected";
    readonly DISCONNECTED: "disconnected";
    readonly ERRORED: "errored";
};
export type ADAPTER_STATUS_TYPE = (typeof ADAPTER_STATUS)[keyof typeof ADAPTER_STATUS];
export type UserAuthInfo = {
    idToken: string;
};
export interface BaseAdapterSettings {
    clientId?: string;
    sessionTime?: number;
    chainConfig?: CustomChainConfig;
    web3AuthNetwork?: WEB3AUTH_NETWORK_TYPE;
    useCoreKitKey?: boolean;
}
export interface IProvider extends SafeEventEmitter<ProviderEvents> {
    get chainId(): string;
    request<S, R>(args: RequestArguments<S>): Promise<Maybe<R>>;
    sendAsync<T, U>(req: JRPCRequest<T>, callback: SendCallBack<JRPCResponse<U>>): void;
    sendAsync<T, U>(req: JRPCRequest<T>): Promise<JRPCResponse<U>>;
    send<T, U>(req: JRPCRequest<T>, callback: SendCallBack<JRPCResponse<U>>): void;
}
export interface IBaseProvider<T> extends IProvider {
    provider: SafeEventEmitterProvider | null;
    currentChainConfig: CustomChainConfig;
    setupProvider(provider: T): Promise<void>;
    addChain(chainConfig: CustomChainConfig): void;
    switchChain(params: {
        chainId: string;
    }): Promise<void>;
    updateProviderEngineProxy(provider: SafeEventEmitterProvider): void;
    setKeyExportFlag(flag: boolean): void;
}
export interface IAdapter<T> extends SafeEventEmitter {
    adapterNamespace: AdapterNamespaceType;
    currentChainNamespace: ChainNamespaceType;
    chainConfigProxy: CustomChainConfig | null;
    type: ADAPTER_CATEGORY_TYPE;
    name: string;
    sessionTime: number;
    web3AuthNetwork: WEB3AUTH_NETWORK_TYPE;
    useCoreKitKey: boolean | undefined;
    clientId: string;
    status: ADAPTER_STATUS_TYPE;
    provider: IProvider | null;
    adapterData?: unknown;
    connnected: boolean;
    isInjected?: boolean;
    addChain(chainConfig: CustomChainConfig): Promise<void>;
    init(options?: AdapterInitOptions): Promise<void>;
    disconnect(options?: {
        cleanup: boolean;
    }): Promise<void>;
    connect(params?: T): Promise<IProvider | null>;
    getUserInfo(): Promise<Partial<UserInfo>>;
    enableMFA(params?: T): Promise<void>;
    manageMFA(params?: T): Promise<void>;
    setAdapterSettings(adapterSettings: BaseAdapterSettings): void;
    switchChain(params: {
        chainId: string;
    }): Promise<void>;
    authenticateUser(): Promise<UserAuthInfo>;
}
export type CONNECTED_EVENT_DATA = {
    adapter: string;
    provider: IProvider;
    reconnected: boolean;
};
export interface IAdapterDataEvent {
    adapterName: string;
    data: unknown;
}
export type AdapterEvents = {
    [ADAPTER_EVENTS.NOT_READY]: () => void;
    [ADAPTER_EVENTS.READY]: (adapter: string) => void;
    [ADAPTER_EVENTS.CONNECTED]: (data: CONNECTED_EVENT_DATA) => void;
    [ADAPTER_EVENTS.DISCONNECTED]: () => void;
    [ADAPTER_EVENTS.CONNECTING]: (data: {
        adapter: string;
    }) => void;
    [ADAPTER_EVENTS.ERRORED]: (error: Web3AuthError) => void;
    [ADAPTER_EVENTS.ADAPTER_DATA_UPDATED]: (data: IAdapterDataEvent) => void;
    [ADAPTER_EVENTS.CACHE_CLEAR]: () => void;
};
export declare abstract class BaseAdapter<T> extends SafeEventEmitter<AdapterEvents> implements IAdapter<T> {
    adapterData?: unknown;
    sessionTime: number;
    clientId: string;
    web3AuthNetwork: WEB3AUTH_NETWORK_TYPE;
    useCoreKitKey: boolean;
    protected rehydrated: boolean;
    protected chainConfig: CustomChainConfig | null;
    protected knownChainConfigs: Record<CustomChainConfig["chainId"], CustomChainConfig>;
    abstract adapterNamespace: AdapterNamespaceType;
    abstract currentChainNamespace: ChainNamespaceType;
    abstract type: ADAPTER_CATEGORY_TYPE;
    abstract name: string;
    abstract status: ADAPTER_STATUS_TYPE;
    constructor(options?: BaseAdapterSettings);
    get chainConfigProxy(): CustomChainConfig | null;
    get connnected(): boolean;
    abstract get provider(): IProvider | null;
    setAdapterSettings(options: BaseAdapterSettings): void;
    checkConnectionRequirements(): void;
    checkInitializationRequirements(): void;
    checkDisconnectionRequirements(): void;
    checkAddChainRequirements(chainConfig: CustomChainConfig, init?: boolean): void;
    checkSwitchChainRequirements({ chainId }: {
        chainId: string;
    }, init?: boolean): void;
    updateAdapterData(data: unknown): void;
    protected addChainConfig(chainConfig: CustomChainConfig): void;
    protected getChainConfig(chainId: string): CustomChainConfig | null;
    abstract init(options?: AdapterInitOptions): Promise<void>;
    abstract connect(params?: T): Promise<IProvider | null>;
    abstract disconnect(): Promise<void>;
    abstract getUserInfo(): Promise<Partial<UserInfo>>;
    abstract enableMFA(params?: T): Promise<void>;
    abstract manageMFA(params?: T): Promise<void>;
    abstract authenticateUser(): Promise<UserAuthInfo>;
    abstract addChain(chainConfig: CustomChainConfig): Promise<void>;
    abstract switchChain(params: {
        chainId: string;
    }): Promise<void>;
}
export interface BaseAdapterConfig {
    label: string;
    isInjected?: boolean;
    showOnModal?: boolean;
    showOnMobile?: boolean;
    showOnDesktop?: boolean;
}
export type LoginMethodConfig = Record<string, {
    /**
     * Display Name. If not provided, we use the default for auth app
     */
    name: string;
    /**
     * Description for button. If provided, it renders as a full length button. else, icon button
     */
    description?: string;
    /**
     * Logo to be shown on mouse hover. If not provided, we use the default for auth app
     */
    logoHover?: string;
    /**
     * Logo to be shown on dark background (dark theme). If not provided, we use the default for auth app
     */
    logoLight?: string;
    /**
     * Logo to be shown on light background (light theme). If not provided, we use the default for auth app
     */
    logoDark?: string;
    /**
     * Show login button on the main list
     */
    mainOption?: boolean;
    /**
     * Whether to show the login button on modal or not
     */
    showOnModal?: boolean;
    /**
     * Whether to show the login button on desktop
     */
    showOnDesktop?: boolean;
    /**
     * Whether to show the login button on mobile
     */
    showOnMobile?: boolean;
}>;
export type WalletConnectV2Data = {
    uri: string;
};
