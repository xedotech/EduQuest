/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  ADAPTER_CATEGORY: () => (/* reexport */ ADAPTER_CATEGORY),
  ADAPTER_EVENTS: () => (/* reexport */ ADAPTER_EVENTS),
  ADAPTER_NAMES: () => (/* reexport */ ADAPTER_NAMES),
  ADAPTER_NAMESPACES: () => (/* reexport */ ADAPTER_NAMESPACES),
  ADAPTER_STATUS: () => (/* reexport */ ADAPTER_STATUS),
  BaseAdapter: () => (/* reexport */ BaseAdapter),
  CHAIN_NAMESPACES: () => (/* reexport */ CHAIN_NAMESPACES),
  EVM_ADAPTERS: () => (/* reexport */ EVM_ADAPTERS),
  EVM_PLUGINS: () => (/* reexport */ EVM_PLUGINS),
  MULTI_CHAIN_ADAPTERS: () => (/* reexport */ MULTI_CHAIN_ADAPTERS),
  NFTCheckoutPluginError: () => (/* reexport */ NFTCheckoutPluginError),
  PLUGIN_EVENTS: () => (/* reexport */ PLUGIN_EVENTS),
  PLUGIN_NAMESPACES: () => (/* reexport */ PLUGIN_NAMESPACES),
  PLUGIN_STATUS: () => (/* reexport */ PLUGIN_STATUS),
  PROVIDER_EVENTS: () => (/* reexport */ PROVIDER_EVENTS),
  SOLANA_ADAPTERS: () => (/* reexport */ SOLANA_ADAPTERS),
  SOLANA_PLUGINS: () => (/* reexport */ SOLANA_PLUGINS),
  UX_MODE: () => (/* reexport */ auth_namespaceObject.UX_MODE),
  WALLET_ADAPTERS: () => (/* reexport */ WALLET_ADAPTERS),
  WALLET_PLUGINS: () => (/* reexport */ WALLET_PLUGINS),
  WEB3AUTH_NETWORK: () => (/* reexport */ auth_namespaceObject.WEB3AUTH_NETWORK),
  WalletInitializationError: () => (/* reexport */ WalletInitializationError),
  WalletLoginError: () => (/* reexport */ WalletLoginError),
  WalletOperationsError: () => (/* reexport */ WalletOperationsError),
  WalletProviderError: () => (/* reexport */ WalletProviderError),
  WalletServicesPluginError: () => (/* reexport */ WalletServicesPluginError),
  Web3AuthContextKey: () => (/* reexport */ Web3AuthContextKey),
  Web3AuthError: () => (/* reexport */ Web3AuthError),
  checkIfTokenIsExpired: () => (/* reexport */ checkIfTokenIsExpired),
  clearToken: () => (/* reexport */ clearToken),
  cloneDeep: () => (/* reexport */ base_controllers_namespaceObject.cloneDeep),
  fetchProjectConfig: () => (/* reexport */ fetchProjectConfig),
  fetchWalletRegistry: () => (/* reexport */ fetchWalletRegistry),
  getChainConfig: () => (/* reexport */ getChainConfig),
  getEvmChainConfig: () => (/* reexport */ getEvmChainConfig),
  getSavedToken: () => (/* reexport */ getSavedToken),
  getSolanaChainConfig: () => (/* reexport */ getSolanaChainConfig),
  getXrplChainConfig: () => (/* reexport */ getXrplChainConfig),
  isHexStrict: () => (/* reexport */ isHexStrict),
  log: () => (/* reexport */ loglevel),
  normalizeWalletName: () => (/* reexport */ normalizeWalletName),
  saveToken: () => (/* reexport */ saveToken),
  serializeError: () => (/* reexport */ serializeError),
  signerHost: () => (/* reexport */ signerHost),
  storageAvailable: () => (/* reexport */ storageAvailable)
});

;// external "@babel/runtime/helpers/defineProperty"
const defineProperty_namespaceObject = require("@babel/runtime/helpers/defineProperty");
var defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty_namespaceObject);
;// external "@babel/runtime/helpers/objectSpread2"
const objectSpread2_namespaceObject = require("@babel/runtime/helpers/objectSpread2");
var objectSpread2_default = /*#__PURE__*/__webpack_require__.n(objectSpread2_namespaceObject);
;// external "@web3auth/auth"
const auth_namespaceObject = require("@web3auth/auth");
;// external "ts-custom-error"
const external_ts_custom_error_namespaceObject = require("ts-custom-error");
;// ./src/errors/index.ts



// @flow

function serializeError(args) {
  // Find first Error or create an "unknown" Error to keep stack trace.
  const index = args.findIndex(arg => arg instanceof Error);
  const msgIndex = args.findIndex(arg => typeof arg === "string");
  const apiErrorIdx = args.findIndex(arg => arg && typeof arg === "object" && "status" in arg && "type" in arg);
  let err;
  if (apiErrorIdx !== -1) {
    const apiError = args[apiErrorIdx];
    err = new Error(`${apiError.status} ${apiError.type.toString()} ${apiError.statusText}`);
  } else if (index !== -1) {
    err = args.splice(index, 1)[0];
  } else if (msgIndex !== -1) {
    err = new Error(args.splice(msgIndex, 1)[0]);
  } else {
    err = new Error("Unknown error");
  }
  return [err, args];
}
class Web3AuthError extends external_ts_custom_error_namespaceObject.CustomError {
  constructor(code, message, cause) {
    // takes care of stack and proto
    super(message);
    defineProperty_default()(this, "code", void 0);
    defineProperty_default()(this, "message", void 0);
    defineProperty_default()(this, "cause", void 0);
    this.code = code;
    this.message = message || "";
    this.cause = cause;
    // Set name explicitly as minification can mangle class names
    Object.defineProperty(this, "name", {
      value: "Web3AuthError"
    });
  }
  toJSON() {
    return {
      name: this.name,
      code: this.code,
      message: this.message,
      cause: serializeError([this.cause])
    };
  }
  toString() {
    return JSON.stringify(this.toJSON());
  }
}
class WalletInitializationError extends Web3AuthError {
  constructor(code, message, cause) {
    // takes care of stack and proto
    super(code, message, cause);

    // Set name explicitly as minification can mangle class names
    Object.defineProperty(this, "name", {
      value: "WalletInitializationError"
    });
  }
  static fromCode(code, extraMessage = "", cause) {
    return new WalletInitializationError(code, `${WalletInitializationError.messages[code]}, ${extraMessage}`, cause);
  }

  // Custom methods
  static notFound(extraMessage = "", cause) {
    return WalletInitializationError.fromCode(5001, extraMessage, cause);
  }
  static notInstalled(extraMessage = "", cause) {
    return WalletInitializationError.fromCode(5002, extraMessage, cause);
  }
  static notReady(extraMessage = "", cause) {
    return WalletInitializationError.fromCode(5003, extraMessage, cause);
  }
  static windowBlocked(extraMessage = "", cause) {
    return WalletInitializationError.fromCode(5004, extraMessage, cause);
  }
  static windowClosed(extraMessage = "", cause) {
    return WalletInitializationError.fromCode(5005, extraMessage, cause);
  }
  static incompatibleChainNameSpace(extraMessage = "", cause) {
    return WalletInitializationError.fromCode(5006, extraMessage, cause);
  }
  static duplicateAdapterError(extraMessage = "", cause) {
    return WalletInitializationError.fromCode(5007, extraMessage, cause);
  }
  static invalidProviderConfigError(extraMessage = "", cause) {
    return WalletInitializationError.fromCode(5008, extraMessage, cause);
  }
  static providerNotReadyError(extraMessage = "", cause) {
    return WalletInitializationError.fromCode(5009, extraMessage, cause);
  }
  static rpcConnectionError(extraMessage = "", cause) {
    return WalletInitializationError.fromCode(5010, extraMessage, cause);
  }
  static invalidParams(extraMessage = "", cause) {
    return WalletInitializationError.fromCode(5011, extraMessage, cause);
  }
  static invalidNetwork(extraMessage = "", cause) {
    return WalletInitializationError.fromCode(5013, extraMessage, cause);
  }
}

/**
 * wallet login errors
 */
defineProperty_default()(WalletInitializationError, "messages", {
  5000: "Custom",
  5001: "Wallet is not found",
  5002: "Wallet is not installed",
  5003: "Wallet is not ready yet",
  5004: "Wallet window is blocked",
  5005: "Wallet window has been closed by the user",
  5006: "Incompatible chain namespace provided",
  5007: "Adapter has already been included",
  5008: "Invalid provider Config",
  5009: "Provider is not ready yet",
  5010: "Failed to connect with rpc url",
  5011: "Invalid params passed in",
  5013: "Invalid network provided"
});
class WalletLoginError extends Web3AuthError {
  constructor(code, message, cause) {
    // takes care of stack and proto
    super(code, message, cause);

    // Set name explicitly as minification can mangle class names
    Object.defineProperty(this, "name", {
      value: "WalletLoginError"
    });
  }
  static fromCode(code, extraMessage = "", cause) {
    return new WalletLoginError(code, `${WalletLoginError.messages[code]}. ${extraMessage}`, cause);
  }
  static connectionError(extraMessage = "", cause) {
    return WalletLoginError.fromCode(5111, extraMessage, cause);
  }
  static disconnectionError(extraMessage = "", cause) {
    return WalletLoginError.fromCode(5112, extraMessage, cause);
  }
  static notConnectedError(extraMessage = "", cause) {
    return WalletLoginError.fromCode(5113, extraMessage, cause);
  }
  static popupClosed(extraMessage = "", cause) {
    return WalletLoginError.fromCode(5114, extraMessage, cause);
  }
  static mfaEnabled(extraMessage = "", cause) {
    return WalletLoginError.fromCode(5115, extraMessage, cause);
  }
  static chainConfigNotAdded(extraMessage = "", cause) {
    return WalletLoginError.fromCode(5116, extraMessage, cause);
  }
  static unsupportedOperation(extraMessage = "", cause) {
    return WalletLoginError.fromCode(5117, extraMessage, cause);
  }
  static coreKitKeyNotFound(extraMessage = "", cause) {
    return WalletLoginError.fromCode(5118, extraMessage, cause);
  }
  static userNotLoggedIn(extraMessage = "", cause) {
    return WalletLoginError.fromCode(5119, extraMessage, cause);
  }
}
defineProperty_default()(WalletLoginError, "messages", {
  5000: "Custom",
  5111: "Failed to connect with wallet",
  5112: "Failed to disconnect from wallet",
  5113: "Wallet is not connected",
  5114: "Wallet popup has been closed by the user",
  5115: "User has already enabled mfa, please use the @web3auth/web3auth-web sdk for login with mfa",
  5116: "Chain config has not been added. Please add the chain config before calling switchChain",
  5117: "Unsupported operation",
  5118: "useCoreKitKey flag is enabled but coreKitKey is not available",
  5119: "User not logged in."
});
class WalletOperationsError extends Web3AuthError {
  constructor(code, message, cause) {
    // takes care of stack and proto
    super(code, message, cause);

    // Set name explicitly as minification can mangle class names
    Object.defineProperty(this, "name", {
      value: "WalletOperationsError"
    });
  }
  static fromCode(code, extraMessage = "", cause) {
    return new WalletOperationsError(code, `${WalletOperationsError.messages[code]}, ${extraMessage}`, cause);
  }

  // Custom methods
  static chainIDNotAllowed(extraMessage = "", cause) {
    return WalletOperationsError.fromCode(5201, extraMessage, cause);
  }
  static operationNotAllowed(extraMessage = "", cause) {
    return WalletOperationsError.fromCode(5202, extraMessage, cause);
  }
  static chainNamespaceNotAllowed(extraMessage = "", cause) {
    return WalletOperationsError.fromCode(5203, extraMessage, cause);
  }
}
defineProperty_default()(WalletOperationsError, "messages", {
  5000: "Custom",
  5201: "Provided chainId is not allowed",
  5202: "This operation is not allowed"
});
class WalletProviderError extends Web3AuthError {
  constructor(code, message, cause) {
    // takes care of stack and proto
    super(code, message, cause);

    // Set name explicitly as minification can mangle class names
    Object.defineProperty(this, "name", {
      value: "WalletProviderError"
    });
  }
  static fromCode(code, extraMessage = "", cause) {
    return new WalletOperationsError(code, `${WalletProviderError.messages[code]}, ${extraMessage}`, cause);
  }

  // Custom methods
  static invalidRequestArgs(extraMessage = "", cause) {
    return WalletOperationsError.fromCode(5301, extraMessage, cause);
  }
  static invalidRequestMethod(extraMessage = "", cause) {
    return WalletOperationsError.fromCode(5302, extraMessage, cause);
  }
  static invalidRequestParams(extraMessage = "", cause) {
    return WalletOperationsError.fromCode(5303, extraMessage, cause);
  }
}
defineProperty_default()(WalletProviderError, "messages", {
  5000: "Custom",
  5301: "Expected a single, non-array, object argument.",
  5302: "'args.method' must be a non-empty string.",
  5303: "'args.params' must be an object or array if provided."
});
;// ./src/chain/IChainInterface.ts
const CHAIN_NAMESPACES = {
  EIP155: "eip155",
  SOLANA: "solana",
  CASPER: "casper",
  XRPL: "xrpl",
  OTHER: "other"
};
// eip155 for all evm chains

const ADAPTER_NAMESPACES = {
  EIP155: "eip155",
  SOLANA: "solana",
  CASPER: "casper",
  XRPL: "xrpl",
  MULTICHAIN: "multichain"
};
// eip155 for all evm chains
;// ./src/chain/config.ts


const INFURA_PROXY_URL = "https://api.web3auth.io/infura-service/v1";
const getDefaultNetworkId = chainNamespace => {
  if (chainNamespace === CHAIN_NAMESPACES.EIP155) {
    return 1;
  } else if (chainNamespace === CHAIN_NAMESPACES.SOLANA) {
    return 1;
  } else if (chainNamespace === CHAIN_NAMESPACES.XRPL) {
    return 1;
  }
  throw WalletInitializationError.invalidParams(`Chain namespace ${chainNamespace} is not supported`);
};
const getEvmChainConfig = (chainId, web3AuthClientId = "") => {
  const chainNamespace = CHAIN_NAMESPACES.EIP155;
  const infuraRpcTarget = `${INFURA_PROXY_URL}/${chainId}/${web3AuthClientId}`;
  if (chainId === 1) {
    return {
      logo: "https://images.toruswallet.io/eth.svg",
      chainNamespace,
      chainId: "0x1",
      rpcTarget: infuraRpcTarget,
      displayName: "Ethereum Mainnet",
      blockExplorerUrl: "https://etherscan.io/",
      ticker: "ETH",
      tickerName: "Ethereum",
      decimals: 18
    };
  }
  if (chainId === 10) {
    return {
      chainNamespace: CHAIN_NAMESPACES.EIP155,
      decimals: 18,
      blockExplorerUrl: "https://optimistic.etherscan.io",
      chainId: "0xa",
      displayName: "Optimism",
      logo: "optimism.svg",
      rpcTarget: infuraRpcTarget,
      ticker: "ETH",
      tickerName: "Ethereum"
    };
  }
  if (chainId === 8453) {
    return {
      chainNamespace: CHAIN_NAMESPACES.EIP155,
      decimals: 18,
      blockExplorerUrl: "https://basescan.org",
      chainId: "0x2105",
      displayName: "Base",
      logo: "base.svg",
      rpcTarget: infuraRpcTarget,
      ticker: "ETH",
      tickerName: "Ethereum"
    };
  }
  if (chainId === 42161) {
    return {
      chainNamespace: CHAIN_NAMESPACES.EIP155,
      decimals: 18,
      blockExplorerUrl: "https://arbiscan.io",
      chainId: "0xa4b1",
      displayName: "Arbitrum One",
      logo: "arbitrum.svg",
      rpcTarget: infuraRpcTarget,
      ticker: "ETH",
      tickerName: "Ethereum"
    };
  }
  if (chainId === 59144) {
    return {
      chainNamespace: CHAIN_NAMESPACES.EIP155,
      decimals: 18,
      blockExplorerUrl: "https://lineascan.build",
      chainId: "0xe708",
      logo: "https://images.toruswallet.io/eth.svg",
      rpcTarget: infuraRpcTarget,
      ticker: "ETH",
      tickerName: "Ethereum"
    };
  }
  if (chainId === 11155111) {
    return {
      logo: "https://images.toruswallet.io/eth.svg",
      chainNamespace,
      chainId: "0xaa36a7",
      rpcTarget: infuraRpcTarget,
      displayName: "Sepolia Testnet",
      blockExplorerUrl: "https://sepolia.etherscan.io/",
      ticker: "ETH",
      tickerName: "Ethereum",
      decimals: 18
    };
  }
  if (chainId === 137) {
    return {
      logo: "https://images.toruswallet.io/polygon.svg",
      chainNamespace,
      chainId: "0x89",
      rpcTarget: infuraRpcTarget,
      displayName: "Polygon Mainnet",
      blockExplorerUrl: "https://polygonscan.com",
      ticker: "POL",
      tickerName: "Polygon Ecosystem Token"
    };
  }
  if (chainId === 80002) {
    return {
      logo: "https://images.toruswallet.io/polygon.svg",
      chainNamespace,
      chainId: "0x13882",
      rpcTarget: infuraRpcTarget,
      displayName: "Polygon Amoy Testnet",
      blockExplorerUrl: "https://www.oklink.com/amoy",
      ticker: "POL",
      tickerName: "Polygon Ecosystem Token",
      decimals: 18
    };
  }
  if (chainId === 56) {
    return {
      logo: "https://images.toruswallet.io/bnb.png",
      chainNamespace,
      chainId: "0x38",
      rpcTarget: infuraRpcTarget,
      displayName: "Binance SmartChain Mainnet",
      blockExplorerUrl: "https://bscscan.com",
      ticker: "BNB",
      tickerName: "Binance SmartChain",
      decimals: 18
    };
  }
  if (chainId === 97) {
    return {
      logo: "https://images.toruswallet.io/bnb.png",
      chainNamespace,
      chainId: "0x61",
      rpcTarget: infuraRpcTarget,
      displayName: "Binance SmartChain Testnet",
      blockExplorerUrl: "https://testnet.bscscan.com",
      ticker: "BNB",
      tickerName: "Binance SmartChain",
      decimals: 18
    };
  }
  if (chainId === 25) {
    return {
      logo: "https://images.toruswallet.io/cro.svg",
      chainNamespace,
      chainId: "0x19",
      rpcTarget: "https://rpc.cronos.org",
      displayName: "Cronos Mainnet",
      blockExplorerUrl: "https://cronoscan.com/",
      ticker: "CRO",
      tickerName: "Cronos"
    };
  }
  if (chainId === 338) {
    return {
      logo: "https://images.toruswallet.io/cro.svg",
      chainNamespace,
      chainId: "0x152",
      rpcTarget: "https://rpc-t3.cronos.org/",
      displayName: "Cronos Testnet",
      blockExplorerUrl: "https://cronoscan.com/",
      ticker: "CRO",
      tickerName: "Cronos",
      decimals: 18
    };
  }
  if (chainId === 8217) {
    return {
      logo: "https://images.toruswallet.io/klay.svg",
      chainNamespace,
      chainId: "0x2019",
      rpcTarget: "https://public-node-api.klaytnapi.com/v1/cypress",
      displayName: "Klaytn Mainnet",
      blockExplorerUrl: "https://scope.klaytn.com",
      ticker: "KLAY",
      tickerName: "Klaytn",
      decimals: 18
    };
  }
  if (chainId === 1946) {
    return {
      chainNamespace: CHAIN_NAMESPACES.EIP155,
      chainId: "0x79a",
      rpcTarget: "https://rpc.minato.soneium.org",
      displayName: "Soneium Minato Testnet",
      blockExplorerUrl: "https://explorer-testnet.soneium.org",
      ticker: "ETH",
      tickerName: "ETH",
      logo: "https://iili.io/2i5xce2.png"
    };
  }
  if (chainId === 1868) {
    return {
      chainNamespace: CHAIN_NAMESPACES.EIP155,
      chainId: "0x74c",
      rpcTarget: "https://rpc.soneium.org",
      displayName: "Soneium Mainnet",
      blockExplorerUrl: "https://soneium.blockscout.com",
      ticker: "ETH",
      tickerName: "ETH",
      logo: "https://iili.io/2i5xce2.png"
    };
  }
  return null;
};
const getSolanaChainConfig = chainId => {
  const chainNamespace = CHAIN_NAMESPACES.SOLANA;
  // support both cross chain id and base solana chain id from 1
  if (chainId === 101 || chainId === 1) {
    return {
      logo: "https://images.toruswallet.io/sol.svg",
      chainNamespace,
      chainId: "0x65",
      rpcTarget: "https://rpc.ankr.com/solana",
      displayName: "Solana Mainnet",
      blockExplorerUrl: "https://explorer.solana.com",
      ticker: "SOL",
      tickerName: "Solana",
      decimals: 9
    };
  } else if (chainId === 102 || chainId === 2) {
    return {
      logo: "https://images.toruswallet.io/sol.svg",
      chainNamespace,
      chainId: "0x66",
      rpcTarget: "https://api.testnet.solana.com",
      displayName: "Solana Testnet",
      blockExplorerUrl: "https://explorer.solana.com?cluster=testnet",
      ticker: "SOL",
      tickerName: "Solana",
      decimals: 9
    };
  } else if (chainId === 103 || chainId === 3) {
    return {
      logo: "https://images.toruswallet.io/sol.svg",
      chainNamespace,
      chainId: "0x67",
      rpcTarget: "https://api.devnet.solana.com",
      displayName: "Solana Devnet",
      blockExplorerUrl: "https://explorer.solana.com?cluster=devnet",
      ticker: "SOL",
      tickerName: "Solana",
      decimals: 9
    };
  }
  return null;
};
const getXrplChainConfig = chainId => {
  const chainNamespace = CHAIN_NAMESPACES.XRPL;
  if (chainId === 1) {
    return {
      chainNamespace,
      decimals: 15,
      chainId: "0x1",
      logo: "https://images.toruswallet.io/XRP.svg",
      rpcTarget: "https://ripple-node.tor.us",
      wsTarget: "wss://s2.ripple.com",
      ticker: "XRP",
      tickerName: "XRPL",
      displayName: "xrpl mainnet",
      blockExplorerUrl: "https://livenet.xrpl.org"
    };
  } else if (chainId === 2) {
    return {
      chainNamespace,
      decimals: 15,
      chainId: "0x2",
      logo: "https://images.toruswallet.io/XRP.svg",
      rpcTarget: "https://testnet-ripple-node.tor.us",
      wsTarget: "wss://s.altnet.rippletest.net",
      ticker: "XRP",
      tickerName: "XRPL",
      displayName: "xrpl testnet",
      blockExplorerUrl: "https://testnet.xrpl.org",
      isTestnet: true
    };
  } else if (chainId === 3) {
    return {
      chainNamespace,
      decimals: 15,
      chainId: "0x3",
      logo: "https://images.toruswallet.io/XRP.svg",
      rpcTarget: "https://devnet-ripple-node.tor.us",
      wsTarget: "wss://s.devnet.rippletest.net/",
      ticker: "XRP",
      tickerName: "XRPL",
      displayName: "xrpl devnet",
      blockExplorerUrl: "https://devnet.xrpl.org",
      isTestnet: true
    };
  }
  return null;
};
const getChainConfig = (chainNamespace, chainId, web3AuthClientId) => {
  if (chainNamespace === CHAIN_NAMESPACES.OTHER) return null;
  const finalChainId = chainId ? typeof chainId === "number" ? chainId : parseInt(chainId, 16) : getDefaultNetworkId(chainNamespace);
  if (chainNamespace === CHAIN_NAMESPACES.EIP155) {
    return getEvmChainConfig(finalChainId, web3AuthClientId);
  } else if (chainNamespace === CHAIN_NAMESPACES.SOLANA) {
    return getSolanaChainConfig(finalChainId);
  } else if (chainNamespace === CHAIN_NAMESPACES.XRPL) {
    return getXrplChainConfig(finalChainId);
  }
  return null;
};
;// ./src/wallet/index.ts

const MULTI_CHAIN_ADAPTERS = {
  AUTH: "auth",
  WALLET_CONNECT_V2: "wallet-connect-v2",
  SFA: "sfa"
};
const SOLANA_ADAPTERS = objectSpread2_default()({
  TORUS_SOLANA: "torus-solana"
}, MULTI_CHAIN_ADAPTERS);
const EVM_ADAPTERS = objectSpread2_default()({
  TORUS_EVM: "torus-evm",
  COINBASE: "coinbase"
}, MULTI_CHAIN_ADAPTERS);
const WALLET_ADAPTERS = objectSpread2_default()(objectSpread2_default()({}, EVM_ADAPTERS), SOLANA_ADAPTERS);
const ADAPTER_NAMES = {
  [MULTI_CHAIN_ADAPTERS.AUTH]: "Auth",
  [MULTI_CHAIN_ADAPTERS.WALLET_CONNECT_V2]: "Wallet Connect v2",
  [MULTI_CHAIN_ADAPTERS.SFA]: "SFA",
  [SOLANA_ADAPTERS.TORUS_SOLANA]: "Torus",
  [EVM_ADAPTERS.TORUS_EVM]: "Torus",
  [EVM_ADAPTERS.COINBASE]: "Coinbase Smart Wallet"
};
;// ./src/adapter/IAdapter.ts








const ADAPTER_CATEGORY = {
  EXTERNAL: "external",
  IN_APP: "in_app"
};
const ADAPTER_STATUS = {
  NOT_READY: "not_ready",
  READY: "ready",
  CONNECTING: "connecting",
  CONNECTED: "connected",
  DISCONNECTED: "disconnected",
  ERRORED: "errored"
};
const ADAPTER_EVENTS = objectSpread2_default()(objectSpread2_default()({}, ADAPTER_STATUS), {}, {
  ADAPTER_DATA_UPDATED: "adapter_data_updated",
  CACHE_CLEAR: "cache_clear"
});
class BaseAdapter extends auth_namespaceObject.SafeEventEmitter {
  constructor(options = {}) {
    super();
    defineProperty_default()(this, "adapterData", {});
    defineProperty_default()(this, "sessionTime", 86400);
    defineProperty_default()(this, "clientId", void 0);
    defineProperty_default()(this, "web3AuthNetwork", auth_namespaceObject.WEB3AUTH_NETWORK.MAINNET);
    defineProperty_default()(this, "useCoreKitKey", undefined);
    defineProperty_default()(this, "rehydrated", false);
    // should be added in constructor or from setAdapterSettings function
    // before calling init function.
    defineProperty_default()(this, "chainConfig", null);
    defineProperty_default()(this, "knownChainConfigs", {});
    defineProperty_default()(this, "adapterNamespace", void 0);
    defineProperty_default()(this, "currentChainNamespace", void 0);
    defineProperty_default()(this, "type", void 0);
    defineProperty_default()(this, "name", void 0);
    defineProperty_default()(this, "status", void 0);
    this.setAdapterSettings(options);
  }
  get chainConfigProxy() {
    return this.chainConfig ? objectSpread2_default()({}, this.chainConfig) : null;
  }
  get connnected() {
    return this.status === ADAPTER_STATUS.CONNECTED;
  }
  setAdapterSettings(options) {
    if (this.status === ADAPTER_STATUS.READY) return;
    if (options !== null && options !== void 0 && options.sessionTime) {
      this.sessionTime = options.sessionTime;
    }
    if (options !== null && options !== void 0 && options.clientId) {
      this.clientId = options.clientId;
    }
    if (options !== null && options !== void 0 && options.web3AuthNetwork) {
      this.web3AuthNetwork = options.web3AuthNetwork;
    }
    if ((options === null || options === void 0 ? void 0 : options.useCoreKitKey) !== undefined) {
      this.useCoreKitKey = options.useCoreKitKey;
    }
    const customChainConfig = options.chainConfig;
    if (customChainConfig) {
      if (!customChainConfig.chainNamespace) throw WalletInitializationError.notReady("ChainNamespace is required while setting chainConfig");
      this.currentChainNamespace = customChainConfig.chainNamespace;
      // chainId is optional in this function.
      // we go with mainnet chainId by default.
      const defaultChainConfig = getChainConfig(customChainConfig.chainNamespace, customChainConfig.chainId, this.clientId);
      // NOTE: It is being forced casted to CustomChainConfig to handle OTHER Chainnamespace
      // where chainConfig is not required.
      const finalChainConfig = objectSpread2_default()(objectSpread2_default()({}, defaultChainConfig || {}), customChainConfig);
      this.chainConfig = finalChainConfig;
      this.addChainConfig(finalChainConfig);
    }
  }
  checkConnectionRequirements() {
    // we reconnect without killing existing wallet connect session on calling connect again.
    if (this.name === WALLET_ADAPTERS.WALLET_CONNECT_V2 && this.status === ADAPTER_STATUS.CONNECTING) return;else if (this.status === ADAPTER_STATUS.CONNECTING) throw WalletInitializationError.notReady("Already connecting");
    if (this.status === ADAPTER_STATUS.CONNECTED) throw WalletLoginError.connectionError("Already connected");
    if (this.status !== ADAPTER_STATUS.READY) throw WalletLoginError.connectionError("Wallet adapter is not ready yet, Please wait for init function to resolve before calling connect/connectTo function");
  }
  checkInitializationRequirements() {
    if (!this.clientId) throw WalletInitializationError.invalidParams("Please initialize Web3Auth with a valid clientId in constructor");
    if (!this.chainConfig) throw WalletInitializationError.invalidParams("rpcTarget is required in chainConfig");
    if (!this.chainConfig.rpcTarget && this.chainConfig.chainNamespace !== CHAIN_NAMESPACES.OTHER) {
      throw WalletInitializationError.invalidParams("rpcTarget is required in chainConfig");
    }
    if (!this.chainConfig.chainId && this.chainConfig.chainNamespace !== CHAIN_NAMESPACES.OTHER) {
      throw WalletInitializationError.invalidParams("chainID is required in chainConfig");
    }
    if (this.status === ADAPTER_STATUS.NOT_READY) return;
    if (this.status === ADAPTER_STATUS.CONNECTED) throw WalletInitializationError.notReady("Already connected");
    if (this.status === ADAPTER_STATUS.READY) throw WalletInitializationError.notReady("Adapter is already initialized");
  }
  checkDisconnectionRequirements() {
    if (this.status !== ADAPTER_STATUS.CONNECTED) throw WalletLoginError.disconnectionError("Not connected with wallet");
  }
  checkAddChainRequirements(chainConfig, init = false) {
    if (!init && !this.provider) throw WalletLoginError.notConnectedError("Not connected with wallet.");
    if (this.currentChainNamespace !== chainConfig.chainNamespace) {
      throw WalletOperationsError.chainNamespaceNotAllowed("This adapter doesn't support this chainNamespace");
    }
  }
  checkSwitchChainRequirements({
    chainId
  }, init = false) {
    if (!init && !this.provider) throw WalletLoginError.notConnectedError("Not connected with wallet.");
    if (!this.knownChainConfigs[chainId]) throw WalletLoginError.chainConfigNotAdded("Invalid chainId");
  }
  updateAdapterData(data) {
    this.adapterData = data;
    this.emit(ADAPTER_EVENTS.ADAPTER_DATA_UPDATED, {
      adapterName: this.name,
      data
    });
  }
  addChainConfig(chainConfig) {
    const currentConfig = this.knownChainConfigs[chainConfig.chainId];
    this.knownChainConfigs[chainConfig.chainId] = objectSpread2_default()(objectSpread2_default()({}, currentConfig || {}), chainConfig);
  }
  getChainConfig(chainId) {
    return this.knownChainConfigs[chainId] || null;
  }
}
;// external "jwt-decode"
const external_jwt_decode_namespaceObject = require("jwt-decode");
;// external "@toruslabs/base-controllers"
const base_controllers_namespaceObject = require("@toruslabs/base-controllers");
;// external "@toruslabs/constants"
const constants_namespaceObject = require("@toruslabs/constants");
;// external "@toruslabs/http-helpers"
const http_helpers_namespaceObject = require("@toruslabs/http-helpers");
;// ./src/utils.ts




function storageAvailable(type) {
  let storageExists = false;
  let storageLength = 0;
  let storage;
  try {
    storage = window[type];
    storageExists = true;
    storageLength = storage.length;
    const x = "__storage_test__";
    storage.setItem(x, x);
    storage.removeItem(x);
    return true;
  } catch (error) {
    const _error = error;
    return !!(_error && (
    // everything except Firefox
    _error.code === 22 ||
    // Firefox
    _error.code === 1014 ||
    // test name field too, because code might not be present
    // everything except Firefox
    _error.name === "QuotaExceededError" ||
    // Firefox
    _error.name === "NS_ERROR_DOM_QUOTA_REACHED") &&
    // acknowledge QuotaExceededError only if there's something already stored
    storageExists && storageLength !== 0);
  }
}
const isHexStrict = hex => {
  return (typeof hex === "string" || typeof hex === "number") && /^(-)?0x[0-9a-f]*$/i.test(hex);
};
const signerHost = web3AuthNetwork => {
  return constants_namespaceObject.SIGNER_MAP[web3AuthNetwork !== null && web3AuthNetwork !== void 0 ? web3AuthNetwork : auth_namespaceObject.WEB3AUTH_NETWORK.SAPPHIRE_MAINNET];
};
const fetchProjectConfig = async (clientId, web3AuthNetwork, aaProvider) => {
  const url = new URL(`${signerHost(web3AuthNetwork)}/api/configuration`);
  url.searchParams.append("project_id", clientId);
  url.searchParams.append("network", web3AuthNetwork);
  url.searchParams.append("whitelist", "true");
  if (aaProvider) url.searchParams.append("aa_provider", aaProvider);
  const res = await (0,http_helpers_namespaceObject.get)(url.href);
  return res;
};
const fetchWalletRegistry = async url => {
  const res = await (0,http_helpers_namespaceObject.get)(url || "https://assets.web3auth.io/v1/wallet-registry.json");
  return res;
};

// Normalize wallet name to a standard format, used for external wallets that are auto-detected by MIPD (EIP-6963 and Wallet Standard)
const normalizeWalletName = name => {
  let normalizedName = name.toLowerCase();
  // remove decriptive part after | e.g. "Crypto.com | Defi Wallet" => "Crypto.com"
  normalizedName = normalizedName.split("|")[0];

  // replace -  with space e.g. "Trust - Wallet" => "Trust Wallet"
  normalizedName = normalizedName.replace(/-/g, " ");

  // replace multiple spaces with single space
  normalizedName = normalizedName.replace(/\s+/g, " ");

  // remove trailing "wallet" e.g. "Trust Wallet" => "Trust", "GateWallet" => "Gate"
  normalizedName = normalizedName.replace(/wallet$/i, "").trim();

  // replace space with -
  normalizedName = normalizedName.replace(/\s/g, "-");
  return normalizedName;
};

;// ./src/adapter/utils.ts


const checkIfTokenIsExpired = token => {
  const decoded = (0,external_jwt_decode_namespaceObject.jwtDecode)(token);
  if (!decoded.exp) {
    return true;
  }
  if (decoded.exp < Math.floor(Date.now() / 1000)) {
    return true;
  }
  return false;
};
const getSavedToken = (userAddress, issuer) => {
  if (storageAvailable("localStorage")) {
    return localStorage.getItem(`${userAddress.toLowerCase()}_${issuer}`);
  }
  return null;
};
const saveToken = (userAddress, issuer, token) => {
  if (storageAvailable("localStorage")) {
    return localStorage.setItem(`${userAddress.toLowerCase()}_${issuer}`, token);
  }
  return null;
};
const clearToken = (userAddress, issuer) => {
  if (storageAvailable("localStorage")) {
    return localStorage.removeItem(`${userAddress.toLowerCase()}_${issuer}`);
  }
  return null;
};
;// ./src/adapter/index.ts


;// ./src/composables/index.ts
const Web3AuthContextKey = "web3auth_context";
;// external "loglevel"
const external_loglevel_namespaceObject = require("loglevel");
var external_loglevel_default = /*#__PURE__*/__webpack_require__.n(external_loglevel_namespaceObject);
;// ./src/loglevel.ts

/* harmony default export */ const loglevel = (external_loglevel_default().getLogger("web3auth-logger"));
;// ./src/plugin/errors.ts


class WalletServicesPluginError extends Web3AuthError {
  constructor(code, message, cause) {
    // takes care of stack and proto
    super(code, message, cause);

    // Set name explicitly as minification can mangle class names
    Object.defineProperty(this, "name", {
      value: "WalletServicesPluginError"
    });
  }
  static fromCode(code, extraMessage = "", cause) {
    return new WalletServicesPluginError(code, `${WalletServicesPluginError.messages[code]}${extraMessage}`, cause);
  }
  static notInitialized(extraMessage = "", cause) {
    return WalletServicesPluginError.fromCode(5210, extraMessage, cause);
  }
  static unsupportedAdapter(extraMessage = "", cause) {
    return WalletServicesPluginError.fromCode(5211, extraMessage, cause);
  }
  static providerRequired(extraMessage = "", cause) {
    return WalletServicesPluginError.fromCode(5212, extraMessage, cause);
  }
  static web3authRequired(extraMessage = "", cause) {
    return WalletServicesPluginError.fromCode(5213, extraMessage, cause);
  }
  static web3AuthNotConnected(extraMessage = "", cause) {
    return WalletServicesPluginError.fromCode(5214, extraMessage, cause);
  }
  static alreadyInitialized(extraMessage = "", cause) {
    return WalletServicesPluginError.fromCode(5216, extraMessage, cause);
  }
  static unsupportedChainNamespace(extraMessage = "", cause) {
    return WalletServicesPluginError.fromCode(5218, extraMessage, cause);
  }
  static differentWeb3AuthNetwork(extraMessage = "", cause) {
    return WalletServicesPluginError.fromCode(5219, extraMessage, cause);
  }
  static invalidParams(extraMessage = "", cause) {
    return WalletServicesPluginError.fromCode(5220, extraMessage, cause);
  }
  static web3authNotInitialized(extraMessage = "", cause) {
    return WalletServicesPluginError.fromCode(5221, extraMessage, cause);
  }
  static invalidSession(extraMessage = "", cause) {
    return WalletServicesPluginError.fromCode(5222, extraMessage, cause);
  }
  static walletPluginNotConnected(extraMessage = "", cause) {
    return WalletServicesPluginError.fromCode(5223, extraMessage, cause);
  }
}
defineProperty_default()(WalletServicesPluginError, "messages", {
  5210: "Wallet Services Plugin is not initialized",
  5211: "Web3Auth is connected to unsupported adapter. Wallet services connector plugin requires web3auth connected to auth adapter.",
  5212: "Provider is required..",
  5213: "Web3Auth instance is required while initialization.",
  5214: "Web3Auth is not connected.",
  5216: "Plugin is already initialized",
  5218: "Unsupported chain namespace.",
  5219: "Plugin network different than web3auth instance network.",
  5221: "Web3Auth is not initialized",
  5222: "Invalid session inside wallet services. Please report this issue.",
  5223: "Wallet plugin is not connected Yet. Please wait for plugin to connect and listen via `connected` event on the plugin"
});
class NFTCheckoutPluginError extends Web3AuthError {
  constructor(code, message, cause) {
    // takes care of stack and proto
    super(code, message, cause);

    // Set name explicitly as minification can mangle class names
    Object.defineProperty(this, "name", {
      value: "NFTCheckoutPluginError"
    });
  }
  static fromCode(code, extraMessage = "", cause) {
    return new NFTCheckoutPluginError(code, `${NFTCheckoutPluginError.messages[code]}${extraMessage}`, cause);
  }
  static notInitialized(extraMessage = "", cause) {
    return NFTCheckoutPluginError.fromCode(6210, extraMessage, cause);
  }
  static providerRequired(extraMessage = "", cause) {
    return NFTCheckoutPluginError.fromCode(6212, extraMessage, cause);
  }
  static web3authRequired(extraMessage = "", cause) {
    return NFTCheckoutPluginError.fromCode(6213, extraMessage, cause);
  }
  static web3AuthNotConnected(extraMessage = "", cause) {
    return NFTCheckoutPluginError.fromCode(6214, extraMessage, cause);
  }
  static pluginNotConnected(extraMessage = "", cause) {
    return NFTCheckoutPluginError.fromCode(6223, extraMessage, cause);
  }
}
defineProperty_default()(NFTCheckoutPluginError, "messages", {
  6210: "NFT Checkout Plugin is not initialized",
  6212: "Provider is required..",
  6213: "Web3Auth instance is required while initialization.",
  6214: "Web3Auth is not connected.",
  6223: "NFT Checkout plugin is not connected Yet. Please wait for plugin to connect and listen via `connected` event on the plugin"
});
;// ./src/plugin/IPlugin.ts


const PLUGIN_NAMESPACES = objectSpread2_default()(objectSpread2_default()({}, CHAIN_NAMESPACES), {}, {
  MULTICHAIN: "multichain"
});
const PLUGIN_STATUS = {
  READY: "ready",
  CONNECTING: "connecting",
  CONNECTED: "connected",
  DISCONNECTED: "disconnected",
  ERRORED: "errored"
};
const PLUGIN_EVENTS = objectSpread2_default()({}, PLUGIN_STATUS);
const EVM_PLUGINS = {
  WALLET_SERVICES: "wallet-services",
  NFT_CHECKOUT: "nft-checkout"
};
const SOLANA_PLUGINS = {
  SOLANA: "solana"
};
const WALLET_PLUGINS = objectSpread2_default()(objectSpread2_default()({}, EVM_PLUGINS), SOLANA_PLUGINS);
;// ./src/plugin/index.ts


;// ./src/provider/IProvider.ts
const PROVIDER_EVENTS = {
  INITIALIZED: "initialized",
  ERRORED: "errored"
};
;// ./src/index.ts












module.exports = __webpack_exports__;
/******/ })()
;