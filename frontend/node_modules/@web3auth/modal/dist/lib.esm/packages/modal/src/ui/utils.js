import { get, post } from '@toruslabs/http-helpers';
import { LANGUAGES, LANGUAGE_MAP } from '@web3auth/auth';
import { log } from '@web3auth/no-modal';
import clsx from 'clsx';
import { twMerge } from 'tailwind-merge';

const cache = new Map();

/** Merge classes with tailwind-merge with clsx full feature and memoization */
function cn(...inputs) {
  // Create a cache key using JSON.stringify
  const cacheKey = JSON.stringify(inputs);

  // Check if the result is already cached
  if (cache.has(cacheKey)) {
    return cache.get(cacheKey);
  }

  // If not cached, compute the result
  const result = twMerge(clsx(inputs));

  // Store the result in the cache
  cache.set(cacheKey, result);
  return result;
}
const getBrowserExtensionUrl = (browserType, walletId) => {
  if (walletId !== null && walletId !== void 0 && walletId.startsWith("https://")) return walletId;
  switch (browserType) {
    case "chrome":
      return `https://chrome.google.com/webstore/detail/${walletId}`;
    case "firefox":
      return `https://addons.mozilla.org/firefox/addon/${walletId}`;
    case "edge":
      return `https://microsoftedge.microsoft.com/addons/detail/${walletId}`;
    default:
      return null;
  }
};
const getMobileInstallLink = (os, appId) => {
  if (appId !== null && appId !== void 0 && appId.includes("https://")) {
    return appId;
  }
  switch (os) {
    case "android":
      return `https://play.google.com/store/apps/details?id=${appId}`;
    case "ios":
      return `https://apps.apple.com/app/safepal-wallet/${appId}`;
    default:
      return "";
  }
};
const getOsName = os => {
  switch (os) {
    case "ios":
      return "iOS";
    case "android":
      return "Android";
    default:
      return "";
  }
};
const getBrowserName = browserType => {
  return browserType.charAt(0).toUpperCase() + browserType.slice(1);
};
const getIcons = icon => {
  return `https://images.web3auth.io/login-modal/${icon}.svg`;
};
const passwordlessBackendUrl = "https://api.web3auth.io/passwordless-service";
const getUserCountry = async () => {
  try {
    const result = await get(`${passwordlessBackendUrl}/api/v3/user/location`);
    if (result && result.data.country) return {
      country: result.data.country,
      dialCode: result.data.dial_code
    };
    return null;
  } catch (error) {
    log.error("error getting user country", error);
    return null;
  }
};
const validatePhoneNumber = async phoneNumber => {
  try {
    const result = await post(`${passwordlessBackendUrl}/api/v3/phone_number/validate`, {
      phone_number: phoneNumber
    });
    if (result && result.success) return result;
    return {
      success: false,
      parsed_number: "",
      country_flag: ""
    };
  } catch (error) {
    log.error("error validating phone number", error);
    if (error.status === 400) {
      return {
        success: false,
        parsed_number: "",
        country_flag: ""
      };
    }
    // sending true because we don't want the user to be stuck on a flow
    // if there is an error with the api or something went wrong.
    return {
      success: false,
      parsed_number: "",
      country_flag: ""
    };
  }
};
const getUserLanguage = defaultLanguage => {
  let userLanguage = defaultLanguage;
  if (!userLanguage) {
    const browserLanguage = typeof window !== "undefined" ? window.navigator.userLanguage || window.navigator.language || "en-US" : "en-US";
    userLanguage = browserLanguage.split("-")[0];
  }
  return Object.prototype.hasOwnProperty.call(LANGUAGE_MAP, userLanguage) ? userLanguage : LANGUAGES.en;
};
function formatIOSMobile(params) {
  const encodedUri = encodeURIComponent(params.uri);
  if (params.link.startsWith("http")) return `${params.link}/wc?uri=${encodedUri}`;
  if (params.link) return `${params.link}wc?uri=${encodedUri}`;
  return "";
}
const getErrorMessages = errorCode => {
  if (!errorCode) return "passwordless.something-wrong-error";
  switch (errorCode) {
    case "E001":
      return "passwordless.error-invalid-params";
    case "E002":
      return "passwordless.error-invalid-origin";
    case "E201":
      return "passwordless.error-sending-sms-failed";
    case "E300":
      return "passwordless.error-no-mail-generated";
    case "E301":
      return "passwordless.error-invalid-link";
    case "E302":
      return "passwordless.error-new-link-generated-heading";
    case "E304":
    case "E403":
      return "passwordless.error-max-retry-limit-reached";
    case "E305":
    case "E401":
      return "passwordless.error-invalid-otp";
    case "E306":
      return "passwordless.error-otp-expired";
    case "E400":
      return "passwordless.error-no-sms-generated";
    case "E411":
      return "passwordless.error-plan-limit-reached";
    case "E412":
      return "passwordless.error-recaptcha-verification-failed";
    default:
      return "passwordless.something-wrong-error";
  }
};

export { cn, formatIOSMobile, getBrowserExtensionUrl, getBrowserName, getErrorMessages, getIcons, getMobileInstallLink, getOsName, getUserCountry, getUserLanguage, passwordlessBackendUrl, validatePhoneNumber };
