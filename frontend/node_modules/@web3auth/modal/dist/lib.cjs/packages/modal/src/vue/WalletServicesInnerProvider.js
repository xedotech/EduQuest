'use strict';

var noModal = require('@web3auth/no-modal');
var vue$1 = require('@web3auth/no-modal/vue');
var vue = require('vue');
var useWeb3AuthInner = require('./composables/useWeb3AuthInner.js');

const WalletServicesInnerProvider = vue.defineComponent({
  name: "WalletServicesInnerProvider",
  setup() {
    const web3AuthContext = useWeb3AuthInner.useWeb3AuthInner();
    if (!web3AuthContext) throw noModal.WalletServicesPluginError.fromCode(1000, "`WalletServicesProvider` must be wrapped by `Web3AuthProvider`");
    const {
      getPlugin,
      isInitialized,
      isConnected
    } = web3AuthContext;
    const walletServicesPlugin = vue.shallowRef(null);
    const ready = vue.ref(false);
    const connecting = vue.ref(false);
    vue.watch(isInitialized, newIsInitialized => {
      if (newIsInitialized) {
        const plugin = getPlugin(noModal.EVM_PLUGINS.WALLET_SERVICES);
        walletServicesPlugin.value = plugin;
      }
    });
    vue.watch(isConnected, newIsConnected => {
      if (newIsConnected) {
        var _walletServicesPlugin;
        const plugin = getPlugin(noModal.EVM_PLUGINS.WALLET_SERVICES);
        if (!walletServicesPlugin.value) walletServicesPlugin.value = plugin;
        // when rehydrating, the connectedListener may be registered after the connected event is emitted, we need to check the status here
        if (((_walletServicesPlugin = walletServicesPlugin.value) === null || _walletServicesPlugin === void 0 ? void 0 : _walletServicesPlugin.status) === noModal.CONNECTOR_STATUS.CONNECTED) ready.value = true;
      }
    });
    vue.watch(walletServicesPlugin, (newWalletServicesPlugin, prevWalletServicesPlugin) => {
      const connectedListener = () => {
        ready.value = true;
      };
      const disconnectedListener = () => {
        ready.value = false;
      };
      const connectingListener = () => {
        connecting.value = true;
      };
      // unregister previous listeners
      if (prevWalletServicesPlugin && newWalletServicesPlugin !== prevWalletServicesPlugin) {
        prevWalletServicesPlugin.off(noModal.PLUGIN_EVENTS.CONNECTED, connectedListener);
        prevWalletServicesPlugin.off(noModal.PLUGIN_EVENTS.DISCONNECTED, disconnectedListener);
        prevWalletServicesPlugin.off(noModal.PLUGIN_EVENTS.CONNECTING, connectingListener);
      }
      if (newWalletServicesPlugin && newWalletServicesPlugin !== prevWalletServicesPlugin) {
        newWalletServicesPlugin.on(noModal.PLUGIN_EVENTS.CONNECTED, connectedListener);
        newWalletServicesPlugin.on(noModal.PLUGIN_EVENTS.DISCONNECTED, disconnectedListener);
        newWalletServicesPlugin.on(noModal.PLUGIN_EVENTS.CONNECTING, connectingListener);
      }
    });
    vue.provide(vue$1.WalletServicesContextKey, {
      plugin: walletServicesPlugin,
      ready,
      connecting
    });
  },
  render() {
    var _this$$slots$default;
    return vue.h((_this$$slots$default = this.$slots.default) !== null && _this$$slots$default !== void 0 ? _this$$slots$default : "");
  }
});

exports.WalletServicesInnerProvider = WalletServicesInnerProvider;
