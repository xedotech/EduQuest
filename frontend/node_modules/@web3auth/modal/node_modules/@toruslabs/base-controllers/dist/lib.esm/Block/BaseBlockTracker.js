import _defineProperty from '@babel/runtime/helpers/defineProperty';
import { BaseController } from '../BaseController.js';

const sec = 1000;
const calculateSum = (accumulator, currentValue) => accumulator + currentValue;
class BaseBlockTracker extends BaseController {
  constructor({
    config = {},
    state = {}
  }) {
    super({
      config,
      state
    });

    // config
    _defineProperty(this, "name", "BaseBlockTracker");
    _defineProperty(this, "_blockResetTimeout", void 0);
    this.defaultState = {
      _currentBlock: {
        idempotencyKey: ""
      },
      _isRunning: false
    };
    this.defaultConfig = {
      blockResetDuration: 20 * sec
    };
    this.initialize();

    // bind functions for internal use
    this._onNewListener = this._onNewListener.bind(this);
    this._onRemoveListener = this._onRemoveListener.bind(this);
    this._resetCurrentBlock = this._resetCurrentBlock.bind(this);

    // listen for handler changes
    this._setupInternalEvents();
  }
  isRunning() {
    return this.state._isRunning;
  }
  getCurrentBlock() {
    return this.state._currentBlock;
  }
  async getLatestBlock() {
    // return if available
    if (this.state._currentBlock.idempotencyKey) {
      return this.state._currentBlock;
    }
    // wait for a new latest block
    const latestBlock = await new Promise(resolve => {
      this.once("latest", block => {
        if (block) {
          resolve(block);
        }
      });
    });
    // return newly set current block
    return latestBlock;
  }

  // dont allow module consumer to remove our internal event listeners
  removeAllListeners(eventName) {
    if (eventName) {
      super.removeAllListeners(eventName);
    } else {
      super.removeAllListeners();
    }
    // re-add internal events
    this._setupInternalEvents();
    // trigger stop check just in case
    this._onRemoveListener();
    return this;
  }

  /**
   * To be implemented in subclass.
   */
  _start() {
    // default behavior is noop
  }

  /**
   * To be implemented in subclass.
   */
  _end() {
    // default behavior is noop
  }
  _newPotentialLatest(newBlock) {
    const currentBlock = this.state._currentBlock;
    // only update if block number is higher
    if (currentBlock && newBlock.idempotencyKey === currentBlock.idempotencyKey) {
      return;
    }
    this._setCurrentBlock(newBlock);
  }
  _setupInternalEvents() {
    // first remove listeners for idempotency
    this.removeListener("newListener", this._onNewListener);
    this.removeListener("removeListener", this._onRemoveListener);
    // then add them
    this.on("removeListener", this._onRemoveListener);
    this.on("newListener", this._onNewListener);
  }
  _onNewListener() {
    this._maybeStart();
  }
  _onRemoveListener() {
    // `removeListener` is called *after* the listener is removed
    if (this._getBlockTrackerEventCount() > 0) {
      return;
    }
    this._maybeEnd();
  }
  _maybeStart() {
    if (this.state._isRunning) {
      return;
    }
    this.state._isRunning = true;
    // cancel setting latest block to stale
    this._cancelBlockResetTimeout();
    this._start();
  }
  _maybeEnd() {
    if (!this.state._isRunning) {
      return;
    }
    this.state._isRunning = false;
    this._setupBlockResetTimeout();
    this._end();
  }
  _getBlockTrackerEventCount() {
    const blockTrackerEvents = ["latest", "sync"];
    return blockTrackerEvents.map(eventName => this.listenerCount(eventName)).reduce(calculateSum);
  }
  _setCurrentBlock(newBlock) {
    const oldBlock = this.state._currentBlock;
    this.update({
      _currentBlock: newBlock
    });
    this.emit("latest", newBlock);
    this.emit("sync", {
      oldBlock,
      newBlock
    });
  }
  _setupBlockResetTimeout() {
    // clear any existing timeout
    this._cancelBlockResetTimeout();
    // clear latest block when stale
    this._blockResetTimeout = setTimeout(this._resetCurrentBlock, this.config.blockResetDuration);

    // nodejs - dont hold process open
    if (this._blockResetTimeout.unref) {
      this._blockResetTimeout.unref();
    }
  }
  _cancelBlockResetTimeout() {
    if (this._blockResetTimeout) {
      clearTimeout(this._blockResetTimeout);
    }
  }
  _resetCurrentBlock() {
    this.update({
      _currentBlock: {
        idempotencyKey: ""
      }
    });
  }
}

export { BaseBlockTracker };
