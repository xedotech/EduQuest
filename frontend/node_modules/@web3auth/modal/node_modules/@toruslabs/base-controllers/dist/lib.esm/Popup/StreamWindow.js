import _defineProperty from '@babel/runtime/helpers/defineProperty';
import { BroadcastChannel } from '@toruslabs/broadcast-channel';
import log from 'loglevel';
import { BaseController } from '../BaseController.js';
import { COMMUNICATION_NOTIFICATIONS, BROADCAST_CHANNELS, POPUP_LOADED, SETUP_COMPLETE } from '../enums.js';
import { broadcastChannelOptions, sleep } from '../utils/utils.js';

class StreamWindow extends BaseController {
  constructor({
    config,
    state
  }) {
    super({
      config,
      state
    });
    // if window has been closed by users
    _defineProperty(this, "closed", false);
    this.initialize();
  }
  async open() {
    return new Promise((resolve, reject) => {
      const {
        communicationEngine,
        communicationWindowManager
      } = this.config;
      let popupSuccess = false;
      communicationWindowManager.once(`${this.state.windowId}:closed`, () => {
        this.closed = true;
      });

      // Window is not open yet
      if (!this.config.isWindowAlreadyOpen) {
        // since, we're opening window now, no need to tell window anything
        if (typeof this.config.handleWindowBlockAlert !== "function") reject(new Error("handleWindowBlockAlert is not a function"));
        communicationWindowManager.once(`${this.state.windowId}:iframe-opened`, () => {
          // this means iframe is full screen now
          // there might be multiple block alerts at a time. so, we don't set iframe to close after handling this here
          this.config.handleWindowBlockAlert({
            windowId: this.state.windowId,
            finalUrl: this.state.url.href
          }).then(resolve).catch(reject);
        });

        // Tell the other party to maximize the iframe
        communicationEngine.emit("notification", {
          method: COMMUNICATION_NOTIFICATIONS.IFRAME_STATUS,
          params: {
            isFullScreen: true,
            rid: this.state.windowId
          }
        });
      } else {
        // this is a pre-opened window. so, we need to tell it to redirect to correct url. it's currently waiting on /redirect and uses `RedirectHandler` code
        // Send this window with `windowId` the url to open via bc
        const channelName = `${BROADCAST_CHANNELS.REDIRECT_CHANNEL}_${this.config.instanceId}_${this.state.windowId}`;
        const bc = new BroadcastChannel(channelName, broadcastChannelOptions);
        bc.addEventListener("message", async ev => {
          try {
            log.info(ev, `receiving data on channel: ${bc.name}`);
            const {
              error
            } = ev;
            if (error) {
              // Popup says some error. so, we say it's not really opened
              reject(new Error(error));
              return;
            }
            const {
              message
            } = ev.data;
            if (message === POPUP_LOADED) {
              popupSuccess = true;
              await bc.postMessage({
                data: {
                  url: this.state.url.href,
                  message: "" // No need of a msg
                }
              });
              resolve(this);
              bc.close();
            }
          } catch (error) {
            reject(error);
            bc.close();
            // Something went wrong. so, we close that window
            this.close();
          }
        });

        // We don't know if the other end is ready to receive this msg. So, we keep writing until it receives and sends back something
        // we need backoff strategy
        // we need to wait for first attempt to succeed/fail until the second attempt
        // If we get 429, we need to wait for a while and then try again

        const postMsg = async () => {
          // this never throws
          const localResponse = await bc.postMessage({
            data: {
              message: SETUP_COMPLETE
            }
          });
          return localResponse;
        };
        let currentDelay = bc.type === "server" ? 1000 : 200;
        const recursiveFn = async () => {
          if (!popupSuccess && !this.closed) {
            const localResponse = await postMsg();
            if (bc.type === "server") {
              const serverResponse = localResponse;
              if (serverResponse.status >= 400) {
                // We need to wait for a while and then try again
                currentDelay = Math.round(currentDelay * 1.5);
              }
            }
            await sleep(currentDelay);
            await recursiveFn();
          }
        };
        recursiveFn();
      }
    });
  }
  close() {
    const {
      communicationEngine,
      communicationWindowManager
    } = this.config;
    if (this.config.isWindowAlreadyOpen) {
      communicationEngine.emit("notification", {
        method: COMMUNICATION_NOTIFICATIONS.CLOSE_WINDOW,
        params: {
          windowId: this.state.windowId
        }
      });
      // when popup is blocked by browser, window is not open yet even though `config.isWindowAlreadyOpen is true
      // popup can be opened from modal in the frame and need communicationWindowManager to close it
      communicationWindowManager.emit(`${this.state.windowId}:close`);
    } else {
      communicationWindowManager.emit(`${this.state.windowId}:close`);
    }
  }
}

export { StreamWindow };
