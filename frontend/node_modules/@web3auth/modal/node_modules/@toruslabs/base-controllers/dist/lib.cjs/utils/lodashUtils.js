'use strict';

function omitBy(object, predicate) {
  // Create a new object to store the results
  const result = {};
  // Iterate over all own properties of the object
  for (const [key, value] of Object.entries(object)) {
    if (!predicate(value, key)) {
      result[key] = value;
    }
  }
  return result;
}
function pickBy(object, predicate) {
  // Create a new object to store the results
  const result = {};
  for (const [key, value] of Object.entries(object)) {
    if (predicate(value, key)) {
      result[key] = value;
    }
  }
  return result;
}
function cloneDeep(object) {
  try {
    return structuredClone(object);
  } catch {
    return JSON.parse(JSON.stringify(object, (_, v) => typeof v === "bigint" ? v.toString() : v));
  }
}
function sortBy(arr, key) {
  return arr.slice().sort((a, b) => {
    if (a[key] < b[key]) return -1;
    if (a[key] > b[key]) return 1;
    return 0;
  });
}
function keyBy(arr, key) {
  return arr.reduce((acc, item) => {
    const keyValue = item[key];
    if (typeof keyValue === "string" || typeof keyValue === "number") {
      acc[keyValue.toString()] = item;
    }
    return acc;
  }, {});
}
function mapValues(obj, iteratee) {
  return Object.fromEntries(Object.entries(obj).map(([key, value]) => [key, iteratee(value, key)]));
}

exports.cloneDeep = cloneDeep;
exports.keyBy = keyBy;
exports.mapValues = mapValues;
exports.omitBy = omitBy;
exports.pickBy = pickBy;
exports.sortBy = sortBy;
