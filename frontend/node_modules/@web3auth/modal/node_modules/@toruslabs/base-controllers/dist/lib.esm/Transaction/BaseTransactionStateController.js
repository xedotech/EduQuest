import _objectSpread from '@babel/runtime/helpers/objectSpread2';
import _defineProperty from '@babel/runtime/helpers/defineProperty';
import { BaseController } from '../BaseController.js';
import { pickBy, omitBy } from '../utils/lodashUtils.js';
import { TransactionStatus, TX_EVENTS } from './ITransactionController.js';
import { transactionMatchesNetwork } from '../utils/utils.js';

class BaseTransactionStateManager extends BaseController {
  constructor({
    config,
    state,
    getCurrentChainId
  }) {
    super({
      config,
      state
    });
    _defineProperty(this, "getCurrentChainId", void 0);
    this.defaultConfig = {
      txHistoryLimit: 40
    };
    this.defaultState = {
      transactions: {},
      unapprovedTxs: {},
      currentNetworkTxsList: []
    };
    this.initialize();
    this.getCurrentChainId = getCurrentChainId;
  }
  getUnapprovedTxList() {
    const chainId = this.getCurrentChainId();
    return pickBy(this.state.transactions, transaction => transaction.status === TransactionStatus.unapproved && transactionMatchesNetwork(transaction, chainId));
  }
  getTransaction(txId) {
    const {
      transactions
    } = this.state;
    return transactions[txId];
  }
  updateTransaction(txMeta) {
    // commit txMeta to state
    const txId = txMeta.id;
    txMeta.updated_at = new Date().toISOString();
    this.update({
      transactions: _objectSpread(_objectSpread({}, this.state.transactions), {}, {
        [txId]: txMeta
      })
    });
  }
  setTxStatusRejected(txId) {
    this._setTransactionStatus(txId, TransactionStatus.rejected);
    this._deleteTransaction(txId);
  }

  /**
   * The implementing controller can override this functionality and add custom logic + call super.()
   */
  setTxStatusUnapproved(txId) {
    this._setTransactionStatus(txId, TransactionStatus.unapproved);
  }
  setTxStatusApproved(txId) {
    this._setTransactionStatus(txId, TransactionStatus.approved);
  }
  setTxStatusSigned(txId, isFinalStep) {
    this._setTransactionStatus(txId, TransactionStatus.signed, isFinalStep);
  }
  setTxStatusSubmitted(txId) {
    this._setTransactionStatus(txId, TransactionStatus.submitted);
  }
  setTxStatusDropped(txId) {
    this._setTransactionStatus(txId, TransactionStatus.dropped);
  }
  setTxStatusExpired(txId) {
    this._setTransactionStatus(txId, TransactionStatus.expired);
  }
  setTxStatusConfirmed(txId) {
    this._setTransactionStatus(txId, TransactionStatus.confirmed);
  }
  setTxStatusFailed(txId, error_) {
    const error = !error_ ? new Error("Internal torus failure") : error_;
    const txMeta = this.getTransaction(txId);
    txMeta.error = error;
    this.updateTransaction(txMeta);
    this._setTransactionStatus(txId, TransactionStatus.failed);
  }

  /**
   * Method to determine if the transaction is in a final state
   * @param status - Transaction status
   * @returns boolean if the transaction is in a final state
   */
  isFinalState(status) {
    return status === TransactionStatus.rejected || status === TransactionStatus.submitted || status === TransactionStatus.confirmed || status === TransactionStatus.failed || status === TransactionStatus.cancelled || status === TransactionStatus.expired;
  }

  /**
   * Filters out the unapproved transactions from state
   */
  clearUnapprovedTxs() {
    this.update({
      transactions: omitBy(this.state.transactions, transaction => transaction.status === TransactionStatus.unapproved)
    });
  }

  /**
   * will append new transactions to old txns.
   */
  _addTransactionsToState(transactions) {
    this.update({
      transactions: transactions.reduce((result, newTx) => {
        result[newTx.id] = newTx;
        return result;
      }, this.state.transactions)
    });
  }

  /**
   * will set new txns, override existing if any in state.
   */
  _setTransactionsToState(transactions) {
    this.update({
      transactions: transactions.reduce((result, newTx) => {
        result[newTx.id] = newTx;
        return result;
      }, {})
    });
  }
  _deleteTransaction(targetTransactionId) {
    const {
      transactions
    } = this.state;
    delete transactions[targetTransactionId];
    this.update({
      transactions
    });
  }
  _deleteTransactions(targetTransactionIds) {
    const {
      transactions
    } = this.state;
    targetTransactionIds.forEach(transactionId => {
      delete transactions[transactionId];
    });
    this.update({
      transactions
    });
  }
  _setTransactionStatus(txId, status, isFinalStep) {
    const txMeta = this.getTransaction(txId);
    if (!txMeta) {
      return;
    }
    txMeta.status = status;
    // only updating status so no validation required on txn.
    this.updateTransaction(txMeta);
    this.emit(TX_EVENTS.TX_STATUS_UPDATE, {
      txId,
      status
    });
    if (this.isFinalState(status) || isFinalStep) {
      this.emit(`${txMeta.id}:finished`, txMeta);
    } else {
      this.emit(`${txMeta.id}:${status}`, txId);
    }
  }
}

export { BaseTransactionStateManager };
